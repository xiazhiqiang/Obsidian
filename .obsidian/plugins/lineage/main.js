/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Lineage
});
module.exports = __toCommonJS(main_exports);
var import_obsidian41 = require("obsidian");

// src/view/view.ts
var import_obsidian34 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets2 = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets2.push(c));
  targets2.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block22, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block22(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance123, create_fragment125, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance123 ? instance123(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment125 ? create_fragment125($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/lang/lang.ts
var lang = {
  // open
  ocm_open_in_editor: "Open in editor",
  ocm_open_in_lineage: "Open in Lineage",
  cmd_toggle_lineage_view: "Toggle view",
  card_btn_reveal_in_editor: "Reveal in editor",
  error_parent_not_found: (full) => `Could not find the parent section of ${full}`,
  modals_snapshots_document_loaded: "Opened document",
  error_set_empty_data: "Data is empty, but the file on disk is not",
  error_save_empty_data: "Can't save empty data",
  // create document
  cmd_create_new_document: "Create new document",
  ocm_new_document: "New document",
  ocm_import_from_gingko: "Import from Gingko",
  // add sections
  hk_add_below_and_split: "Add section after and split at cursor",
  card_btn_add_node_below: "Add section after",
  hk_add_above_and_split: "Add section before and split at cursor",
  card_btn_add_node_above: "Add section before",
  hk_add_parent_sibling: "Add section after parent",
  hk_add_child_and_split: "Add subsection and split at cursor",
  card_btn_add_child_node: "Add subsection",
  hkg_create_nodes: "Create",
  modals_snapshots_created_node: "Created section ",
  // edit
  settings_general_maintain_edit_mode: "Maintain editing mode",
  settings_general_maintain_edit_mode_desc: "Maintain editing mode when switching to a different card using the mouse or keyboard",
  card_btn_edit: "Edit",
  hk_enable_edit_mode: "Edit section",
  hk_enable_edit_mode_and_place_cursor_at_start: "Edit section and place cursor at the start",
  hk_enable_edit_mode_and_place_cursor_at_end: "Edit section and place cursor at the end",
  hkg_edit_nodes: "Edit",
  modals_snapshots_updated_node: "Updated section ",
  modal_hk_editor_state_on: "Enable only when the editor is active",
  modal_hk_editor_state_off: "Enable only when the editor is inactive",
  modal_hk_editor_state_both: "Enable regardless of the editor state",
  // save
  card_btn_save: "Save",
  hk_save_changes: "Save changes and exit editor",
  hk_disable_edit_mode: "Cancel changes",
  // delete
  card_btn_delete: "Delete",
  hk_delete_section: "Delete section",
  error_delete_last_node: "Cannot delete this section",
  hkg_delete_nodes: "Delete",
  modals_snapshots_deleted_section: "Deleted section ",
  // clipboard
  cm_copy: "Copy",
  cm_copy_branches: "Copy branches",
  cm_copy_branch: "Copy branch",
  cm_copy_branches_wo_formatting: "Copy branches as plain text",
  cm_copy_branch_wo_formatting: "Copy branch as plain text",
  cm_copy_node_wo_subitems: "Copy sections",
  cm_copy_nodes_wo_subitems: "Copy section",
  hk_copy_node: "Copy branch",
  hk_copy_node_unformatted: "Copy branch as plain text",
  hk_copy_node_without_subitems: "Copy section",
  cm_copy_link_to_block: "Copy link to block",
  toolbar_copy_search_results: "Copy search results",
  toolbar_copy_search_results_wo_subitems: "Copy search results without sub-items",
  toolbar_cut_search_results: "Cut search results",
  hkg_clipboard: "Clipboard",
  modals_snapshots_cut_section: "Cut section ",
  cm_cut: "Cut",
  hk_cut_node: "Cut branch",
  cm_paste: "Paste",
  hk_paste_node: "Paste branch",
  modals_snapshots_pasted_section: "Pasted section ",
  error_cant_paste: "Paste command failed. Try pasting directly into a card",
  /*hk_notice_copy: (
      size: number,
      formatted: boolean,
      type: 'branch' | 'section',
  ) => {
      if (size === 0) return null;
      return type === 'branch'
          ? size === 1
              ? formatted
                  ? null
                  : 'Unformatted branch copied to clipboard'
              : formatted
                ? `${size} branches copied to clipboard`
                : `${size} unformatted branches copied to clipboard`
          : size === 1
            ? null
            : size + ' sections copied to clipboard';
  },*/
  // merge
  cm_merge_above: "Merge with branch above",
  cm_merge_below: "Merge with branch below",
  hk_merge_with_node_above: "Merge with branch above",
  hk_merge_with_node_below: "Merge with branch below",
  error_hk_cant_merge_multiple_nodes: "Cannot merge multiple branches",
  hkg_merge_nodes: "Merge",
  modals_snapshots_merged_node: "Merged section ",
  // move
  hk_move_node_up: "Move branch up",
  hk_move_node_down: "Move branch down",
  hk_move_node_right: "Move branch right",
  hk_move_node_left: "Move branch left",
  hkg_move_nodes: "Move",
  modals_snapshots_moved_node: "Moved section ",
  // dnd
  modals_snapshots_dropped_node: "Dropped section ",
  // split
  cm_split_node: "Split section",
  error_cm_cant_split_node_that_has_children: "Cannot split a section that has sub-items",
  error_cm_cant_split_node_identical: "The result is the same as the input",
  modals_snapshots_split_node: "Split section ",
  // undo
  controls_history: "History",
  controls_history_undo: "Undo",
  controls_history_redo: "Redo",
  hk_undo_change: "Undo change",
  hk_redo_change: "Redo change",
  error_apply_snapshot_while_editing: "Cannot apply a snapshot while editing",
  hkg_history: "History",
  // extract
  cmd_extract_branch: "Extract branch to a new document",
  cm_extract_branch: "Extract branch",
  cm_extract_section: "Extract section",
  modals_snapshots_extracted_node: "Extracted section ",
  // export
  cm_export_document: "Export document",
  cm_eject_document: "Eject document",
  cm_export_selection: "Export",
  cm_export_section: "Export section",
  cm_export_branch_with_subitems: "Export branch",
  cm_export_branch_wo_subitems: "Export section",
  cmd_export_branches_with_subitems: "Export branches",
  cmd_export_nodes_wo_subitems: "Export sections",
  // document format
  settings_general_default_format: "Default format",
  cm_document_format: "Document format",
  settings_format_html_elements: "HTML elements (experimental)",
  settings_format_html_comments: "HTML comments",
  settings_format_outline: "Outline",
  cm_change_format_to_html_element: "Format: HTML elements (experimental)",
  cm_change_format_to_document: "Format: HTML comments",
  cm_change_format_to_outline: "Format: outline",
  // format
  cm_format_headings: "Format headings",
  modals_snapshots_formatted_headings: "Formatted headings",
  // search
  tlb_search_toggle: "Toggle search input",
  tlb_search_show_all_nodes: "Show all sections",
  tlb_search_fuzzy_search: "Fuzzy search",
  tlb_search_previous_result: "Previous result",
  tlb_search_next_result: "Next result",
  tlb_search_clear: "Clear",
  hk_toggle_search_input: "Toggle search",
  hkg_search: "Search",
  // select
  hk_extend_select_up: "Extend selection up",
  hk_extend_select_down: "Extend selection down",
  hk_extend_select_to_start_of_group: "Extend selection to start of group",
  hk_extend_select_to_end_of_group: "Extend selection to end of group",
  hk_extend_select_to_start_of_column: "Extend selection to start of column",
  hk_extend_select_to_end_of_column: "Extend selection to end of column",
  hkg_selection: "Select",
  hk_select_all: "Select all sections",
  // navigate spatially
  hk_navigate_to_next_node: "Select next section",
  hk_navigate_to_previous_node: "Select previous section",
  hk_go_up: "Go up",
  hk_go_down: "Go down",
  hk_go_right: "Go right",
  hk_go_Left: "Go left",
  hk_go_to_beginning_of_group: "Go to start of group",
  hk_go_to_end_of_group: "Go to end of group",
  hk_go_to_beginning_of_column: "Go to start of column",
  hk_go_to_end_of_column: "Go to end of column",
  hk_select_parent: "Select parent section",
  hkg_navigation: "Navigate",
  hk_select_previous_sibling: "Select previous sibling",
  hk_select_next_sibling: "Select next sibling",
  // navigate node history
  hk_navigate_back: "Navigate back",
  hk_navigate_forward: "Navigate forward",
  tlb_navigation_navigate_back: "Navigate back",
  tlb_navigation_navigate_forward: "Navigate forward",
  // zoom
  controls_zoom_in: "Zoom in",
  controls_zoom_out: "Zoom out",
  controls_zoom_reset: "Reset (hold shift to undo)",
  controls_zoom_presets: "Zoom menu",
  hk_zoom_in: "Zoom in",
  hk_zoom_out: "Zoom out",
  hk_zoom_reset: "Reset zoom",
  hkg_zoom: "Zoom",
  // scroll
  hk_scroll_left: "Scroll left",
  hk_scroll_right: "Scroll right",
  hk_scroll_up: "Scroll up",
  hk_scroll_down: "Scroll down",
  hk_align_branch: "Center active branch",
  controls_toggle_scrolling_mode_horizontal: "Always center active card horizontally",
  controls_toggle_scrolling_mode_vertical: "Always center active card vertically",
  cmd_toggle_horizontal_scrolling_mode: `Toggle 'always center active card horizontally'`,
  cmd_toggle_vertical_scrolling_mode: `Toggle 'always center active card vertically'`,
  card_btn_scroll_to_reveal: "Reveal",
  hkg_scrolling: "Scroll",
  // theme
  settings_theme_bg: "Background color",
  settings_theme_active_branch_bg: "Active branch background color",
  settings_theme_active_branch_color: "Active branch text color",
  settings_appearance_font_size: "Font size",
  settings_appearance_headings_font_size: "Headings font size (em)",
  settings_appearance_inactive_node_opacity: "Inactive cards opacity",
  // layout
  settings_layout_card_width: "Card width",
  settings_layout_limit_card_height: "Limit card height",
  settings_always_show_card_buttons: "Show buttons on all cards",
  settings_always_show_card_buttons_desc: "Show card buttons on all cards, not just the active one",
  // outline
  settings_layout_indentation_width: "Card indentation",
  controls_single_column: "Outline mode",
  hk_toggle_outline_mode: `Toggle outline mode`,
  card_btn_collapse_node: "Collapse",
  card_btn_expand_node: "Expand",
  hk_outline_toggle_collapse: "Collapse/expand section",
  hk_outline_toggle_collapse_all: "Collapse/expand all sections",
  hkg_outline: "Outline",
  // toolbar
  settings_vertical_toolbar_icons: "Vertical toolbar buttons",
  settings_vertical_toolbar_icons_desc: "Configure what buttons appear in the vertical toolbar",
  // space between cards
  controls_gap_between_cards: "Space between cards",
  cmd_space_between_cards: `Toggle 'space between cards'`,
  settings_layout_space_between_cards: "Space between cards",
  // sidebar
  toolbar_toggle_left_sidebar: "Left sidebar",
  controls_toggle_minimap: "Document minimap",
  cmd_toggle_minimap: "Toggle document minimap",
  cmd_toggle_left_sidebar: "Toggle left sidebar",
  // recent sections
  sidebar_tab_recent_nodes: "Recently selected sections",
  sidebar_no_recent_nodes: "No recent sections",
  // pin sections
  cm_unpin_from_left_sidebar: "Unpin from left sidebar",
  cm_pin_in_left_sidebar: "Pin in left sidebar",
  cmd_toggle_pin_in_left_sidebar: `Toggle 'pin section in left sidebar'`,
  sidebar_tab_pinned_nodes: "Pinned sections",
  sidebar_no_pinned_nodes: "No pinned sections",
  // rules
  modals_rules_add_rule: "New rule",
  modals_rules_no_rules: "No rules",
  controls_rules: "Card style rules",
  modals_rules_matches: "Number of matches",
  modals_rules_drag_handle: "Change priority",
  modals_rules_tab_global_rules: "Global rules",
  modals_rules_tab_document_rules: "Document rules",
  modals_rules_rule_cm_move_to_document: "Move to document rules",
  modals_rules_rule_cm_move_to_global: "Move to global rules",
  // sort
  cmd_sort_child_nodes_asc: "Sort subsections: ascending order",
  cmd_sort_child_nodes_desc: "Sort subsections: descending order",
  cm_sort_child: "Sort subsections",
  cm_sort_child_nodes_asc: "Ascending order",
  cm_sort_child_nodes_desc: "Descending order",
  modals_snapshots_sorted_child_nodes: "Sorted subsections of section ",
  // settings
  controls_settings: "Settings",
  controls_toggle_bar: "Toggle controls bar",
  settings_appearance: "Appearance",
  settings_layout: "Layout",
  settings_reset: "Reset",
  // general settings
  settings_general_link_split: "Open in new split",
  settings_general_link_tab: "Open in new tab",
  settings_general_link_behavior: "Default link behavior",
  // hotkeys
  modals_hk_input_placeholder: "Filter",
  modals_hk_editor_cancel: "Cancel",
  controls_hotkeys: "Hotkeys",
  modals_hk_reset_hotkeys: "Reset all hotkeys",
  modals_hk_load_alt_hotkeys_preset: "Apply preset: use 'Alt' as the primary modifier",
  modals_hk_load_nav_while_editing_preset: "Apply preset: navigate while editing using 'Alt+Shift+Arrow keys'",
  error_generic: "Something went wrong\nYou might find additional details in the developer console"
};

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[10]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[11]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[10]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[10];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[6],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${/*name*/
      ctx[0]} ${/*$$props*/
      ctx[7].class ?? ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        129 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${/*name*/
        ctx2[0]} ${/*$$props*/
        ctx2[7].class ?? ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-down-wide-narrow" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 16 4 4 4-4" }],
    ["path", { "d": "M7 20V4" }],
    ["path", { "d": "M11 4h10" }],
    ["path", { "d": "M11 8h7" }],
    ["path", { "d": "M11 12h4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_down_wide_narrow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_down_wide_narrow_default = Arrow_down_wide_narrow;

// node_modules/lucide-svelte/dist/icons/arrow-left.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m12 19-7-7 7-7" }], ["path", { "d": "M19 12H5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_left_default = Arrow_left;

// node_modules/lucide-svelte/dist/icons/arrow-right.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "m12 5 7 7-7 7" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var arrow_right_default = Arrow_right;

// node_modules/lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up-narrow-wide" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 8 4-4 4 4" }],
    ["path", { "d": "M7 4v16" }],
    ["path", { "d": "M11 12h4" }],
    ["path", { "d": "M11 16h7" }],
    ["path", { "d": "M11 20h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up_narrow_wide = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var arrow_up_narrow_wide_default = Arrow_up_narrow_wide;

// node_modules/lucide-svelte/dist/icons/chevron-down.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var chevron_down_default = Chevron_down;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/chevron-up.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m18 15-6-6-6 6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var chevron_up_default = Chevron_up;

// node_modules/lucide-svelte/dist/icons/clipboard-paste.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "clipboard-paste" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"
      }
    ],
    [
      "path",
      {
        "d": "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"
      }
    ],
    ["path", { "d": "m17 10 4 4-4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Clipboard_paste = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var clipboard_paste_default = Clipboard_paste;

// node_modules/lucide-svelte/dist/icons/clock.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "clock" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    ["polyline", { "points": "12 6 12 12 16 14" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Clock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var clock_default = Clock;

// node_modules/lucide-svelte/dist/icons/copy.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "copy" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "width": "14",
        "height": "14",
        "x": "8",
        "y": "8",
        "rx": "2",
        "ry": "2"
      }
    ],
    [
      "path",
      {
        "d": "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Copy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var copy_default = Copy;

// node_modules/lucide-svelte/dist/icons/eye.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "eye" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Eye = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var eye_default = Eye;

// node_modules/lucide-svelte/dist/icons/file-minus.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-minus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var file_minus_default = File_minus;

// node_modules/lucide-svelte/dist/icons/file-output.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-output" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M4 7V4a2 2 0 0 1 2-2 2 2 0 0 0-2 2"
      }
    ],
    [
      "path",
      {
        "d": "M4.063 20.999a2 2 0 0 0 2 1L18 22a2 2 0 0 0 2-2V7l-5-5H6"
      }
    ],
    ["path", { "d": "m5 11-3 3" }],
    ["path", { "d": "m5 17-3-3h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_output = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var file_output_default = File_output;

// node_modules/lucide-svelte/dist/icons/file-pen.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v10"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M10.4 12.6a2 2 0 1 1 3 3L8 21l-4 1 1-4Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var file_pen_default = File_pen;

// node_modules/lucide-svelte/dist/icons/file-plus.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment16(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }],
    ["path", { "d": "M12 18v-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
  }
};
var file_plus_default = File_plus;

// node_modules/lucide-svelte/dist/icons/file-symlink.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment17(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-symlink" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m10 18 3-3-3-3" }],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M4 11V4a2 2 0 0 1 2-2h9l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h7"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_symlink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
  }
};
var file_symlink_default = File_symlink;

// node_modules/lucide-svelte/dist/icons/file-text.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment18(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-text" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M10 9H8" }],
    ["path", { "d": "M16 13H8" }],
    ["path", { "d": "M16 17H8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_text = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var file_text_default = File_text;

// node_modules/lucide-svelte/dist/icons/file-up.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment19(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M12 12v6" }],
    ["path", { "d": "m15 15-3-3-3 3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
  }
};
var file_up_default = File_up;

// node_modules/lucide-svelte/dist/icons/focus.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment20(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "focus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "3" }],
    ["path", { "d": "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { "d": "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { "d": "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { "d": "M7 21H5a2 2 0 0 1-2-2v-2" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Focus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var focus_default = Focus;

// node_modules/lucide-svelte/dist/icons/globe.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment21(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "globe" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    [
      "path",
      {
        "d": "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"
      }
    ],
    ["path", { "d": "M2 12h20" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Globe = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
  }
};
var globe_default = Globe;

// node_modules/lucide-svelte/dist/icons/grip-vertical.svelte
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment22(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "grip-vertical" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "9", "cy": "12", "r": "1" }],
    ["circle", { "cx": "9", "cy": "5", "r": "1" }],
    ["circle", { "cx": "9", "cy": "19", "r": "1" }],
    ["circle", { "cx": "15", "cy": "12", "r": "1" }],
    ["circle", { "cx": "15", "cy": "5", "r": "1" }],
    ["circle", { "cx": "15", "cy": "19", "r": "1" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Grip_vertical = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
  }
};
var grip_vertical_default = Grip_vertical;

// node_modules/lucide-svelte/dist/icons/heading-1.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment23(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "heading-1" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M4 12h8" }],
    ["path", { "d": "M4 18V6" }],
    ["path", { "d": "M12 18V6" }],
    ["path", { "d": "m17 12 3-2v8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Heading_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
  }
};
var heading_1_default = Heading_1;

// node_modules/lucide-svelte/dist/icons/history.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment24(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "history" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }],
    ["path", { "d": "M12 7v5l4 2" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var History = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
  }
};
var history_default = History;

// node_modules/lucide-svelte/dist/icons/info.svelte
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment25(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "info" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    ["path", { "d": "M12 16v-4" }],
    ["path", { "d": "M12 8h.01" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Info = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, {});
  }
};
var info_default = Info;

// node_modules/lucide-svelte/dist/icons/keyboard.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment26(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "keyboard" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M10 8h.01" }],
    ["path", { "d": "M12 12h.01" }],
    ["path", { "d": "M14 8h.01" }],
    ["path", { "d": "M16 12h.01" }],
    ["path", { "d": "M18 8h.01" }],
    ["path", { "d": "M6 8h.01" }],
    ["path", { "d": "M7 16h10" }],
    ["path", { "d": "M8 12h.01" }],
    [
      "rect",
      {
        "x": "2",
        "y": "4",
        "width": "20",
        "height": "16",
        "rx": "2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Keyboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, {});
  }
};
var keyboard_default = Keyboard;

// node_modules/lucide-svelte/dist/icons/merge.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment27(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "merge" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m8 6 4-4 4 4" }],
    [
      "path",
      {
        "d": "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"
      }
    ],
    ["path", { "d": "m20 22-5-5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Merge = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, {});
  }
};
var merge_default = Merge;

// node_modules/lucide-svelte/dist/icons/minus.svelte
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment28(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "minus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
  }
};
var minus_default = Minus;

// node_modules/lucide-svelte/dist/icons/more-vertical.svelte
function create_default_slot28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment29(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "more-vertical" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot28] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "1" }],
    ["circle", { "cx": "12", "cy": "5", "r": "1" }],
    ["circle", { "cx": "12", "cy": "19", "r": "1" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var More_vertical = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, {});
  }
};
var more_vertical_default = More_vertical;

// node_modules/lucide-svelte/dist/icons/palette.svelte
function create_default_slot29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment30(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "palette" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot29] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "circle",
      {
        "cx": "13.5",
        "cy": "6.5",
        "r": ".5",
        "fill": "currentColor"
      }
    ],
    [
      "circle",
      {
        "cx": "17.5",
        "cy": "10.5",
        "r": ".5",
        "fill": "currentColor"
      }
    ],
    [
      "circle",
      {
        "cx": "8.5",
        "cy": "7.5",
        "r": ".5",
        "fill": "currentColor"
      }
    ],
    [
      "circle",
      {
        "cx": "6.5",
        "cy": "12.5",
        "r": ".5",
        "fill": "currentColor"
      }
    ],
    [
      "path",
      {
        "d": "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Palette = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, {});
  }
};
var palette_default = Palette;

// node_modules/lucide-svelte/dist/icons/panel-left-dashed.svelte
function create_default_slot30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment31(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "panel-left-dashed" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot30] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2"
      }
    ],
    ["path", { "d": "M9 14v1" }],
    ["path", { "d": "M9 19v2" }],
    ["path", { "d": "M9 3v2" }],
    ["path", { "d": "M9 9v1" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Panel_left_dashed = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, {});
  }
};
var panel_left_dashed_default = Panel_left_dashed;

// node_modules/lucide-svelte/dist/icons/panel-right-dashed.svelte
function create_default_slot31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment32(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "panel-right-dashed" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot31] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "rect",
      {
        "width": "18",
        "height": "18",
        "x": "3",
        "y": "3",
        "rx": "2"
      }
    ],
    ["path", { "d": "M15 14v1" }],
    ["path", { "d": "M15 19v2" }],
    ["path", { "d": "M15 3v2" }],
    ["path", { "d": "M15 9v1" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Panel_right_dashed = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
  }
};
var panel_right_dashed_default = Panel_right_dashed;

// node_modules/lucide-svelte/dist/icons/pen.svelte
function create_default_slot32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment33(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot32] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
  }
};
var pen_default = Pen;

// node_modules/lucide-svelte/dist/icons/pencil.svelte
function create_default_slot33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment34(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pencil" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ],
    ["path", { "d": "m15 5 4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pencil = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
  }
};
var pencil_default = Pencil;

// node_modules/lucide-svelte/dist/icons/pin.svelte
function create_default_slot34(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment35(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pin" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot34] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "line",
      {
        "x1": "12",
        "x2": "12",
        "y1": "17",
        "y2": "22"
      }
    ],
    [
      "path",
      {
        "d": "M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pin = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, {});
  }
};
var pin_default = Pin;

// node_modules/lucide-svelte/dist/icons/plus.svelte
function create_default_slot35(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment36(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot35] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "M12 5v14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
  }
};
var plus_default = Plus;

// node_modules/lucide-svelte/dist/icons/redo-2.svelte
function create_default_slot36(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment37(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "redo-2" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot36] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m15 14 5-5-5-5" }],
    [
      "path",
      {
        "d": "M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Redo_2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, {});
  }
};
var redo_2_default = Redo_2;

// node_modules/lucide-svelte/dist/icons/rotate-ccw.svelte
function create_default_slot37(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment38(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-ccw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot37] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_ccw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
  }
};
var rotate_ccw_default = Rotate_ccw;

// node_modules/lucide-svelte/dist/icons/rotate-cw.svelte
function create_default_slot38(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment39(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-cw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot38] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"
      }
    ],
    ["path", { "d": "M21 3v5h-5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_cw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
  }
};
var rotate_cw_default = Rotate_cw;

// node_modules/lucide-svelte/dist/icons/save.svelte
function create_default_slot39(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment40(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "save" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot39] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
      }
    ],
    ["polyline", { "points": "17 21 17 13 7 13 7 21" }],
    ["polyline", { "points": "7 3 7 8 15 8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Save = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
  }
};
var save_default = Save;

// node_modules/lucide-svelte/dist/icons/scan-search.svelte
function create_default_slot40(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment41(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "scan-search" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot40] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { "d": "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { "d": "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { "d": "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }],
    ["path", { "d": "m16 16-1.9-1.9" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Scan_search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
  }
};
var scan_search_default = Scan_search;

// node_modules/lucide-svelte/dist/icons/scissors.svelte
function create_default_slot41(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment42(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "scissors" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot41] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "6", "cy": "6", "r": "3" }],
    ["path", { "d": "M8.12 8.12 12 12" }],
    ["path", { "d": "M20 4 8.12 15.88" }],
    ["circle", { "cx": "6", "cy": "18", "r": "3" }],
    ["path", { "d": "M14.8 14.8 20 20" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Scissors = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
  }
};
var scissors_default = Scissors;

// node_modules/lucide-svelte/dist/icons/search.svelte
function create_default_slot42(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment43(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "search" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot42] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "11", "cy": "11", "r": "8" }],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
  }
};
var search_default = Search;

// node_modules/lucide-svelte/dist/icons/settings.svelte
function create_default_slot43(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment44(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "settings" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot43] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Settings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
  }
};
var settings_default = Settings;

// node_modules/lucide-svelte/dist/icons/split.svelte
function create_default_slot44(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment45(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "split" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot44] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M16 3h5v5" }],
    ["path", { "d": "M8 3H3v5" }],
    [
      "path",
      {
        "d": "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"
      }
    ],
    ["path", { "d": "m15 9 6-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Split = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, {});
  }
};
var split_default = Split;

// node_modules/lucide-svelte/dist/icons/text.svelte
function create_default_slot45(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment46(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "text" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot45] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M17 6.1H3" }],
    ["path", { "d": "M21 12.1H3" }],
    ["path", { "d": "M15.1 18H3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Text = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, {});
  }
};
var text_default = Text;

// node_modules/lucide-svelte/dist/icons/trash.svelte
function create_default_slot46(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment47(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "trash" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot46] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 6h18" }],
    [
      "path",
      {
        "d": "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"
      }
    ],
    [
      "path",
      {
        "d": "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Trash = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
  }
};
var trash_default = Trash;

// node_modules/lucide-svelte/dist/icons/undo-2.svelte
function create_default_slot47(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment48(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "undo-2" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot47] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M9 14 4 9l5-5" }],
    [
      "path",
      {
        "d": "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Undo_2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, {});
  }
};
var undo_2_default = Undo_2;

// node_modules/lucide-svelte/dist/icons/x.svelte
function create_default_slot48(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment49(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "x" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot48] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M18 6 6 18" }], ["path", { "d": "m6 6 12 12" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var X = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, {});
  }
};
var x_default = X;

// src/view/components/container/context.ts
var getPlugin = () => {
  return getContext("plugin");
};
var getView = () => {
  return getContext("view");
};

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/lib/store/derived.ts
var derived2 = (source, mapper) => {
  const subscribers = /* @__PURE__ */ new Set();
  let derivedValue;
  let unsubFromSource = null;
  return {
    subscribe: (run2) => {
      subscribers.add(run2);
      if (!unsubFromSource) {
        unsubFromSource = source.subscribe(
          (value, action, initialRun) => {
            if (action || initialRun) {
              const newValue = mapper(value, action);
              if (newValue !== derivedValue) {
                derivedValue = newValue;
                for (const sub of subscribers) {
                  sub(derivedValue, action, initialRun);
                }
              }
            }
          }
        );
      } else {
        run2(derivedValue, void 0, true);
      }
      return () => {
        subscribers.delete(run2);
        if (unsubFromSource && subscribers.size === 0) {
          unsubFromSource();
          unsubFromSource = null;
        }
      };
    }
  };
};

// src/stores/view/derived/ui-controls-store.ts
var uiControlsStore = (view) => derived2(view.viewStore, (state2) => state2.ui.controls);

// src/view/components/container/shared/button.svelte
function create_fragment50(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr(button, "class", button_class_value = "lineage-view-button " + /*classes*/
      ctx[3]);
      attr(
        button,
        "data-active",
        /*active*/
        ctx[4]
      );
      attr(
        button,
        "data-tooltip-position",
        /*tooltipPosition*/
        ctx[1]
      );
      button.disabled = /*disabled*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      1) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*classes*/
      8 && button_class_value !== (button_class_value = "lineage-view-button " + /*classes*/
      ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*active*/
      16) {
        attr(
          button,
          "data-active",
          /*active*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*tooltipPosition*/
      2) {
        attr(
          button,
          "data-tooltip-position",
          /*tooltipPosition*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        button.disabled = /*disabled*/
        ctx2[2];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label } = $$props;
  let { tooltipPosition } = $$props;
  let { disabled = false } = $$props;
  let { classes = "" } = $$props;
  let { active = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("tooltipPosition" in $$props2)
      $$invalidate(1, tooltipPosition = $$props2.tooltipPosition);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
    if ("active" in $$props2)
      $$invalidate(4, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    label,
    tooltipPosition,
    disabled,
    classes,
    active,
    $$scope,
    slots,
    click_handler
  ];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      label: 0,
      tooltipPosition: 1,
      disabled: 2,
      classes: 3,
      active: 4
    });
  }
};
var button_default = Button;

// src/stores/settings/derived/scrolling-store.ts
var ScrollSettingsStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.scrolling);
var showMinimapStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.showMinimap);

// src/stores/settings/derived/view-settings-store.ts
var ShowLeftSidebarStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.showLeftSidebar);
var LeftSidebarActiveTabStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.leftSidebarActiveTab);
var ApplyGapBetweenCardsStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.applyGapBetweenCards);
var OutlineModeStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.outlineMode);
var MaintainEditMode = (view) => derived2(view.plugin.settings, (state2) => state2.view.maintainEditMode);
var AlwaysShowCardButtons = (view) => derived2(view.plugin.settings, (state2) => state2.view.alwaysShowCardButtons);
var HiddenVerticalToolbarButtons = (plugin) => derived2(
  plugin.settings,
  (state2) => state2.view.hiddenVerticalToolbarButtons
);

// src/helpers/load-custom-icons.ts
var import_obsidian = require("obsidian");
var svgWrapper = (innerSVG, mode = "stroke") => `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="svg-icon" ${mode === "fill" ? 'stroke="transparent" fill="currentColor"' : 'stroke="currentColor" fill="transparent"'}> ${innerSVG.trim().replace(/\n/g, "")}</svg>`;
var cards = {
  name: "lineage-cards",
  svg: `
    <path
    d="m 13.115181,16.644424 h 6.605231 v 5.578301 H 13.115181 Z M 4.3082043,9.2066877 H 10.913436 V 14.784989 H 4.3082043 Z m 8.8069767,0 h 6.605231 v 5.5783013 h -6.605231 z m 0,-7.4377346 h 6.605231 V 7.347254 h -6.605231 z"
    />
  `,
  mode: "fill"
};
var split = {
  name: "lineage-split",
  svg: `<path d="M16 3h5v5"/><path d="M8 3H3v5"/><path d="M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"/><path d="m15 9 6-6"/>`,
  mode: "stroke"
};
var alignH = {
  name: "lineage-align-horizontal",
  svg: `<g> 
            <rect width="20" height="12" x="2" y="6" rx="2"/> 
            <line x1="12" y1="0" x2="12" y2="24" stroke-dasharray="4 3" />
    </g> `,
  mode: "stroke"
};
var alignV = {
  name: "lineage-align-vertical",
  svg: `<g> 
            <rect width="18" height="12" x="3" y="6" rx="2"/> 
        
         <path
      <path
       style="stroke-width:2;stroke-dasharray:8, 2;stroke-dashoffset:0"
       d="m -14.007348,12.000818 c 15.3564398,3.95e-4 30.79516,0.16535 46.069016,5.77e-4"
       id="path5"
       sodipodi:nodetypes="cc" />

    </g> `,
  mode: "stroke"
};
var gap = {
  name: "cards-gap",
  svg: `  
                <rect width="20" height="12" x="-11.600009" y="6" rx="2" />
                <rect
                    width="20"
                    height="12"
                    x="16.534304"
                    y="5.9783392"
                    rx="2"
                />
          `,
  mode: "stroke"
};
var outline = {
  name: "outline",
  svg: `<path d="M 7.563873,12 H 21.24698" />
  <path d="M 7.56116,18 H 21.159058" />
  <path d="M3 6h18" /> `,
  mode: "stroke"
};
var cursorOff = {
  name: "cursor-off",
  svg: `<path d="m 8.0036101,3.8555957 h 1 a 3,3 0 0 1 2.9999999,3 3,3 0 0 1 3,-3 h 1" />
  <path d="m 16.00361,19.855596 h -1 a 3,3 0 0 1 -3,-3 3,3 0 0 1 -2.9999999,3 h -1" />
  <path d="M 12.00361,6.8555957 V 16.855596" />
  <path d="M 3.0758124,4.7436822 20.548737,18.693141" />`,
  mode: "stroke"
};
var cursor = {
  name: "cursor",
  svg: `<path d="m 8.0036101,3.8555957 h 1 a 3,3 0 0 1 2.9999999,3 3,3 0 0 1 3,-3 h 1" />
  <path d="m 16.00361,19.855596 h -1 a 3,3 0 0 1 -3,-3 3,3 0 0 1 -2.9999999,3 h -1" />
  <path d="M 12.00361,6.8555957 V 16.855596" />`,
  mode: "stroke"
};
var customIcons = {
  cards,
  split,
  alignH,
  alignV,
  gap,
  outline,
  cursor,
  cursorOff
};
var loadCustomIcons = () => {
  for (const icon of Object.values(customIcons)) {
    icon.svg = svgWrapper(icon.svg, icon.mode);
    (0, import_obsidian.addIcon)(icon.name, icon.svg);
  }
};

// src/view/components/container/toolbar-vertical/vertical-toolbar-actions.ts
var VerticalToolbarActions = class {
  constructor(view) {
    this.view = view;
    this.toggleHelp = () => {
      this.view.viewStore.dispatch({ type: "view/hotkeys/toggle-modal" });
    };
    this.toggleStyleRules = () => {
      this.view.viewStore.dispatch({
        type: "view/style-rules/toggle-modal"
      });
    };
    this.toggleSettings = () => {
      this.view.viewStore.dispatch({ type: "view/settings/toggle-modal" });
    };
    this.toggleMinimap = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/toggle-minimap"
      });
    };
    this.toggleScrollModeH = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/toggle-horizontal-scrolling-mode"
      });
    };
    this.toggleScrollModeV = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/toggle-vertical-scrolling-mode"
      });
    };
    this.toggleGap = () => {
      this.view.plugin.settings.dispatch({
        type: "view/modes/gap-between-cards/toggle"
      });
    };
    this.toggleOutlineMode = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/modes/toggle-outline-mode"
      });
    };
    this.zoomIn = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { direction: "in" }
      });
    };
    this.zoomOut = () => {
      this.view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { direction: "out" }
      });
    };
  }
};

// src/view/components/container/toolbar-vertical/vertical-toolbar-buttons-list.ts
var VerticalToolbarButtonsList = (view) => {
  const hiddenControlsBarButtons = HiddenVerticalToolbarButtons(view.plugin);
  const h = new VerticalToolbarActions(view);
  return derived([hiddenControlsBarButtons], ([hiddenControlsBarButtons2]) => {
    const set = new Set(hiddenControlsBarButtons2);
    const buttons = [
      {
        id: "minimap",
        buttons: [
          {
            label: lang.controls_toggle_minimap,
            onClick: h.toggleMinimap,
            icon: panel_right_dashed_default,
            id: "minimap"
          }
        ]
      },
      {
        id: "settings",
        buttons: [
          {
            label: lang.controls_settings,
            onClick: h.toggleSettings,
            icon: settings_default,
            id: "settings"
          },
          {
            label: lang.controls_hotkeys,
            onClick: h.toggleHelp,
            icon: keyboard_default,
            id: "hotkeys"
          },
          {
            label: lang.controls_rules,
            onClick: h.toggleStyleRules,
            icon: palette_default,
            id: "style-rules"
          }
        ]
      },
      {
        id: "scroll",
        buttons: [
          {
            label: lang.controls_toggle_scrolling_mode_horizontal,
            onClick: h.toggleScrollModeH,
            icon: customIcons.alignH,
            id: "center-active-node-h"
          },
          {
            label: lang.controls_toggle_scrolling_mode_vertical,
            onClick: h.toggleScrollModeV,
            icon: customIcons.alignV,
            id: "center-active-node-v"
          },
          {
            label: lang.controls_single_column,
            onClick: h.toggleOutlineMode,
            icon: customIcons.outline,
            id: "outline-mode"
          },
          {
            label: lang.controls_gap_between_cards,
            onClick: h.toggleGap,
            icon: customIcons.gap,
            id: "space-between-cards"
          }
        ]
      }
    ];
    return buttons.map((group) => {
      return {
        id: group.id,
        buttons: group.buttons.filter((b) => !set.has(b.id))
      };
    }).filter((g) => g.buttons.length > 0);
  });
};

// src/view/components/container/toolbar-vertical/vertical-toolbar.svelte
function add_css(target) {
  append_styles(target, "svelte-101pjig", ".controls-container.svelte-101pjig{right:var(--size-4-2);top:var(--size-4-2);gap:var(--size-4-2);display:flex;flex-direction:column;position:absolute;z-index:2}.controls-toggle.svelte-101pjig{display:none}.is-mobile{& .controls-toggle {\n            display: block;\n        };& .buttons-group[data-visible='false'] {\n            display: none;\n        }}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_default_slot_1(ctx) {
  let morevertical;
  let current;
  morevertical = new more_vertical_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(morevertical.$$.fragment);
    },
    m(target, anchor) {
      mount_component(morevertical, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(morevertical.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(morevertical.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(morevertical, detaching);
    }
  };
}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*button*/
    ctx[16].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      2 && switch_value !== (switch_value = /*button*/
      ctx2[16].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block(ctx) {
  let html_tag;
  let raw_value = (
    /*button*/
    ctx[16].icon.svg + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      2 && raw_value !== (raw_value = /*button*/
      ctx2[16].icon.svg + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_default_slot49(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if ("svg" in /*button*/
    ctx2[16].icon)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let first;
  let button_1;
  let current;
  button_1 = new button_default({
    props: {
      active: (
        /*$activeStates*/
        ctx[2][
          /*button*/
          ctx[16].id
        ]
      ),
      classes: "control-item",
      label: (
        /*button*/
        ctx[16].label
      ),
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot49] },
      $$scope: { ctx }
    }
  });
  button_1.$on("click", function() {
    if (is_function(
      /*button*/
      ctx[16].onClick
    ))
      ctx[16].onClick.apply(this, arguments);
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(button_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(button_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_1_changes = {};
      if (dirty & /*$activeStates, $buttons*/
      6)
        button_1_changes.active = /*$activeStates*/
        ctx[2][
          /*button*/
          ctx[16].id
        ];
      if (dirty & /*$buttons*/
      2)
        button_1_changes.label = /*button*/
        ctx[16].label;
      if (dirty & /*$$scope, $buttons*/
      524290) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(button_1, detaching);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*group*/
    ctx[13].buttons
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[16].label
  );
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "buttons-group buttons-group--vertical");
      attr(
        div,
        "data-visible",
        /*$showControls*/
        ctx[0]
      );
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$activeStates, $buttons*/
      6) {
        each_value_1 = ensure_array_like(
          /*group*/
          ctx[13].buttons
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1, t, get_each_context_1);
        check_outros();
      }
      if (!current || dirty & /*$showControls*/
      1) {
        attr(
          div,
          "data-visible",
          /*$showControls*/
          ctx[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_fragment51(ctx) {
  let div1;
  let div0;
  let button_1;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  button_1 = new button_default({
    props: {
      active: (
        /*$showControls*/
        ctx[0]
      ),
      label: lang.controls_toggle_bar,
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button_1.$on(
    "click",
    /*toggleShowControls*/
    ctx[4]
  );
  let each_value = ensure_array_like(
    /*$buttons*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[13].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(button_1.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "buttons-group controls-toggle svelte-101pjig");
      attr(div1, "class", "controls-container svelte-101pjig");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(button_1, div0, null);
      append(div1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_1_changes = {};
      if (dirty & /*$showControls*/
      1)
        button_1_changes.active = /*$showControls*/
        ctx2[0];
      if (dirty & /*$$scope*/
      524288) {
        button_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button_1.$set(button_1_changes);
      if (dirty & /*$showControls, $buttons, $activeStates*/
      7) {
        each_value = ensure_array_like(
          /*$buttons*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let $showControls;
  let $buttons;
  let $activeStates;
  const view = getView();
  const showControls = writable(false);
  component_subscribe($$self, showControls, (value) => $$invalidate(0, $showControls = value));
  const toggleShowControls = () => {
    showControls.update((v) => !v);
  };
  const controls = uiControlsStore(view);
  const showMinimap = showMinimapStore(view);
  const scrollSettingsStore = ScrollSettingsStore(view);
  const applyGapBetweenCards = ApplyGapBetweenCardsStore(view);
  const outlineMode = OutlineModeStore(view);
  const buttons = VerticalToolbarButtonsList(view);
  component_subscribe($$self, buttons, (value) => $$invalidate(1, $buttons = value));
  const activeStates = derived([showMinimap, controls, scrollSettingsStore, outlineMode, applyGapBetweenCards], ([
    showMinimap2,
    controls2,
    scrollSettingsStore2,
    outlineMode2,
    applyGapBetweenCards2
  ]) => {
    return {
      minimap: showMinimap2,
      settings: controls2.showSettingsSidebar,
      hotkeys: controls2.showHelpSidebar,
      "style-rules": controls2.showStyleRulesModal,
      "center-active-node-h": scrollSettingsStore2.centerActiveNodeH,
      "center-active-node-v": scrollSettingsStore2.centerActiveNodeV,
      "outline-mode": outlineMode2,
      "space-between-cards": applyGapBetweenCards2
    };
  });
  component_subscribe($$self, activeStates, (value) => $$invalidate(2, $activeStates = value));
  return [
    $showControls,
    $buttons,
    $activeStates,
    showControls,
    toggleShowControls,
    buttons,
    activeStates
  ];
}
var Vertical_toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, {}, add_css);
  }
};
var vertical_toolbar_default = Vertical_toolbar;

// src/stores/view/derived/zoom-level-store.ts
var zoomLevelStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.zoomLevel);

// src/view/components/container/toolbar-vertical/helpers/create-zoom-menu.ts
var import_obsidian2 = require("obsidian");

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// src/lib/align-element/helpers/get-combined-client-rect.ts
var getCombinedBoundingClientRect = (elements) => {
  if (elements.length === 0) {
    return new DOMRect(0, 0, 0, 0);
  }
  let combinedRect = elements[0].getBoundingClientRect();
  for (let i = 1; i < elements.length; i++) {
    const rect = elements[i].getBoundingClientRect();
    combinedRect = combineRects(combinedRect, rect);
  }
  return combinedRect;
};
var combineRects = (rect1, rect2) => {
  const left = Math.min(rect1.left, rect2.left);
  const top = Math.min(rect1.top, rect2.top);
  const right = Math.max(rect1.right, rect2.right);
  const bottom = Math.max(rect1.bottom, rect2.bottom);
  const width = right - left;
  const height = bottom - top;
  return new DOMRect(left, top, width, height);
};

// src/view/components/container/toolbar-vertical/helpers/fit-document-height-into-view.ts
var fitDocumentHeightIntoView = async (view) => {
  invariant(view.container);
  const initialZoomLevel = get_store_value(zoomLevelStore(view));
  view.plugin.settings.dispatch({
    type: "settings/view/set-zoom-level",
    payload: { value: 1 }
  });
  const columns = Array.from(
    view.container.querySelectorAll(".column")
  );
  let result = 1;
  if (columns.length) {
    const groupHeights = columns.map((c) => {
      return getCombinedBoundingClientRect(
        Array.from(c.querySelectorAll(".group"))
      ).height;
    }).sort((a, b) => a - b);
    const height = groupHeights[groupHeights.length - 1];
    const width = getCombinedBoundingClientRect(columns).width;
    const boundingClientRect = view.container.getBoundingClientRect();
    const heightScale = boundingClientRect.height / (height + 100);
    const widthScale = boundingClientRect.width / (width + 100);
    result = Math.min(heightScale, widthScale);
  }
  view.plugin.settings.dispatch({
    type: "settings/view/set-zoom-level",
    payload: { value: initialZoomLevel }
  });
  return result;
};

// src/view/components/container/toolbar-vertical/helpers/fit-branch-into-view.ts
var fitBranchIntoView = async (view) => {
  invariant(view.container);
  const initialZoomLevel = get_store_value(zoomLevelStore(view));
  view.plugin.settings.dispatch({
    type: "settings/view/set-zoom-level",
    payload: { value: 1 }
  });
  let result = 1;
  const parents = Array.from(
    view.container.querySelectorAll(".active-parent")
  );
  const activeNode = view.container.querySelector(
    ".active-node"
  );
  const children2 = Array.from(
    view.container.querySelectorAll(".active-child")
  );
  const siblings = Array.from(
    view.container.querySelectorAll(".active-sibling")
  );
  const combinedRect = getCombinedBoundingClientRect([
    ...parents,
    activeNode,
    ...siblings,
    ...children2
  ]);
  const boundingClientRect = view.container.getBoundingClientRect();
  const heightScale = boundingClientRect.height / (combinedRect.height + 100);
  const widthScale = boundingClientRect.width / (combinedRect.width + 100);
  result = Math.min(heightScale, widthScale);
  view.plugin.settings.dispatch({
    type: "settings/view/set-zoom-level",
    payload: { value: initialZoomLevel }
  });
  return result;
};

// src/view/components/container/toolbar-vertical/helpers/create-zoom-menu.ts
var staticZoomOptions = [
  { label: "200%", scale: 2 },
  { label: "175%", scale: 1.75 },
  { label: "150%", scale: 1.5 },
  { label: "125%", scale: 1.25 },
  { label: "100%", scale: 1 },
  { label: "90%", scale: 0.9 },
  { label: "80%", scale: 0.8 },
  { label: "70%", scale: 0.7 },
  { label: "60%", scale: 0.6 },
  { label: "50%", scale: 0.5 },
  { label: "40%", scale: 0.4 },
  { label: "30%", scale: 0.3 },
  { label: "20%", scale: 0.2 },
  { label: "10%", scale: 0.1 },
  { label: "5%", scale: 0.05 }
];
var dynamicZoomOptions = [
  {
    label: "Fit document",
    scale: fitDocumentHeightIntoView
  },
  {
    label: "Fit active branch",
    scale: fitBranchIntoView
  }
];
var createZoomMenu = (props) => {
  let lastClickedZoom = get_store_value(zoomLevelStore(props.view));
  const zoomGroups = [dynamicZoomOptions, staticZoomOptions];
  const apply = async (zoom, isClick) => {
    const newValue = typeof zoom.scale === "number" ? zoom.scale : await zoom.scale(props.view);
    if (isClick) {
      lastClickedZoom = newValue;
    } else {
      hoverZoom = newValue;
    }
    props.view.plugin.settings.dispatch({
      type: "settings/view/set-zoom-level",
      payload: {
        value: newValue
      }
    });
  };
  const menu = new import_obsidian2.Menu();
  let hoverZoom = lastClickedZoom;
  for (const group of zoomGroups) {
    const groupIndex = zoomGroups.indexOf(group);
    if (groupIndex > 0)
      menu.addSeparator();
    for (const zoom of group) {
      menu.addItem((item) => {
        item.setTitle(zoom.label).setChecked(zoom.scale === lastClickedZoom).onClick(() => {
          apply(zoom, true);
          menu.hide();
          createZoomMenu(props);
        });
        const dom = item.dom;
        if (dom) {
          dom.addEventListener("mouseenter", () => {
            apply(zoom, false);
          });
        }
      });
    }
  }
  const menuDom = menu.dom;
  if (menuDom) {
    menuDom.addEventListener("mouseleave", () => {
      if (hoverZoom !== lastClickedZoom) {
        props.view.plugin.settings.dispatch({
          type: "settings/view/set-zoom-level",
          payload: { value: lastClickedZoom }
        });
      }
    });
    menuDom.style.width = "220px";
  }
  if (menuDom && !props.state.menuHeight) {
    menu.showAtPosition({ x: props.event.pageX, y: props.event.pageY });
    const rect = menuDom.getBoundingClientRect();
    props.state.menuHeight = rect.height;
    props.state.menuWidth = rect.width;
    menu.close();
  }
  const buttonRect = props.event.target.getBoundingClientRect();
  const viewRect = props.view.container.getBoundingClientRect();
  menu.showAtPosition({
    x: get_store_value(showMinimapStore(props.view)) ? buttonRect.left - props.state.menuWidth - 10 : buttonRect.left - 10,
    y: viewRect.bottom - 10 - props.state.menuHeight
  });
  menu.onHide(() => {
    props.state.lastMenuHideEvent_ms = Date.now();
  });
};

// src/stores/settings/reducers/change-zoom-level.ts
var formatNumber = (num) => parseFloat(num.toFixed(3));
var zoomStep = 0.1;
var maxZoomLevel = 2;
var minZoomLevel = 0.05;
var changeZoomLevel = (state2, payload) => {
  if ("value" in payload) {
    state2.view.zoomLevel = payload.value;
  } else {
    state2.view.zoomLevel = payload.direction === "in" ? Math.min(state2.view.zoomLevel + zoomStep, maxZoomLevel) : Math.max(state2.view.zoomLevel - zoomStep, minZoomLevel);
  }
  state2.view.zoomLevel = formatNumber(state2.view.zoomLevel);
};

// src/view/components/container/toolbar-vertical/zoom-buttons/zoom-buttons-list.ts
var ZoomButtonsList = (view, restoreZoom, showZoomPopupMenu) => {
  const hiddenControlsBarButtons = HiddenVerticalToolbarButtons(view.plugin);
  const h = new VerticalToolbarActions(view);
  return derived([hiddenControlsBarButtons], ([hiddenControlsBarButtons2]) => {
    const set = new Set(hiddenControlsBarButtons2);
    const buttons = [
      {
        id: "zoom",
        buttons: [
          {
            label: lang.controls_zoom_in,
            onClick: h.zoomIn,
            icon: plus_default,
            id: "zoom-in"
          },
          {
            label: lang.controls_zoom_reset,
            onClick: restoreZoom,
            icon: rotate_ccw_default,
            id: "zoom-reset"
          },
          {
            label: lang.controls_zoom_presets,
            onClick: showZoomPopupMenu,
            icon: scan_search_default,
            id: "zoom-presets"
          },
          {
            label: lang.controls_zoom_out,
            onClick: h.zoomOut,
            icon: minus_default,
            id: "zoom-out"
          }
        ]
      }
    ];
    return buttons.map((group) => {
      return {
        id: group.id,
        buttons: group.buttons.filter((b) => !set.has(b.id))
      };
    }).filter((g) => g.buttons.length > 0);
  });
};

// src/stores/view/derived/keyboard-store.ts
var KeyboardStore = (view) => derived2(view.viewStore, (state2) => state2.keyboard);

// src/view/components/container/toolbar-vertical/zoom-buttons/zoom-buttons.svelte
function add_css2(target) {
  append_styles(target, "svelte-12oedbu", ".zoom-buttons-container.svelte-12oedbu{right:var(--size-4-2);bottom:var(--size-4-2);gap:var(--size-4-2);display:flex;flex-direction:column;position:absolute;z-index:2}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*$buttons*/
    ctx[0][0].buttons
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[19].label
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "buttons-group buttons-group--vertical");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$activeStates, $buttons, $disabledStates, $showUndoRestZoomButton*/
      15) {
        each_value = ensure_array_like(
          /*$buttons*/
          ctx2[0][0].buttons
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block3, null, get_each_context3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_else_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*button*/
    ctx[19].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      1 && switch_value !== (switch_value = /*button*/
      ctx2[19].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$showUndoRestZoomButton*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let html_tag;
  let raw_value = (
    /*button*/
    ctx[19].icon.svg + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      1 && raw_value !== (raw_value = /*button*/
      ctx2[19].icon.svg + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_else_block2(ctx) {
  let rotateccw;
  let current;
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(rotateccw.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rotateccw, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rotateccw, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let rotatecw;
  let current;
  rotatecw = new rotate_cw_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(rotatecw.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rotatecw, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(rotatecw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotatecw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rotatecw, detaching);
    }
  };
}
function create_default_slot50(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_1, create_if_block_2, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if ("svg" in /*button*/
    ctx2[19].icon)
      return 0;
    if (
      /*button*/
      ctx2[19].id === "zoom-reset"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      t = space();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block3(key_1, ctx) {
  let first;
  let button_1;
  let current;
  button_1 = new button_default({
    props: {
      active: (
        /*$activeStates*/
        ctx[1][
          /*button*/
          ctx[19].id
        ]
      ),
      classes: "control-item",
      label: (
        /*button*/
        ctx[19].label
      ),
      tooltipPosition: "left",
      disabled: (
        /*$disabledStates*/
        ctx[2][
          /*button*/
          ctx[19].id
        ]
      ),
      $$slots: { default: [create_default_slot50] },
      $$scope: { ctx }
    }
  });
  button_1.$on("click", function() {
    if (is_function(
      /*button*/
      ctx[19].onClick
    ))
      ctx[19].onClick.apply(this, arguments);
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(button_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(button_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_1_changes = {};
      if (dirty & /*$activeStates, $buttons*/
      3)
        button_1_changes.active = /*$activeStates*/
        ctx[1][
          /*button*/
          ctx[19].id
        ];
      if (dirty & /*$buttons*/
      1)
        button_1_changes.label = /*button*/
        ctx[19].label;
      if (dirty & /*$disabledStates, $buttons*/
      5)
        button_1_changes.disabled = /*$disabledStates*/
        ctx[2][
          /*button*/
          ctx[19].id
        ];
      if (dirty & /*$$scope, $buttons, $showUndoRestZoomButton*/
      4194313) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(button_1, detaching);
    }
  };
}
function create_fragment52(ctx) {
  let div;
  let current;
  let if_block = (
    /*$buttons*/
    ctx[0].length > 0 && create_if_block2(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "zoom-buttons-container svelte-12oedbu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$buttons*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$buttons*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let $keyboardStore;
  let $buttons;
  let $activeStates;
  let $disabledStates;
  let $showUndoRestZoomButton;
  const view = getView();
  const keyboardStore = KeyboardStore(view);
  component_subscribe($$self, keyboardStore, (value) => $$invalidate(10, $keyboardStore = value));
  const zoomLevel = zoomLevelStore(view);
  const showUndoRestZoomButton = writable(false);
  component_subscribe($$self, showUndoRestZoomButton, (value) => $$invalidate(3, $showUndoRestZoomButton = value));
  let zoomValueBeforeReset = -1;
  let clearSavedZoomTimeoutRef = null;
  const clearSavedZoomValue = () => {
    if (clearSavedZoomTimeoutRef)
      clearTimeout(clearSavedZoomTimeoutRef);
    $$invalidate(9, zoomValueBeforeReset = -1);
  };
  const saveZoomValue = () => {
    clearSavedZoomValue();
    $$invalidate(9, zoomValueBeforeReset = get_store_value(zoomLevelStore(view)));
    clearSavedZoomTimeoutRef = setTimeout(
      () => {
        $$invalidate(9, zoomValueBeforeReset = -1);
      },
      1e3 * 120
    );
  };
  const restoreZoom = () => {
    if (get_store_value(showUndoRestZoomButton)) {
      view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { value: zoomValueBeforeReset }
      });
      clearSavedZoomValue();
    } else {
      saveZoomValue();
      view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { value: 1 }
      });
    }
  };
  const zoomMenuState = {
    menuHeight: 0,
    menuWidth: 0,
    lastMenuHideEvent_ms: 0
  };
  const showZoomPopupMenu = (event) => {
    if (Date.now() - zoomMenuState.lastMenuHideEvent_ms < 100)
      return;
    createZoomMenu({ event, view, state: zoomMenuState });
  };
  const buttons = ZoomButtonsList(view, restoreZoom, showZoomPopupMenu);
  component_subscribe($$self, buttons, (value) => $$invalidate(0, $buttons = value));
  const activeStates = derived([zoomLevel, showUndoRestZoomButton], ([zoomLevel2, showUndoRestZoomButton2]) => {
    return {
      "zoom-reset": showUndoRestZoomButton2 ? true : zoomLevel2 !== 1
    };
  });
  component_subscribe($$self, activeStates, (value) => $$invalidate(1, $activeStates = value));
  const disabledStates = derived([zoomLevel, showUndoRestZoomButton], ([zoomLevel2, showUndoRestZoomButton2]) => {
    return {
      "zoom-in": zoomLevel2 >= maxZoomLevel,
      "zoom-out": zoomLevel2 <= minZoomLevel,
      "zoom-reset": showUndoRestZoomButton2 ? false : zoomLevel2 === 1
    };
  });
  component_subscribe($$self, disabledStates, (value) => $$invalidate(2, $disabledStates = value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$keyboardStore, zoomValueBeforeReset*/
    1536) {
      $: {
        showUndoRestZoomButton.set($keyboardStore.shift && zoomValueBeforeReset !== -1);
      }
    }
  };
  return [
    $buttons,
    $activeStates,
    $disabledStates,
    $showUndoRestZoomButton,
    keyboardStore,
    showUndoRestZoomButton,
    buttons,
    activeStates,
    disabledStates,
    zoomValueBeforeReset,
    $keyboardStore
  ];
}
var Zoom_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, {}, add_css2);
  }
};
var zoom_buttons_default = Zoom_buttons;

// src/lib/tree-utils/find/find-node-column.ts
var findNodeColumn = (columns, nodeId) => {
  for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (group.nodes.find((n) => n === nodeId))
        return i;
    }
  }
  return -1;
};

// src/lib/tree-utils/get/traverse-down.ts
var traverseDown = (columns, nodeId, cleanDocument) => {
  const result = [];
  let nodeColumnIndex = 0;
  if (cleanDocument) {
    nodeColumnIndex = findNodeColumn(columns, nodeId) + 1;
    if (nodeColumnIndex > columns.length - 1) {
      return result;
    }
  }
  const currentParents = /* @__PURE__ */ new Set([nodeId]);
  let firstResult = false;
  for (let i = nodeColumnIndex; i < columns.length; i++) {
    const column = columns[i];
    let columnResult = false;
    for (const group of column.groups) {
      if (currentParents.has(group.parentId)) {
        result.push(group.parentId);
        group.nodes.forEach((node) => currentParents.add(node));
        columnResult = true;
        if (!firstResult)
          firstResult = true;
      }
    }
    if (firstResult && !columnResult)
      break;
  }
  return result;
};

// src/view/actions/dnd/draggable.ts
var DND_ACTIVE_CLASS = "is-dragged";
var toggleDraggedNodeVisibility = (node, data, visible) => {
  requestAnimationFrame(() => {
    const parent = node.matchParent("#" + data.id);
    if (parent) {
      parent.style.display = visible ? "flex" : "none";
      parent.toggleClass(DND_ACTIVE_CLASS, !visible);
    }
  });
};
var draggable = (node, data) => {
  const view = getView();
  const viewStore = view.viewStore;
  const documentStore = view.documentStore;
  if (data.isInSidebar)
    return;
  node.draggable = true;
  const handleDragstart = (event) => {
    if (!event.dataTransfer)
      return;
    const target = event.currentTarget;
    if (event.clientX - target.getBoundingClientRect().x <= 7 || target.dataset["test"] === "true") {
      event.dataTransfer.setData("text/plain", data.id);
      setTimeout(() => {
        const childGroups = traverseDown(
          documentStore.getValue().document.columns,
          data.id,
          false
        );
        viewStore.dispatch({
          type: "view/dnd/set-drag-started",
          payload: { nodeId: data.id, childGroups }
        });
        toggleDraggedNodeVisibility(node, data, false);
      }, 0);
    } else {
      event.preventDefault();
    }
  };
  node.addEventListener("dragstart", handleDragstart);
  const handleDragEnd = () => {
    viewStore.dispatch({ type: "view/dnd/set-drag-ended" });
    toggleDraggedNodeVisibility(node, data, true);
  };
  node.addEventListener("dragend", handleDragEnd);
  return {
    destroy: () => {
      node.removeEventListener("dragstart", handleDragstart);
      node.removeEventListener("dragend", handleDragEnd);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/dnd/draggable.svelte
function add_css3(target) {
  append_styles(target, "svelte-gtjx2q", ".draggable.svelte-gtjx2q.svelte-gtjx2q{width:100%;background-color:transparent;display:flex;position:relative}.drag-handle.svelte-gtjx2q.svelte-gtjx2q{height:100%;width:6px;background-color:transparent;cursor:grab;position:absolute;left:-5px;z-index:10}.active-node .drag-handle.svelte-gtjx2q.svelte-gtjx2q{left:0}.draggable.svelte-gtjx2q:hover .drag-handle.svelte-gtjx2q{background-size:2px 4px;background-image:linear-gradient(\n                0deg,\n                hsla(0, 0%, 60%, 0.5) 20%,\n                transparent 40%\n        )}.content.svelte-gtjx2q.svelte-gtjx2q{width:100%\n    }");
}
function create_if_block3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "drag-handle svelte-gtjx2q");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment53(ctx) {
  let div1;
  let t;
  let div0;
  let draggable_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*isInSidebar*/
  ctx[0] && create_if_block3(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "content svelte-gtjx2q");
      attr(div1, "class", "draggable svelte-gtjx2q");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(draggable_action = draggable.call(null, div1, {
          id: (
            /*nodeId*/
            ctx[1]
          ),
          isInSidebar: (
            /*isInSidebar*/
            ctx[0]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*isInSidebar*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*nodeId, isInSidebar*/
      3)
        draggable_action.update.call(null, {
          id: (
            /*nodeId*/
            ctx2[1]
          ),
          isInSidebar: (
            /*isInSidebar*/
            ctx2[0]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { isInSidebar } = $$props;
  let { nodeId } = $$props;
  $$self.$$set = ($$props2) => {
    if ("isInSidebar" in $$props2)
      $$invalidate(0, isInSidebar = $$props2.isInSidebar);
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [isInSidebar, nodeId, $$scope, slots];
}
var Draggable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, { isInSidebar: 0, nodeId: 1 }, add_css3);
  }
};
var draggable_default = Draggable;

// src/view/actions/inline-editor/load-inline-editor.ts
var loadInlineEditor = (target, nodeId) => {
  const view = getView();
  if (!view.file)
    return;
  view.inlineEditor.loadNode(target, nodeId);
  return {
    destroy: () => {
      view.inlineEditor.unloadNode(nodeId);
    }
  };
};

// src/stores/settings/derived/limit-preview-height-store.ts
var limitPreviewHeightStore = (view) => derived2(view.plugin.settings, (state2) => state2.view.limitPreviewHeight);

// src/view/actions/inline-editor/expandable-textarea-action.ts
var deletionKeys = /* @__PURE__ */ new Set(["Backspace", "Delete", "x", " "]);
var AdjustHeight = (view, el) => {
  let previousScrollHeight = 0;
  let x;
  const limitCardHeight = get_store_value(limitPreviewHeightStore(view));
  const viewState = view.viewStore.getValue();
  const isInSidebar = viewState.document.editing.isInSidebar;
  return (e) => {
    if (!x) {
      x = el.querySelector(".cm-scroller");
    }
    if (!x)
      return;
    requestAnimationFrame(() => {
      const scrollHeight = x.scrollHeight;
      const scrollHeightChange = scrollHeight > 100 && scrollHeight !== previousScrollHeight;
      if (scrollHeightChange || e && deletionKeys.has(e.key)) {
        x.style.height = "auto";
        previousScrollHeight = x.scrollHeight;
        el.style.height = previousScrollHeight + "px";
        x.style.height = "";
        if (!isInSidebar && limitCardHeight && scrollHeightChange) {
          view.alignBranch.align({
            type: "view/align-branch/reveal-node"
          });
        }
      }
    });
  };
};
var expandableTextareaAction = (el) => {
  const view = getView();
  const adjustHeight = AdjustHeight(view, el);
  el.addEventListener("keydown", adjustHeight);
  return {
    destroy: () => {
      el.removeEventListener("keydown", adjustHeight);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/inline-editor.svelte
function add_css4(target) {
  append_styles(target, "svelte-lini95", ".editor-container.svelte-lini95{width:100%;min-height:var(--min-node-height);height:fit-content;overflow:hidden;display:flex}.apply-style-rule.svelte-lini95{& .view-content {\n            background-color: transparent !important;\n        }}");
}
function create_fragment54(ctx) {
  let div;
  let div_class_value;
  let expandableTextareaAction_action;
  let loadInlineEditor_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = null_to_empty("editor-container" + /*style*/
      (ctx[1] ? " apply-style-rule" : "")) + " svelte-lini95");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(expandableTextareaAction_action = expandableTextareaAction.call(null, div)),
          action_destroyer(loadInlineEditor_action = loadInlineEditor.call(
            null,
            div,
            /*nodeId*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*style*/
      2 && div_class_value !== (div_class_value = null_to_empty("editor-container" + /*style*/
      (ctx2[1] ? " apply-style-rule" : "")) + " svelte-lini95")) {
        attr(div, "class", div_class_value);
      }
      if (loadInlineEditor_action && is_function(loadInlineEditor_action.update) && dirty & /*nodeId*/
      1)
        loadInlineEditor_action.update.call(
          null,
          /*nodeId*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  let { style } = $$props;
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
  };
  return [nodeId, style];
}
var Inline_editor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment54, safe_not_equal, { nodeId: 0, style: 1 }, add_css4);
  }
};
var inline_editor_default = Inline_editor;

// src/view/actions/markdown-preview/markdown-preview-action.ts
var import_obsidian3 = require("obsidian");

// src/stores/document/derived/content-store.ts
var contentStore = (view, nodeId) => {
  let nodeContent;
  let documentContent;
  return derived2(view.documentStore, (state2) => {
    if (!nodeContent || documentContent !== state2.document.content || nodeContent !== documentContent[nodeId]) {
      documentContent = state2.document.content;
      nodeContent = documentContent[nodeId];
      if (!nodeContent)
        return "";
    }
    return nodeContent.content;
  });
};
var documentContentStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.document.content;
  });
};

// src/view/actions/markdown-preview/helpers/format-text.ts
var applyNbsp = (text2) => {
  const lines = text2.split("\n");
  let mutated = false;
  let isInCodeBlock = false;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith("```")) {
      isInCodeBlock = !isInCodeBlock;
    }
    if (isInCodeBlock)
      continue;
    if (lines[i].length > 0)
      continue;
    const previousLine = lines[i - 1];
    const skipNbsp = i > 0 && (previousLine.startsWith("- ") || previousLine.startsWith("> "));
    if (!skipNbsp) {
      lines[i] = "&nbsp;";
      mutated = true;
    }
  }
  return mutated ? lines.join("\n") : text2;
};
var formatText = (text2) => {
  if (/\s+(\^[a-zA-Z0-9]{4,})$/.test(text2)) {
    text2 = text2.replace(
      /\s+(\^[a-zA-Z0-9]{4,})$/gm,
      ' <sup class="cm-blockid" data-block-id="$1">$1</sup>'
    );
  }
  if (/%%/.test(text2)) {
    text2 = text2.replace(
      /%%(.*?)%%/gms,
      `<span class="cm-comment">%\u200B%$1%\u200B%</span>`
    );
  }
  if (/<!--/.test(text2)) {
    text2 = text2.replace(
      /<!--(.*?)-->/gms,
      '<span class="cm-comment">&lt;!--$1--&gt;</span>'
    );
  }
  if (/^\s*$/gm.test(text2) && !/^\|.*\|/m.test(text2)) {
    text2 = applyNbsp(text2);
  }
  return text2;
};

// src/view/actions/markdown-preview/markdown-preview-action.ts
var markdownPreviewAction = (element2, nodeId) => {
  const plugin = getPlugin();
  const view = getView();
  const render2 = (content) => {
    if (view && element2) {
      element2.empty();
      if (content.length > 0) {
        content = formatText(content);
      }
      import_obsidian3.MarkdownRenderer.render(
        plugin.app,
        content,
        element2,
        view.file.path,
        view
      );
    }
  };
  const $content = contentStore(view, nodeId);
  const unsub = $content.subscribe((content) => {
    render2(content);
  });
  return {
    destroy: () => {
      unsub();
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/helpers/get-existing-right-tab-group.ts
var getExistingRightTabGroup = (view) => {
  const rootSplit = view.plugin.app.workspace.rootSplit;
  if (!("children" in rootSplit))
    return;
  const viewTabGroup = "parent" in view.leaf ? view.leaf.parent : null;
  if (!viewTabGroup || !(typeof viewTabGroup === "object"))
    return;
  if (!("type" in viewTabGroup && viewTabGroup.type === "tabs"))
    return;
  const children2 = rootSplit["children"];
  if (children2 && Array.isArray(children2)) {
    const viewTabGroupIndex = children2.findIndex(
      (group) => viewTabGroup === group
    );
    if (viewTabGroupIndex !== -1) {
      return children2[viewTabGroupIndex + 1];
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/helpers/open-file-in-existing-right-tab-group.ts
var openFileInExistingRightTabGroup = (view, link, activeFilePath) => {
  const rightTabGroup = getExistingRightTabGroup(view);
  if (!rightTabGroup)
    return false;
  const workspace = view.plugin.app.workspace;
  if (!("createLeafInTabGroup" in workspace && typeof workspace.createLeafInTabGroup === "function"))
    return false;
  const newLeaf = workspace.createLeafInTabGroup(
    rightTabGroup
  );
  if (newLeaf) {
    if (link.contains("#")) {
      view.plugin.app.workspace.openLinkText(
        link,
        activeFilePath,
        "split",
        newLeaf.getViewState()
      );
    } else {
      const linkedFile = view.plugin.app.metadataCache.getFirstLinkpathDest(
        link,
        activeFilePath
      );
      if (linkedFile) {
        newLeaf.openFile(linkedFile);
        workspace.setActiveLeaf(newLeaf);
        return true;
      }
    }
  }
  return false;
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/block-link/handle-global-block-link.ts
var getLinkPaneType = (view, modKey2) => {
  const linkPaneType = view.plugin.settings.getValue().general.linkPaneType;
  if (modKey2) {
    return linkPaneType === "tab" ? "split" : "tab";
  } else {
    return linkPaneType;
  }
};
var handleGlobalBlockLink = (view, link, modKey2) => {
  view.plugin.app.workspace.openLinkText(
    link,
    view.file.basename,
    getLinkPaneType(view, modKey2)
  );
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/file-link/handle-file-link.ts
var handleFileLink = (view, link, modKey2) => {
  const path = view.file?.path;
  if (!link || !path)
    return;
  const paneType = getLinkPaneType(view, modKey2);
  if (paneType === "tab") {
    view.plugin.app.workspace.openLinkText(link, path, "tab");
  } else {
    const success = openFileInExistingRightTabGroup(view, link, path);
    if (!success) {
      view.plugin.app.workspace.openLinkText(link, path, "split");
    }
  }
};

// src/helpers/delay.ts
var delay = async (milliseconds, signal) => {
  return new Promise((resolve) => {
    const timeout = setTimeout(() => resolve(), milliseconds);
    if (signal) {
      signal.addEventListener("abort", () => {
        clearTimeout(timeout);
        resolve();
      });
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/helpers/select-card.ts
var selectCard = async (view, id2) => {
  await delay(16);
  view.viewStore.dispatch({
    type: "view/set-active-node/mouse",
    payload: {
      id: id2
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/heading-link/handle-local-heading-link.ts
var handleLocalHeadingLink = (view, link) => {
  const match = /#+(.*)$/.exec(link);
  if (!match)
    return;
  const headingText = match[1].trimStart();
  for (let level2 = 1; level2 <= 6; level2++) {
    const headings = Array.from(
      view.containerEl.querySelectorAll("h" + level2)
    );
    const heading = headings.find((h) => h.dataset.heading === headingText);
    if (heading) {
      const card = heading.closest(".lineage-card");
      if (card && card.id) {
        selectCard(view, card.id);
        break;
      }
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/heading-link/handle-heading.ts
var handleHeading = (view, link, modKey2) => {
  const file = link.split("#")[0];
  if (file && file !== view.file.basename) {
    handleGlobalBlockLink(view, link, modKey2);
  } else {
    handleLocalHeadingLink(view, link);
  }
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/block-link/handle-local-block-link.ts
var handleLocalBlockLink = (view, id2) => {
  const element2 = view.container.querySelector(
    `[data-block-id="^${id2}"`
  );
  if (element2) {
    const card = element2.closest(".lineage-card");
    if (card && card.id) {
      selectCard(view, card.id);
      return true;
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/block-link/handle-block-link.ts
var handleBlockLink = (view, link, modKey2) => {
  const viewFilePath = view.file.basename;
  const match = /(.*)#\^(\S{4,})$/.exec(link);
  if (match) {
    const file = match[1];
    const id2 = match[2];
    if (!file.trim() || file === viewFilePath) {
      handleLocalBlockLink(view, id2);
    } else {
      handleGlobalBlockLink(view, link, modKey2);
    }
  }
};

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/mod-key.ts
var import_obsidian4 = require("obsidian");
var isMacLike = import_obsidian4.Platform.isMacOS || import_obsidian4.Platform.isIosApp;
var modKey = isMacLike ? "Cmd" : "Ctrl";

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links/handle-links.ts
var handleLinks = (view, e) => {
  if (!(e.target instanceof HTMLAnchorElement))
    return;
  if (!e.target.hasClass("internal-link"))
    return;
  const link = e.target.dataset.href;
  const modKey2 = isMacLike ? e.metaKey : e.ctrlKey;
  if (!link)
    return;
  if (link.contains("#^")) {
    e.stopPropagation();
    handleBlockLink(view, link, modKey2);
  } else if (link.contains("#")) {
    e.stopPropagation();
    handleHeading(view, link, modKey2);
  } else {
    e.stopPropagation();
    handleFileLink(view, link, modKey2);
  }
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/get-cursor-position.ts
var getCursorPosition = (markdownText, event) => {
  const range = document.caretRangeFromPoint(event.clientX, event.clientY);
  if (!range)
    return null;
  const lines = markdownText.split("\n");
  const clickedText = range.startContainer.textContent || "";
  const offset = range.startOffset;
  const start = Math.max(0, offset - 10);
  const end = Math.min(clickedText.length, offset + 10);
  const context = clickedText.slice(start, end);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].contains(context)) {
      const startInLine = lines[i].indexOf(context) + (offset - start);
      return {
        line: i,
        ch: startInLine
      };
    }
  }
  return null;
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/helpers/is-grabbing.ts
var isGrabbing = (view) => {
  const cursor2 = view.container.style.cursor;
  if (cursor2 === "grab")
    return true;
  return false;
};

// src/stores/view/subscriptions/actions/set-active-sidebar-node.ts
var setActiveSidebarNode = (view, id2) => {
  const settings = view.plugin.settings.getValue();
  const activeTab = settings.view.leftSidebarActiveTab;
  view.viewStore.dispatch({
    type: activeTab === "pinned-cards" ? "view/pinned-nodes/set-active-node" : "view/recent-nodes/set-active-node",
    payload: { id: id2 }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/store-actions/set-active-main-split-node.ts
var setActiveMainSplitNode = (view, nodeId, e) => {
  const silent = isMacLike ? e.metaKey : e.ctrlKey;
  view.viewStore.dispatch({
    type: silent ? "view/set-active-node/mouse-silent" : "view/set-active-node/mouse",
    payload: { id: nodeId }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/store-actions/enable-edit-mode-in-sidebar.ts
var enableEditModeInSidebar = (view, nodeId) => {
  const settings = view.plugin.settings.getValue();
  const activeSidebarTab = settings.view.leftSidebarActiveTab;
  view.viewStore.dispatch({
    type: "view/editor/enable-sidebar-editor",
    payload: {
      id: nodeId
    },
    context: {
      activeSidebarTab
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/store-actions/enable-edit-mode-in-main-split.ts
var enableEditModeInMainSplit = (view, nodeId) => {
  view.viewStore.dispatch({
    type: "view/editor/enable-main-editor",
    payload: {
      nodeId
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/content/content.svelte
function add_css5(target) {
  append_styles(target, "svelte-1wqkxy4", ".lng-prev.svelte-1wqkxy4{width:100%;min-height:var(--min-node-height);font-size:var(--font-text-size);padding:6px 6px 10px 12px;color-scheme:light}");
}
function create_fragment55(ctx) {
  let div;
  let div_class_value;
  let markdownPreviewAction_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = null_to_empty("lng-prev markdown-preview-view markdown-preview-section markdown-rendered") + " svelte-1wqkxy4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*handleClick*/
            ctx[1]
          ),
          listen(
            div,
            "dblclick",
            /*handleDoubleClick*/
            ctx[2]
          ),
          action_destroyer(markdownPreviewAction_action = markdownPreviewAction.call(
            null,
            div,
            /*nodeId*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (markdownPreviewAction_action && is_function(markdownPreviewAction_action.update) && dirty & /*nodeId*/
      1)
        markdownPreviewAction_action.update.call(
          null,
          /*nodeId*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  let { isInSidebar } = $$props;
  let { active } = $$props;
  const view = getView();
  const setActiveNode2 = (e) => {
    if (isInSidebar) {
      setActiveSidebarNode(view, nodeId);
    } else {
      setActiveMainSplitNode(view, nodeId, e);
    }
  };
  const enableEditMode3 = () => {
    if (isInSidebar) {
      enableEditModeInSidebar(view, nodeId);
    } else {
      enableEditModeInMainSplit(view, nodeId);
    }
  };
  const enableEditModeAtCursor = (e) => {
    const content = get_store_value(contentStore(view, nodeId));
    const cursor2 = getCursorPosition(content, e);
    setActiveNode2(e);
    if (cursor2) {
      view.inlineEditor.setNodeCursor(nodeId, cursor2);
    }
    enableEditMode3();
  };
  const anotherNodeIsBeingEdited = () => {
    const isNotActiveNode = active !== "node" /* node */;
    const editingState = view.viewStore.getValue().document.editing;
    return isNotActiveNode && editingState.activeNodeId && !editingState.isInSidebar;
  };
  const handleClick = (e) => {
    if (isGrabbing(view))
      return;
    const maintainEditMode2 = get_store_value(MaintainEditMode(view));
    const enableEditOnSingleClick = maintainEditMode2 && !isInSidebar && anotherNodeIsBeingEdited();
    if (enableEditOnSingleClick) {
      enableEditModeAtCursor(e);
    } else {
      handleLinks(view, e);
      setActiveNode2(e);
    }
  };
  const handleDoubleClick = (e) => {
    if (isGrabbing(view))
      return;
    enableEditModeAtCursor(e);
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("isInSidebar" in $$props2)
      $$invalidate(3, isInSidebar = $$props2.isInSidebar);
    if ("active" in $$props2)
      $$invalidate(4, active = $$props2.active);
  };
  return [nodeId, handleClick, handleDoubleClick, isInSidebar, active];
}
var Content = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, { nodeId: 0, isInSidebar: 3, active: 4 }, add_css5);
  }
};
var content_default = Content;

// src/view/components/container/column/components/group/components/card/components/card-buttons/shared/floating-button.svelte
var import_classnames = __toESM(require_classnames());
function create_fragment56(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[2]
      );
      attr(button, "class", button_class_value = (0, import_classnames.default)(
        /*classes*/
        ctx[0],
        /*positionClasses*/
        ctx[3][
          /*position*/
          ctx[1]
        ],
        "lineage-floating-button"
      ));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      4) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*classes, position*/
      3 && button_class_value !== (button_class_value = (0, import_classnames.default)(
        /*classes*/
        ctx2[0],
        /*positionClasses*/
        ctx2[3][
          /*position*/
          ctx2[1]
        ],
        "lineage-floating-button"
      ))) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { classes = "" } = $$props;
  let { position } = $$props;
  let { label } = $$props;
  const positionClasses = {
    up: "position-top",
    right: "position-right",
    down: "position-bottom",
    "down-right": "position-bottom-right",
    "up-right": "position-top-right",
    collapse: "collapse-button"
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [classes, position, label, positionClasses, $$scope, slots, click_handler];
}
var Floating_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment56, safe_not_equal, { classes: 0, position: 1, label: 2 });
  }
};
var floating_button_default = Floating_button;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/delete-node.ts
var deleteNode = (view, nodeId, includeSelection = false) => {
  const documentStore = view.documentStore;
  const viewState = view.viewStore.getValue();
  if (viewState.document.pendingConfirmation.deleteNode.has(nodeId)) {
    const selectedNodes = includeSelection ? viewState.document.selectedNodes : void 0;
    documentStore.dispatch({
      type: "document/delete-node",
      payload: {
        activeNodeId: nodeId,
        selectedNodes
      }
    });
    view.viewStore.dispatch({
      type: "view/delete-node/reset-confirmation"
    });
  } else {
    view.viewStore.dispatch({
      type: "view/delete-node/confirm",
      payload: {
        id: nodeId,
        includeSelection
      }
    });
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/components/delete-node-button.svelte
function create_default_slot51(ctx) {
  let trashicon;
  let current;
  trashicon = new trash_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(trashicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trashicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(trashicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trashicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trashicon, detaching);
    }
  };
}
function create_fragment57(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: lang.card_btn_delete,
      position: "up-right",
      classes: "delete-card-button",
      $$slots: { default: [create_default_slot51] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*_deleteNode*/
    ctx[0]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*$$scope*/
      8) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  const _deleteNode = (e) => {
    e.stopPropagation();
    deleteNode(view, nodeId);
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
  };
  return [_deleteNode, nodeId];
}
var Delete_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment57, safe_not_equal, { nodeId: 1 });
  }
};
var delete_node_button_default = Delete_node_button;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-content.ts
var saveNodeContent = (view, modKey2 = false) => {
  if (view.inlineEditor.nodeId) {
    view.inlineEditor.unloadNode();
    const isInSidebar = view.viewStore.getValue().document.editing.isInSidebar;
    if (isInSidebar) {
      view.viewStore.dispatch({
        type: "view/editor/disable-sidebar-editor",
        context: {
          modKey: modKey2
        }
      });
    } else {
      view.viewStore.dispatch({
        type: "view/editor/disable-main-editor",
        context: {
          modKey: modKey2
        }
      });
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/components/edit-node-button.svelte
function create_else_block3(ctx) {
  let pencilicon;
  let current;
  pencilicon = new pencil_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(pencilicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pencilicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pencilicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pencilicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pencilicon, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let saveicon;
  let current;
  saveicon = new save_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(saveicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(saveicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(saveicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(saveicon, detaching);
    }
  };
}
function create_default_slot52(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editing*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment58(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*editing*/
        ctx[0] ? lang.card_btn_save : lang.card_btn_edit
      ),
      position: "down-right",
      $$slots: { default: [create_default_slot52] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*handleClick*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*editing*/
      1)
        floatingbutton_changes.label = /*editing*/
        ctx2[0] ? lang.card_btn_save : lang.card_btn_edit;
      if (dirty & /*$$scope, editing*/
      257) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance58($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { nodeId } = $$props;
  let { isInSidebar } = $$props;
  const view = getView();
  const viewStore = view.viewStore;
  const enableEditMode3 = (e) => {
    e.stopPropagation();
    if (isInSidebar) {
      enableEditModeInSidebar(view, nodeId);
    } else {
      enableEditModeInMainSplit(view, nodeId);
    }
  };
  const saveNode = (e) => {
    e.stopPropagation();
    saveNodeContent(view);
  };
  const handleClick = (e) => {
    if (editing) {
      saveNode(e);
    } else {
      enableEditMode3(e);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
    if ("isInSidebar" in $$props2)
      $$invalidate(3, isInSidebar = $$props2.isInSidebar);
  };
  return [editing, handleClick, nodeId, isInSidebar];
}
var Edit_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance58, create_fragment58, safe_not_equal, { editing: 0, nodeId: 2, isInSidebar: 3 });
  }
};
var edit_node_button_default = Edit_node_button;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/is-editing.ts
var isEditing = (view) => {
  return !!view.viewStore.getValue().document.editing.activeNodeId;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-and-insert-node.ts
var saveNodeAndInsertNode = (view, direction, content = "", activeNodeId) => {
  if (isEditing(view)) {
    saveNodeContent(view);
  }
  const nodeId = activeNodeId || view.viewStore.getValue().document.activeNode;
  view.documentStore.dispatch({
    type: "document/add-node",
    payload: {
      position: direction,
      content,
      activeNodeId: nodeId
    }
  });
  if (content) {
    const newNodeId = view.viewStore.getValue().document.activeNode;
    if (direction === "down" || direction === "right") {
      view.inlineEditor.setNodeCursor(newNodeId, { line: 0, ch: 0 });
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/components/create-card-button.svelte
function create_default_slot53(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*chevrons*/
    ctx[2][
      /*position*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*position*/
      1 && switch_value !== (switch_value = /*chevrons*/
      ctx2[2][
        /*position*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment59(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*label*/
        ctx[3][
          /*position*/
          ctx[0]
        ]
      ),
      position: (
        /*position*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot53] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*createCard*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*position*/
      1)
        floatingbutton_changes.label = /*label*/
        ctx2[3][
          /*position*/
          ctx2[0]
        ];
      if (dirty & /*position*/
      1)
        floatingbutton_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*$$scope, position*/
      65) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance59($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  let { position } = $$props;
  const view = getView();
  const createCard = (e) => {
    e.stopPropagation();
    saveNodeAndInsertNode(view, position, void 0, nodeId);
  };
  const chevrons = {
    right: chevron_right_default,
    up: chevron_up_default,
    down: chevron_down_default
  };
  const label = {
    "up": lang.card_btn_add_node_above,
    "down": lang.card_btn_add_node_below,
    "right": lang.card_btn_add_child_node
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(4, nodeId = $$props2.nodeId);
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
  };
  return [position, createCard, chevrons, label, nodeId];
}
var Create_card_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance59, create_fragment59, safe_not_equal, { nodeId: 4, position: 0 });
  }
};
var create_card_button_default = Create_card_button;

// src/stores/view/subscriptions/effects/focus-container.ts
var import_obsidian5 = require("obsidian");
var focusContainer = (view) => {
  setTimeout(() => {
    if (view.container) {
      const isEditing2 = Boolean(view.inlineEditor.nodeId);
      const isEditingOnMobile = import_obsidian5.Platform.isMobile && isEditing2;
      if (!isEditingOnMobile) {
        if (isEditing2)
          view.inlineEditor.focus();
        else
          view.container.focus();
      }
    }
  }, 16);
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/components/focus-card-button.svelte
function create_default_slot54(ctx) {
  let focus;
  let current;
  focus = new focus_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(focus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(focus, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(focus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(focus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(focus, detaching);
    }
  };
}
function create_fragment60(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: lang.card_btn_scroll_to_reveal,
      position: "up-right",
      $$slots: { default: [create_default_slot54] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*focusCard*/
    ctx[0]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*$$scope*/
      8) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance60($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  const focusCard = () => {
    view.viewStore.dispatch({
      type: "view/set-active-node/mouse",
      payload: { id: nodeId }
    });
    focusContainer(view);
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
  };
  return [focusCard, nodeId];
}
var Focus_card_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance60, create_fragment60, safe_not_equal, { nodeId: 1 });
  }
};
var focus_card_button_default = Focus_card_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/components/collapse-card-button.svelte
function create_else_block4(ctx) {
  let minus;
  let current;
  minus = new minus_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(minus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(minus, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(minus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(minus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(minus, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let plus;
  let current;
  plus = new plus_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(plus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(plus, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(plus, detaching);
    }
  };
}
function create_default_slot55(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*collapsed*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment61(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*collapsed*/
        ctx[0] ? lang.card_btn_expand_node : lang.card_btn_collapse_node
      ),
      position: "collapse",
      $$slots: { default: [create_default_slot55] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*toggleCollapse*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*collapsed*/
      1)
        floatingbutton_changes.label = /*collapsed*/
        ctx2[0] ? lang.card_btn_expand_node : lang.card_btn_collapse_node;
      if (dirty & /*$$scope, collapsed*/
      17) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance61($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  let { collapsed } = $$props;
  const view = getView();
  const toggleCollapse = () => {
    view.viewStore.dispatch({
      type: "view/outline/toggle-collapse-node",
      payload: { id: nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
    if ("collapsed" in $$props2)
      $$invalidate(0, collapsed = $$props2.collapsed);
  };
  return [collapsed, toggleCollapse, nodeId];
}
var Collapse_card_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance61, create_fragment61, safe_not_equal, { nodeId: 2, collapsed: 0 });
  }
};
var collapse_card_button_default = Collapse_card_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons/card-buttons.svelte
function create_if_block_12(ctx) {
  let t;
  let editnodebutton;
  let current;
  let if_block = !/*editing*/
  ctx[0] && create_if_block_22(ctx);
  editnodebutton = new edit_node_button_default({
    props: {
      editing: (
        /*editing*/
        ctx[0]
      ),
      nodeId: (
        /*nodeId*/
        ctx[1]
      ),
      isInSidebar: (
        /*isInSidebar*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(editnodebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(editnodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*editing*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editing*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const editnodebutton_changes = {};
      if (dirty & /*editing*/
      1)
        editnodebutton_changes.editing = /*editing*/
        ctx2[0];
      if (dirty & /*nodeId*/
      2)
        editnodebutton_changes.nodeId = /*nodeId*/
        ctx2[1];
      if (dirty & /*isInSidebar*/
      8)
        editnodebutton_changes.isInSidebar = /*isInSidebar*/
        ctx2[3];
      editnodebutton.$set(editnodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(editnodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(editnodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(editnodebutton, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_32, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*isInSidebar*/
    ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block5(ctx) {
  let focuscardbutton;
  let current;
  focuscardbutton = new focus_card_button_default({ props: { nodeId: (
    /*nodeId*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(focuscardbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(focuscardbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const focuscardbutton_changes = {};
      if (dirty & /*nodeId*/
      2)
        focuscardbutton_changes.nodeId = /*nodeId*/
        ctx2[1];
      focuscardbutton.$set(focuscardbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(focuscardbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(focuscardbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(focuscardbutton, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let createcardbutton0;
  let t0;
  let createcardbutton1;
  let t1;
  let createcardbutton2;
  let t2;
  let deletenodebutton;
  let current;
  createcardbutton0 = new create_card_button_default({
    props: {
      position: "up",
      nodeId: (
        /*nodeId*/
        ctx[1]
      )
    }
  });
  createcardbutton1 = new create_card_button_default({
    props: {
      position: "right",
      nodeId: (
        /*nodeId*/
        ctx[1]
      )
    }
  });
  createcardbutton2 = new create_card_button_default({
    props: {
      position: "down",
      nodeId: (
        /*nodeId*/
        ctx[1]
      )
    }
  });
  deletenodebutton = new delete_node_button_default({ props: { nodeId: (
    /*nodeId*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(createcardbutton0.$$.fragment);
      t0 = space();
      create_component(createcardbutton1.$$.fragment);
      t1 = space();
      create_component(createcardbutton2.$$.fragment);
      t2 = space();
      create_component(deletenodebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(createcardbutton0, target, anchor);
      insert(target, t0, anchor);
      mount_component(createcardbutton1, target, anchor);
      insert(target, t1, anchor);
      mount_component(createcardbutton2, target, anchor);
      insert(target, t2, anchor);
      mount_component(deletenodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const createcardbutton0_changes = {};
      if (dirty & /*nodeId*/
      2)
        createcardbutton0_changes.nodeId = /*nodeId*/
        ctx2[1];
      createcardbutton0.$set(createcardbutton0_changes);
      const createcardbutton1_changes = {};
      if (dirty & /*nodeId*/
      2)
        createcardbutton1_changes.nodeId = /*nodeId*/
        ctx2[1];
      createcardbutton1.$set(createcardbutton1_changes);
      const createcardbutton2_changes = {};
      if (dirty & /*nodeId*/
      2)
        createcardbutton2_changes.nodeId = /*nodeId*/
        ctx2[1];
      createcardbutton2.$set(createcardbutton2_changes);
      const deletenodebutton_changes = {};
      if (dirty & /*nodeId*/
      2)
        deletenodebutton_changes.nodeId = /*nodeId*/
        ctx2[1];
      deletenodebutton.$set(deletenodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(createcardbutton0.$$.fragment, local);
      transition_in(createcardbutton1.$$.fragment, local);
      transition_in(createcardbutton2.$$.fragment, local);
      transition_in(deletenodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(createcardbutton0.$$.fragment, local);
      transition_out(createcardbutton1.$$.fragment, local);
      transition_out(createcardbutton2.$$.fragment, local);
      transition_out(deletenodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(createcardbutton0, detaching);
      destroy_component(createcardbutton1, detaching);
      destroy_component(createcardbutton2, detaching);
      destroy_component(deletenodebutton, detaching);
    }
  };
}
function create_if_block6(ctx) {
  let collapsecardbutton;
  let current;
  collapsecardbutton = new collapse_card_button_default({
    props: {
      nodeId: (
        /*nodeId*/
        ctx[1]
      ),
      collapsed: (
        /*collapsed*/
        ctx[4]
      )
    }
  });
  return {
    c() {
      create_component(collapsecardbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(collapsecardbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const collapsecardbutton_changes = {};
      if (dirty & /*nodeId*/
      2)
        collapsecardbutton_changes.nodeId = /*nodeId*/
        ctx2[1];
      if (dirty & /*collapsed*/
      16)
        collapsecardbutton_changes.collapsed = /*collapsed*/
        ctx2[4];
      collapsecardbutton.$set(collapsecardbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(collapsecardbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(collapsecardbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(collapsecardbutton, detaching);
    }
  };
}
function create_fragment62(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*active*/
    (ctx[5] === "node" /* node */ || /*alwaysShowCardButtons*/
    ctx[6]) && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*outlineMode*/
    ctx[7] && /*hasChildren*/
    ctx[2] && create_if_block6(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*active*/
        ctx2[5] === "node" /* node */ || /*alwaysShowCardButtons*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*active, alwaysShowCardButtons*/
          96) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*outlineMode*/
        ctx2[7] && /*hasChildren*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*outlineMode, hasChildren*/
          132) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance62($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { nodeId } = $$props;
  let { hasChildren } = $$props;
  let { isInSidebar = false } = $$props;
  let { collapsed } = $$props;
  let { active } = $$props;
  let { alwaysShowCardButtons } = $$props;
  let { outlineMode } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
    if ("hasChildren" in $$props2)
      $$invalidate(2, hasChildren = $$props2.hasChildren);
    if ("isInSidebar" in $$props2)
      $$invalidate(3, isInSidebar = $$props2.isInSidebar);
    if ("collapsed" in $$props2)
      $$invalidate(4, collapsed = $$props2.collapsed);
    if ("active" in $$props2)
      $$invalidate(5, active = $$props2.active);
    if ("alwaysShowCardButtons" in $$props2)
      $$invalidate(6, alwaysShowCardButtons = $$props2.alwaysShowCardButtons);
    if ("outlineMode" in $$props2)
      $$invalidate(7, outlineMode = $$props2.outlineMode);
  };
  return [
    editing,
    nodeId,
    hasChildren,
    isInSidebar,
    collapsed,
    active,
    alwaysShowCardButtons,
    outlineMode
  ];
}
var Card_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      editing: 0,
      nodeId: 1,
      hasChildren: 2,
      isInSidebar: 3,
      collapsed: 4,
      active: 5,
      alwaysShowCardButtons: 6,
      outlineMode: 7
    });
  }
};
var card_buttons_default = Card_buttons;

// src/view/components/container/column/components/group/components/card/card.svelte
var import_classnames2 = __toESM(require_classnames());

// src/view/components/container/column/components/group/components/card/components/bridges/bridges.svelte
function add_css6(target) {
  append_styles(target, "svelte-7f61s4", ".active-node-bridge.svelte-7f61s4,.active-parent-bridge-right.svelte-7f61s4,.active-parent-bridge-left.svelte-7f61s4{height:100%;width:10px;position:absolute;top:0}.active-parent-bridge-right.svelte-7f61s4{right:-10px;background-color:var(--bg-color)}.active-parent-bridge-left.svelte-7f61s4{width:7px;left:-12px;background-color:var(--bg-color)}.active-node-bridge.svelte-7f61s4{right:-10px;background-color:var(--bg-color)}");
}
function create_if_block_13(ctx) {
  let div;
  let div_class_value;
  let t;
  let if_block_anchor;
  let if_block = !/*firstColumn*/
  ctx[3] && create_if_block_23(ctx);
  return {
    c() {
      div = element("div");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", div_class_value = null_to_empty("active-parent-bridge-right") + " svelte-7f61s4");
      set_style(
        div,
        "--bg-color",
        /*style*/
        ctx[4] && /*style*/
        ctx[4].styleVariant == "background-color" ? (
          /*style*/
          ctx[4].color
        ) : "var(--background-active-parent)"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*style*/
      16) {
        set_style(
          div,
          "--bg-color",
          /*style*/
          ctx2[4] && /*style*/
          ctx2[4].styleVariant == "background-color" ? (
            /*style*/
            ctx2[4].color
          ) : "var(--background-active-parent)"
        );
      }
      if (!/*firstColumn*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-node-bridge svelte-7f61s4");
      set_style(
        div,
        "--bg-color",
        /*style*/
        ctx[4] && /*style*/
        ctx[4].styleVariant == "background-color" ? "transparent" : "var(--background-active-node)"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*style*/
      16) {
        set_style(
          div,
          "--bg-color",
          /*style*/
          ctx2[4] && /*style*/
          ctx2[4].styleVariant == "background-color" ? "transparent" : "var(--background-active-node)"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-parent-bridge-left svelte-7f61s4");
      set_style(
        div,
        "--bg-color",
        /*style*/
        ctx[4] && /*style*/
        ctx[4].styleVariant == "background-color" ? (
          /*style*/
          ctx[4].color
        ) : "var(--background-active-parent)"
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*style*/
      16) {
        set_style(
          div,
          "--bg-color",
          /*style*/
          ctx2[4] && /*style*/
          ctx2[4].styleVariant == "background-color" ? (
            /*style*/
            ctx2[4].color
          ) : "var(--background-active-parent)"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment63(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*editing*/
    ctx2[0] && /*hasActiveChildren*/
    ctx2[1] && /*active*/
    ctx2[2] === "node" /* node */)
      return create_if_block7;
    if (
      /*active*/
      ctx2[2] === "parent" /* parent */
    )
      return create_if_block_13;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function instance63($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { hasActiveChildren } = $$props;
  let { active } = $$props;
  let { firstColumn } = $$props;
  let { style } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("hasActiveChildren" in $$props2)
      $$invalidate(1, hasActiveChildren = $$props2.hasActiveChildren);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("firstColumn" in $$props2)
      $$invalidate(3, firstColumn = $$props2.firstColumn);
    if ("style" in $$props2)
      $$invalidate(4, style = $$props2.style);
  };
  return [editing, hasActiveChildren, active, firstColumn, style];
}
var Bridges = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance63,
      create_fragment63,
      safe_not_equal,
      {
        editing: 0,
        hasActiveChildren: 1,
        active: 2,
        firstColumn: 3,
        style: 4
      },
      add_css6
    );
  }
};
var bridges_default = Bridges;

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id2 += urlAlphabet[bytes[size] & 63];
  }
  return id2;
};

// src/helpers/id.ts
var id_size = 8;
var id = {
  rootNode: () => "r" + nanoid(id_size),
  // node: () => 'n-' + RandomId.generateId('adjectives', 'nouns'),
  // column: () => 'c-' + RandomId.generateId('cities'),
  node: () => "n" + nanoid(id_size),
  column: () => "c" + nanoid(id_size),
  snapshot: () => "s" + nanoid(id_size),
  view: () => "v" + nanoid(id_size),
  canvas: () => "canvas-" + nanoid(id_size),
  styleRule: () => "sr" + nanoid(id_size)
};
var isId = {
  node: (text2) => text2.length === 9 && text2.startsWith("n")
};

// src/view/actions/dnd/droppable.ts
var getDropPosition = (event, targetElement) => {
  const boundingBox = targetElement.getBoundingClientRect();
  const mouseX = event.clientX;
  const mouseY = event.clientY;
  if (mouseY - boundingBox.top < boundingBox.height / 4) {
    return "up";
  } else if (boundingBox.bottom - mouseY < boundingBox.height / 4)
    return "down";
  else if (boundingBox.right - mouseX < boundingBox.width / 4)
    return "right";
};
var dropClasses = {
  up: "lineage__drop-node-above",
  down: "lineage__drop-node-below",
  right: "lineage__drop-node-under"
};
var classesList = Object.values(dropClasses);
var droppable = (node) => {
  const view = getView();
  const viewStore = view.viewStore;
  const documentStore = view.documentStore;
  function HandleDragLeave(event) {
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    event.currentTarget.removeClasses(classesList);
    event.currentTarget.removeClass("inactive-node-hover");
  }
  const handleDragOver = (event) => {
    event.preventDefault();
    if (!event.dataTransfer)
      return;
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    event.dataTransfer.dropEffect = "move";
    const position = getDropPosition(event, targetCard);
    targetCard.removeClasses(classesList);
    if (position) {
      targetCard.addClass(dropClasses[position]);
      if (targetCard.hasClass("inactive-node"))
        targetCard.addClass("inactive-node-hover");
    }
  };
  function handleDrop(event) {
    event.preventDefault();
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    if (!event.dataTransfer)
      return;
    const data = event.dataTransfer.getData("text/plain");
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    targetCard.removeClasses(classesList);
    targetCard.removeClass("inactive-node-hover");
    if (!data)
      throw new Error(`droppedNodeId is missing`);
    if (!targetCard.id)
      throw new Error(`targetCard.id is missing`);
    const sections = documentStore.getValue().sections;
    if (isId.node(data) && sections.id_section[data]) {
      documentStore.dispatch({
        type: "document/drop-node",
        payload: {
          droppedNodeId: data,
          targetNodeId: targetCard.id,
          position: getDropPosition(event, targetCard)
        }
      });
    } else if (!view.viewStore.getValue().document.editing.activeNodeId) {
      documentStore.dispatch({
        type: "document/paste-node",
        payload: {
          targetNodeId: targetCard.id,
          text: data,
          position: getDropPosition(event, targetCard)
        }
      });
    }
    viewStore.dispatch({
      type: "view/dnd/set-drag-ended"
    });
  }
  node.addEventListener("dragleave", HandleDragLeave);
  node.addEventListener("dragover", handleDragOver);
  node.addEventListener("drop", handleDrop);
  return {
    destroy() {
      node.removeEventListener("dragleave", HandleDragLeave);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    }
  };
};

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/obsidian/events/workspace/helpers/get-persisted-document-format.ts
var getPersistedDocumentFormat = (view, fail = true) => {
  invariant(view.file);
  const format2 = view.plugin.settings.getValue().documents[view.file.path]?.documentFormat;
  if (fail)
    invariant(format2);
  return format2;
};

// src/lib/data-conversion/helpers/html-comment-marker/parse-html-comment-marker.ts
var htmlCommentRegex = /\s*<!--\s*section:\s*((\d\.?)*(\d))[\w\s]*-->/;
var parseHtmlCommentMarker = (line) => {
  const results = htmlCommentRegex.exec(line);
  if (results) {
    const result = results[1];
    const split2 = result.split(".");
    const index = split2[split2.length - 1];
    const parent = result.substring(0, result.length - index.length - 1);
    return [parent, index, result];
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/find-section-position.ts
var findSectionPosition = (view, nodeId) => {
  const lines = view.data.split("\n");
  const treeIndex = get_store_value(view.documentStore).sections.id_section[nodeId];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith("<!--")) {
      const section = parseHtmlCommentMarker(line);
      if (section && section[2] === treeIndex) {
        return i;
      }
    }
  }
};

// src/helpers/clone.ts
var clone = (object) => JSON.parse(JSON.stringify(object));

// src/lib/data-conversion/json-to-x/json-to-outline.ts
var formatContent = (content, indent) => {
  const lines = content.split("\n");
  return lines.length === 1 ? lines[0] : lines.map((line, i) => i === 0 ? line : `${indent}  ${line}`).join("\n");
};
var nodeToOutline = (node, depth = 0) => {
  const indent = "	".repeat(depth);
  let outline2 = `${indent}- ${formatContent(node.content, indent)}
`;
  for (const child of node.children) {
    outline2 += nodeToOutline(child, depth + 1);
  }
  return outline2;
};
var jsonToOutline = (nodes, depth = 0) => {
  const mapped = nodes.map((node) => nodeToOutline(node, depth));
  const last = mapped.pop() || "";
  mapped.push(last.replace(/\n$/, ""));
  return mapped.join("");
};

// src/lib/data-conversion/x-to-json/columns-to-json.ts
var createTreeNode = (content = "") => {
  return {
    content: content.trim(),
    children: []
  };
};
var columnsToJson = (columns, content) => {
  const nodeMap = {};
  for (const column of columns) {
    for (const group of column.groups) {
      for (const node of group.nodes) {
        const treeNode = createTreeNode(content[node]?.content);
        let parentNode = nodeMap[group.parentId];
        if (!parentNode) {
          parentNode = createTreeNode();
          nodeMap[group.parentId] = parentNode;
        }
        parentNode.children.push(treeNode);
        nodeMap[node] = treeNode;
      }
    }
  }
  const roots = [];
  if (columns[0])
    for (const group of columns[0].groups) {
      for (const node of group.nodes) {
        const treeNode = nodeMap[node];
        if (treeNode) {
          roots.push(treeNode);
        } else {
          throw new Error(`could not find node ${node}`);
        }
      }
    }
  return roots;
};

// src/view/helpers/extract-frontmatter.ts
var extractFrontmatter = (markdown) => {
  const frontmatterRegex = /^---\n([\s\S]+?)\n---\n/;
  const match = markdown.match(frontmatterRegex);
  if (match) {
    const frontmatter = match[0];
    const data = markdown.slice(frontmatter.length);
    return { body: data, frontmatter: frontmatter.trim() + "\n" };
  } else {
    return { body: markdown, frontmatter: "" };
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/find-outline-position.ts
var findOutlinePosition = (view, nodeId) => {
  const documentStore = view.documentStore;
  const document2 = clone(documentStore.getValue().document);
  const id2 = nanoid(12);
  document2.content[nodeId].content = id2;
  const outline2 = jsonToOutline(
    columnsToJson(document2.columns, document2.content)
  );
  const { frontmatter } = extractFrontmatter(view.data);
  const frontmatterOffset = frontmatter.length ? frontmatter.split("\n").length - 1 : 0;
  const lines = outline2.split("\n");
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.contains(id2)) {
      return i + frontmatterOffset;
    }
  }
};

// src/stores/settings/actions/set-view-type.ts
var setViewType = (plugin, path, type) => {
  plugin.settings.dispatch({
    type: "settings/documents/set-view-type",
    payload: {
      path,
      type
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/openFileAndJumpToLine.ts
var getLeafFromExistingTabGroup = (view) => {
  const rightTabGroup = getExistingRightTabGroup(view);
  if (!rightTabGroup)
    return null;
  const workspace = view.plugin.app.workspace;
  if (!("createLeafInTabGroup" in workspace && typeof workspace.createLeafInTabGroup === "function"))
    return null;
  return workspace.createLeafInTabGroup(
    rightTabGroup
  );
};
var openFileAndJumpToLine = async (view, line, ch) => {
  const plugin = view.plugin;
  const file = view.file;
  if (!file)
    return;
  let leaf = getLeafFromExistingTabGroup(view);
  if (!leaf) {
    leaf = plugin.app.workspace.getLeaf("split");
  }
  setViewType(plugin, file.path, "markdown");
  await leaf.openFile(file);
  const markdownView = leaf.view;
  markdownView.editor.setCursor({ line, ch });
  setViewType(plugin, file.path, "lineage");
};

// src/lib/data-conversion/helpers/html-element-marker/parse-html-element-marker.ts
var htmlElementRegex = /<span data-section="((\d\.?)*(\d))"\s*(\/>|><\/span>)/;
var parseHtmlElementMarker = (line) => {
  const results = htmlElementRegex.exec(line);
  if (results) {
    const result = results[1];
    const split2 = result.split(".");
    const index = split2[split2.length - 1];
    const parent = result.substring(0, result.length - index.length - 1);
    return [parent, index, result];
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/find-html-element-position.ts
var findHtmlElementPosition = (view, nodeId) => {
  const lines = view.data.split("\n");
  const treeIndex = get_store_value(view.documentStore).sections.id_section[nodeId];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.includes("<span data-section=")) {
      const section = parseHtmlElementMarker(line);
      if (section && section[2] === treeIndex) {
        return i;
      }
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/pin-indicator.svelte
function add_css7(target) {
  append_styles(target, "svelte-180w9t5", ".pin-indicator.svelte-180w9t5{position:absolute;left:-20px;top:0px;cursor:default;& svg {\n            fill: var(--text-muted);\n            color: var(--text-muted);\n           width:16px !important;\n           height:16px !important;\n\n        }}");
}
function create_fragment64(ctx) {
  let span;
  let pin;
  let current;
  pin = new pin_default({ props: { class: "svg-icon", size: "10" } });
  return {
    c() {
      span = element("span");
      create_component(pin.$$.fragment);
      attr(span, "class", "pin-indicator svelte-180w9t5");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(pin, span, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(pin);
    }
  };
}
var Pin_indicator = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment64, safe_not_equal, {}, add_css7);
  }
};
var pin_indicator_default = Pin_indicator;

// src/view/components/container/column/components/group/components/card/components/card-buttons/tree-index-button.svelte
function add_css8(target) {
  append_styles(target, "svelte-1cmrwyv", ".tree-index.svelte-1cmrwyv{position:absolute;bottom:3px;right:8px;opacity:0.8;font-size:12px;cursor:pointer}.is-active.svelte-1cmrwyv{opacity:0.3}.is-active-child.svelte-1cmrwyv{opacity:0.3}.is-active-parent.svelte-1cmrwyv{opacity:0.6}");
}
function create_if_block8(ctx) {
  let pin;
  let current;
  pin = new pin_indicator_default({});
  return {
    c() {
      create_component(pin.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pin, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pin, detaching);
    }
  };
}
function create_fragment65(ctx) {
  let div;
  let t0;
  let span;
  let t1;
  let span_aria_label_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*pinned*/
    ctx[2] && create_if_block8(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*section*/
        ctx[1]
      );
      attr(span, "aria-label", span_aria_label_value = lang.card_btn_reveal_in_editor);
      attr(div, "class", div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx[0] ? (
        /*classes*/
        ctx[4][
          /*activeStatus*/
          ctx[0]
        ]
      ) : "")) + " svelte-1cmrwyv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      append(div, span);
      append(span, t1);
      current = true;
      if (!mounted) {
        dispose = listen(
          span,
          "click",
          /*openFile*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*pinned*/
        ctx2[2]
      ) {
        if (if_block) {
          if (dirty & /*pinned*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*section*/
      2)
        set_data(
          t1,
          /*section*/
          ctx2[1]
        );
      if (!current || dirty & /*activeStatus*/
      1 && div_class_value !== (div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx2[0] ? (
        /*classes*/
        ctx2[4][
          /*activeStatus*/
          ctx2[0]
        ]
      ) : "")) + " svelte-1cmrwyv")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance64($$self, $$props, $$invalidate) {
  const view = getView();
  let { nodeId } = $$props;
  let { activeStatus } = $$props;
  let { section } = $$props;
  let { pinned } = $$props;
  const openFile2 = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!view.file)
      return;
    const format2 = getPersistedDocumentFormat(view);
    const i = format2 === "sections" ? findSectionPosition(view, nodeId) : format2 === "html-element" ? findHtmlElementPosition(view, nodeId) : findOutlinePosition(view, nodeId);
    if (typeof i === "undefined")
      return;
    const targetLine = i + (format2 === "sections" ? 1 : 0);
    const lines = view.data.split("\n");
    const nextLine = lines[targetLine] || "";
    yield openFileAndJumpToLine(view, targetLine, nextLine.length);
  });
  const classes = {
    ["node" /* node */]: "is-active",
    ["child" /* child */]: "is-active-child",
    ["parent" /* parent */]: "is-active-parent",
    ["sibling" /* sibling */]: "is-active-parent"
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(5, nodeId = $$props2.nodeId);
    if ("activeStatus" in $$props2)
      $$invalidate(0, activeStatus = $$props2.activeStatus);
    if ("section" in $$props2)
      $$invalidate(1, section = $$props2.section);
    if ("pinned" in $$props2)
      $$invalidate(2, pinned = $$props2.pinned);
  };
  return [activeStatus, section, pinned, openFile2, classes, nodeId];
}
var Tree_index_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance64,
      create_fragment65,
      safe_not_equal,
      {
        nodeId: 5,
        activeStatus: 0,
        section: 1,
        pinned: 2
      },
      add_css8
    );
  }
};
var tree_index_button_default = Tree_index_button;

// src/view/components/container/column/components/group/components/card/components/card-style.svelte
function create_fragment66(ctx) {
  let div;
  let div_style_value;
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "style", div_style_value = `background-color: ${/*style*/
      ctx[0].color}`);
      attr(div, "class", div_class_value = /*style*/
      ctx[0].styleVariant === "background-color" ? "card-background-style" : "card-left-border-style");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*style*/
      1 && div_style_value !== (div_style_value = `background-color: ${/*style*/
      ctx2[0].color}`)) {
        attr(div, "style", div_style_value);
      }
      if (dirty & /*style*/
      1 && div_class_value !== (div_class_value = /*style*/
      ctx2[0].styleVariant === "background-color" ? "card-background-style" : "card-left-border-style")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance65($$self, $$props, $$invalidate) {
  let { style } = $$props;
  $$self.$$set = ($$props2) => {
    if ("style" in $$props2)
      $$invalidate(0, style = $$props2.style);
  };
  return [style];
}
var Card_style = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance65, create_fragment66, safe_not_equal, { style: 0 });
  }
};
var card_style_default = Card_style;

// src/view/components/container/column/components/group/components/card/card.svelte
function add_css9(target) {
  append_styles(target, "svelte-1nruoli", ":root{--node-width:400px;--min-node-height:100px}.lineage-card.svelte-1nruoli{width:var(--node-width);height:fit-content;display:flex;position:relative;font-size:16px;--scrollbar-thumb-bg:var(--color-base-30);--scrollbar-active-thumb-bg:var(--color-base-40)}.lineage-card.svelte-1nruoli:hover{z-index:10}.lineage-card.svelte-1nruoli::-webkit-scrollbar{display:initial}");
}
function create_if_block_14(ctx) {
  let cardstyle;
  let current;
  cardstyle = new card_style_default({ props: { style: (
    /*style*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(cardstyle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cardstyle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const cardstyle_changes = {};
      if (dirty & /*style*/
      8192)
        cardstyle_changes.style = /*style*/
        ctx2[13];
      cardstyle.$set(cardstyle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardstyle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardstyle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cardstyle, detaching);
    }
  };
}
function create_else_block6(ctx) {
  let draggable2;
  let current;
  draggable2 = new draggable_default({
    props: {
      nodeId: (
        /*node*/
        ctx[0]
      ),
      isInSidebar: (
        /*isInSidebar*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot56] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(draggable2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draggable2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const draggable_changes = {};
      if (dirty & /*node*/
      1)
        draggable_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*isInSidebar*/
      2048)
        draggable_changes.isInSidebar = /*isInSidebar*/
        ctx2[11];
      if (dirty & /*$$scope, node, isInSidebar, active*/
      1050629) {
        draggable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      draggable2.$set(draggable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(draggable2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draggable2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draggable2, detaching);
    }
  };
}
function create_if_block9(ctx) {
  let inlineeditor;
  let current;
  inlineeditor = new inline_editor_default({
    props: {
      nodeId: (
        /*node*/
        ctx[0]
      ),
      style: (
        /*style*/
        ctx[13]
      )
    }
  });
  return {
    c() {
      create_component(inlineeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlineeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlineeditor_changes = {};
      if (dirty & /*node*/
      1)
        inlineeditor_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*style*/
      8192)
        inlineeditor_changes.style = /*style*/
        ctx2[13];
      inlineeditor.$set(inlineeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlineeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlineeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlineeditor, detaching);
    }
  };
}
function create_default_slot56(ctx) {
  let content;
  let current;
  content = new content_default({
    props: {
      nodeId: (
        /*node*/
        ctx[0]
      ),
      isInSidebar: (
        /*isInSidebar*/
        ctx[11]
      ),
      active: (
        /*active*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (dirty & /*node*/
      1)
        content_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*isInSidebar*/
      2048)
        content_changes.isInSidebar = /*isInSidebar*/
        ctx2[11];
      if (dirty & /*active*/
      4)
        content_changes.active = /*active*/
        ctx2[2];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content, detaching);
    }
  };
}
function create_fragment67(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let cardbuttons;
  let t2;
  let treeindex;
  let t3;
  let bridges;
  let div_style_value;
  let div_class_value;
  let droppable_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*style*/
    ctx[13] && create_if_block_14(ctx)
  );
  const if_block_creators = [create_if_block9, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*active*/
      ctx2[2] === "node" /* node */ && /*editing*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  cardbuttons = new card_buttons_default({
    props: {
      editing: (
        /*editing*/
        ctx[1]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      ),
      hasChildren: (
        /*hasChildren*/
        ctx[4]
      ),
      isInSidebar: (
        /*isInSidebar*/
        ctx[11]
      ),
      collapsed: (
        /*collapsed*/
        ctx[15]
      ),
      active: (
        /*active*/
        ctx[2]
      ),
      alwaysShowCardButtons: (
        /*alwaysShowCardButtons*/
        ctx[17]
      ),
      outlineMode: (
        /*outlineMode*/
        ctx[14]
      )
    }
  });
  treeindex = new tree_index_button_default({
    props: {
      activeStatus: (
        /*active*/
        ctx[2]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      ),
      section: (
        /*section*/
        ctx[8]
      ),
      pinned: (
        /*pinned*/
        ctx[10]
      )
    }
  });
  bridges = new bridges_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      editing: (
        /*editing*/
        ctx[1]
      ),
      hasActiveChildren: (
        /*hasActiveChildren*/
        ctx[3]
      ),
      firstColumn: (
        /*firstColumn*/
        ctx[5]
      ),
      style: (
        /*style*/
        ctx[13]
      )
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      create_component(cardbuttons.$$.fragment);
      t2 = space();
      create_component(treeindex.$$.fragment);
      t3 = space();
      create_component(bridges.$$.fragment);
      attr(div, "style", div_style_value = /*outlineMode*/
      ctx[14] && /*depth*/
      ctx[18] > 0 ? `margin-left: calc(var(--node-indentation-width) * ${/*depth*/
      ctx[18]})` : "");
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames2.default)(
        "lineage-card",
        /*hidden*/
        ctx[16] ? "hidden-node" : "",
        /*active*/
        ctx[2] ? (
          /*activeStatusClasses*/
          ctx[19][
            /*active*/
            ctx[2]
          ]
        ) : (
          /*outlineMode*/
          ctx[14] ? " active-sibling" : " inactive-node"
        ),
        /*confirmDelete*/
        ctx[7] ? "node-border--delete" : (
          /*confirmDisableEdit*/
          ctx[6] ? "node-border--discard" : (
            /*editing*/
            ctx[1] ? "node-border--editing" : (
              /*selected*/
              ctx[9] ? "node-border--selected" : (
                /*isSearchMatch*/
                ctx[12] ? "node-border--search-match" : (
                  /*active*/
                  ctx[2] === "node" /* node */ ? "node-border--active" : void 0
                )
              )
            )
          )
        )
      )) + " svelte-1nruoli");
      attr(
        div,
        "id",
        /*node*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      mount_component(cardbuttons, div, null);
      append(div, t2);
      mount_component(treeindex, div, null);
      append(div, t3);
      mount_component(bridges, div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(droppable_action = droppable.call(null, div));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*style*/
        ctx2[13]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*style*/
          8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      const cardbuttons_changes = {};
      if (dirty & /*editing*/
      2)
        cardbuttons_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*node*/
      1)
        cardbuttons_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*hasChildren*/
      16)
        cardbuttons_changes.hasChildren = /*hasChildren*/
        ctx2[4];
      if (dirty & /*isInSidebar*/
      2048)
        cardbuttons_changes.isInSidebar = /*isInSidebar*/
        ctx2[11];
      if (dirty & /*collapsed*/
      32768)
        cardbuttons_changes.collapsed = /*collapsed*/
        ctx2[15];
      if (dirty & /*active*/
      4)
        cardbuttons_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*alwaysShowCardButtons*/
      131072)
        cardbuttons_changes.alwaysShowCardButtons = /*alwaysShowCardButtons*/
        ctx2[17];
      if (dirty & /*outlineMode*/
      16384)
        cardbuttons_changes.outlineMode = /*outlineMode*/
        ctx2[14];
      cardbuttons.$set(cardbuttons_changes);
      const treeindex_changes = {};
      if (dirty & /*active*/
      4)
        treeindex_changes.activeStatus = /*active*/
        ctx2[2];
      if (dirty & /*node*/
      1)
        treeindex_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*section*/
      256)
        treeindex_changes.section = /*section*/
        ctx2[8];
      if (dirty & /*pinned*/
      1024)
        treeindex_changes.pinned = /*pinned*/
        ctx2[10];
      treeindex.$set(treeindex_changes);
      const bridges_changes = {};
      if (dirty & /*active*/
      4)
        bridges_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*editing*/
      2)
        bridges_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*hasActiveChildren*/
      8)
        bridges_changes.hasActiveChildren = /*hasActiveChildren*/
        ctx2[3];
      if (dirty & /*firstColumn*/
      32)
        bridges_changes.firstColumn = /*firstColumn*/
        ctx2[5];
      if (dirty & /*style*/
      8192)
        bridges_changes.style = /*style*/
        ctx2[13];
      bridges.$set(bridges_changes);
      if (!current || dirty & /*outlineMode, depth*/
      278528 && div_style_value !== (div_style_value = /*outlineMode*/
      ctx2[14] && /*depth*/
      ctx2[18] > 0 ? `margin-left: calc(var(--node-indentation-width) * ${/*depth*/
      ctx2[18]})` : "")) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & /*hidden, active, outlineMode, confirmDelete, confirmDisableEdit, editing, selected, isSearchMatch*/
      86726 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames2.default)(
        "lineage-card",
        /*hidden*/
        ctx2[16] ? "hidden-node" : "",
        /*active*/
        ctx2[2] ? (
          /*activeStatusClasses*/
          ctx2[19][
            /*active*/
            ctx2[2]
          ]
        ) : (
          /*outlineMode*/
          ctx2[14] ? " active-sibling" : " inactive-node"
        ),
        /*confirmDelete*/
        ctx2[7] ? "node-border--delete" : (
          /*confirmDisableEdit*/
          ctx2[6] ? "node-border--discard" : (
            /*editing*/
            ctx2[1] ? "node-border--editing" : (
              /*selected*/
              ctx2[9] ? "node-border--selected" : (
                /*isSearchMatch*/
                ctx2[12] ? "node-border--search-match" : (
                  /*active*/
                  ctx2[2] === "node" /* node */ ? "node-border--active" : void 0
                )
              )
            )
          )
        )
      )) + " svelte-1nruoli")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*node*/
      1) {
        attr(
          div,
          "id",
          /*node*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(cardbuttons.$$.fragment, local);
      transition_in(treeindex.$$.fragment, local);
      transition_in(bridges.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(cardbuttons.$$.fragment, local);
      transition_out(treeindex.$$.fragment, local);
      transition_out(bridges.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      destroy_component(cardbuttons);
      destroy_component(treeindex);
      destroy_component(bridges);
      mounted = false;
      dispose();
    }
  };
}
function instance66($$self, $$props, $$invalidate) {
  let { node } = $$props;
  let { editing } = $$props;
  let { active } = $$props;
  let { hasActiveChildren } = $$props;
  let { hasChildren } = $$props;
  let { firstColumn } = $$props;
  let { confirmDisableEdit } = $$props;
  let { confirmDelete } = $$props;
  let { section } = $$props;
  let { selected } = $$props;
  let { pinned } = $$props;
  let { isInSidebar = false } = $$props;
  let { isSearchMatch = false } = $$props;
  let { style } = $$props;
  let { outlineMode } = $$props;
  let { collapsed } = $$props;
  let { hidden } = $$props;
  let { alwaysShowCardButtons } = $$props;
  const activeStatusClasses = {
    ["node" /* node */]: "active-node",
    ["child" /* child */]: "active-child",
    ["parent" /* parent */]: "active-parent",
    ["sibling" /* sibling */]: "active-sibling"
  };
  let depth = 0;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("editing" in $$props2)
      $$invalidate(1, editing = $$props2.editing);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("hasActiveChildren" in $$props2)
      $$invalidate(3, hasActiveChildren = $$props2.hasActiveChildren);
    if ("hasChildren" in $$props2)
      $$invalidate(4, hasChildren = $$props2.hasChildren);
    if ("firstColumn" in $$props2)
      $$invalidate(5, firstColumn = $$props2.firstColumn);
    if ("confirmDisableEdit" in $$props2)
      $$invalidate(6, confirmDisableEdit = $$props2.confirmDisableEdit);
    if ("confirmDelete" in $$props2)
      $$invalidate(7, confirmDelete = $$props2.confirmDelete);
    if ("section" in $$props2)
      $$invalidate(8, section = $$props2.section);
    if ("selected" in $$props2)
      $$invalidate(9, selected = $$props2.selected);
    if ("pinned" in $$props2)
      $$invalidate(10, pinned = $$props2.pinned);
    if ("isInSidebar" in $$props2)
      $$invalidate(11, isInSidebar = $$props2.isInSidebar);
    if ("isSearchMatch" in $$props2)
      $$invalidate(12, isSearchMatch = $$props2.isSearchMatch);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("outlineMode" in $$props2)
      $$invalidate(14, outlineMode = $$props2.outlineMode);
    if ("collapsed" in $$props2)
      $$invalidate(15, collapsed = $$props2.collapsed);
    if ("hidden" in $$props2)
      $$invalidate(16, hidden = $$props2.hidden);
    if ("alwaysShowCardButtons" in $$props2)
      $$invalidate(17, alwaysShowCardButtons = $$props2.alwaysShowCardButtons);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*section*/
    256) {
      $:
        $$invalidate(18, depth = section ? section.split(".").length - 1 : 0);
    }
  };
  return [
    node,
    editing,
    active,
    hasActiveChildren,
    hasChildren,
    firstColumn,
    confirmDisableEdit,
    confirmDelete,
    section,
    selected,
    pinned,
    isInSidebar,
    isSearchMatch,
    style,
    outlineMode,
    collapsed,
    hidden,
    alwaysShowCardButtons,
    depth,
    activeStatusClasses
  ];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance66,
      create_fragment67,
      safe_not_equal,
      {
        node: 0,
        editing: 1,
        active: 2,
        hasActiveChildren: 3,
        hasChildren: 4,
        firstColumn: 5,
        confirmDisableEdit: 6,
        confirmDelete: 7,
        section: 8,
        selected: 9,
        pinned: 10,
        isInSidebar: 11,
        isSearchMatch: 12,
        style: 13,
        outlineMode: 14,
        collapsed: 15,
        hidden: 16,
        alwaysShowCardButtons: 17
      },
      add_css9
    );
  }
};
var card_default = Card;

// src/view/components/container/column/components/group/group.svelte
var import_classnames3 = __toESM(require_classnames());

// src/stores/document/derived/groups-store.ts
var findColumn = (columns, columnId) => {
  return columns.find((c) => c.id === columnId);
};
var groupsStore = (view, columnId) => {
  let column;
  let columns;
  return derived2(view.documentStore, (state2) => {
    if (!column || columns !== state2.document.columns) {
      columns = state2.document.columns;
      column = findColumn(columns, columnId);
      if (!column)
        return [];
    }
    return column.groups;
  });
};
var singleColumnGroupStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.document.columns.length > 0 ? state2.document.columns[0].groups : [];
  });
};

// src/lib/tree-utils/sort/sort-tree-nodes.ts
var sortTreeNodes = (columns) => {
  if (columns.length === 0)
    return [];
  const sortedNodes = [];
  const stack = [];
  for (const group of columns[0].groups) {
    for (let i = group.nodes.length - 1; i >= 0; i--) {
      stack.push({ nodeId: group.nodes[i], columnIndex: 0 });
    }
  }
  while (stack.length > 0) {
    const item = stack.pop();
    sortedNodes.push(item.nodeId);
    if (item.columnIndex + 1 < columns.length) {
      const nextColumn = columns[item.columnIndex + 1];
      for (const group of nextColumn.groups) {
        if (group.parentId === item.nodeId) {
          for (let i = group.nodes.length - 1; i >= 0; i--) {
            stack.push({
              nodeId: group.nodes[i],
              columnIndex: item.columnIndex + 1
            });
          }
        }
      }
    }
  }
  return sortedNodes;
};

// src/stores/document/derived/nodes-store.ts
var findGroup = (columns, columnId, groupId) => {
  const column = findColumn(columns, columnId);
  if (column) {
    return column.groups.find((group) => group.parentId === groupId);
  }
};
var nodesStore = (view, columnId, groupId) => {
  let group;
  let columns;
  return derived2(view.documentStore, (state2) => {
    if (!group || columns !== state2.document.columns) {
      columns = state2.document.columns;
      group = findGroup(columns, columnId, groupId);
      if (!group)
        return [];
    }
    return group.nodes;
  });
};
var singleColumnNodesStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return sortTreeNodes(state2.document.columns);
  });
};

// src/view/components/container/column/components/group/group.svelte
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_if_block10(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_id_value;
  let current;
  let each_value = ensure_array_like(
    /*$nodes*/
    ctx[22]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[27]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = (0, import_classnames3.default)(
        "group",
        /*(parentNodes.has(groupId) ||
        outlineMode ||
        (firstColumn && parentNodes.size > 0)) &&
        'group-has-active-parent',*/
        /*activeChildGroups*/
        (ctx[1].has(
          /*groupId*/
          ctx[0]
        ) || /*outlineMode*/
        ctx[17]) && "group-has-active-child",
        /*activeGroup*/
        (ctx[4] === /*groupId*/
        ctx[0] || /*outlineMode*/
        ctx[17]) && "group-has-active-node"
      ));
      attr(div, "id", div_id_value = "group-" + /*groupId*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$nodes, activeNode, parentNodes, activeChildGroups, groupId, activeGroup, editedNodeState, pendingConfirmation, groupParentIds, idSection, selectedNodes, pinnedNodes, searchResults, firstColumn, styleRules, outlineMode, collapsedParents, hiddenNodes, alwaysShowCardButtons, searchQuery, showAllNodes, searching, allDndNodes*/
      8388607) {
        each_value = ensure_array_like(
          /*$nodes*/
          ctx2[22]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
      if (!current || dirty & /*activeChildGroups, groupId, outlineMode, activeGroup*/
      131091 && div_class_value !== (div_class_value = (0, import_classnames3.default)(
        "group",
        /*(parentNodes.has(groupId) ||
        outlineMode ||
        (firstColumn && parentNodes.size > 0)) &&
        'group-has-active-parent',*/
        /*activeChildGroups*/
        (ctx2[1].has(
          /*groupId*/
          ctx2[0]
        ) || /*outlineMode*/
        ctx2[17]) && "group-has-active-child",
        /*activeGroup*/
        (ctx2[4] === /*groupId*/
        ctx2[0] || /*outlineMode*/
        ctx2[17]) && "group-has-active-node"
      ))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*groupId*/
      1 && div_id_value !== (div_id_value = "group-" + /*groupId*/
      ctx2[0])) {
        attr(div, "id", div_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_15(ctx) {
  let node_1;
  let current;
  node_1 = new card_default({
    props: {
      node: (
        /*node*/
        ctx[27]
      ),
      active: (
        /*node*/
        ctx[27] === /*activeNode*/
        ctx[5] ? "node" /* node */ : (
          /*parentNodes*/
          ctx[3].has(
            /*node*/
            ctx[27]
          ) ? "parent" /* parent */ : (
            /*activeChildGroups*/
            ctx[1].has(
              /*groupId*/
              ctx[0]
            ) ? "child" /* child */ : (
              /*activeGroup*/
              ctx[4] === /*groupId*/
              ctx[0] ? "sibling" /* sibling */ : null
            )
          )
        )
      ),
      editing: (
        /*editedNodeState*/
        ctx[6].activeNodeId === /*node*/
        ctx[27] && !/*editedNodeState*/
        ctx[6].isInSidebar
      ),
      confirmDisableEdit: (
        /*editedNodeState*/
        ctx[6].activeNodeId === /*node*/
        ctx[27] && /*pendingConfirmation*/
        ctx[7].disableEdit === /*node*/
        ctx[27] && !/*editedNodeState*/
        ctx[6].isInSidebar
      ),
      confirmDelete: (
        /*pendingConfirmation*/
        ctx[7].deleteNode.has(
          /*node*/
          ctx[27]
        )
      ),
      hasActiveChildren: (
        /*activeChildGroups*/
        ctx[1].size > 0
      ),
      hasChildren: (
        /*groupParentIds*/
        ctx[14].has(
          /*node*/
          ctx[27]
        )
      ),
      section: (
        /*idSection*/
        ctx[13][
          /*node*/
          ctx[27]
        ]
      ),
      selected: (
        /*selectedNodes*/
        ctx[2].has(
          /*node*/
          ctx[27]
        )
      ),
      pinned: (
        /*pinnedNodes*/
        ctx[11].has(
          /*node*/
          ctx[27]
        )
      ),
      isSearchMatch: (
        /*searchResults*/
        ctx[9].has(
          /*node*/
          ctx[27]
        )
      ),
      firstColumn: (
        /*firstColumn*/
        ctx[15]
      ),
      style: (
        /*styleRules*/
        ctx[16].get(
          /*node*/
          ctx[27]
        )
      ),
      outlineMode: (
        /*outlineMode*/
        ctx[17]
      ),
      collapsed: (
        /*collapsedParents*/
        ctx[19].has(
          /*node*/
          ctx[27]
        )
      ),
      hidden: (
        /*hiddenNodes*/
        ctx[20].has(
          /*node*/
          ctx[27]
        )
      ),
      alwaysShowCardButtons: (
        /*alwaysShowCardButtons*/
        ctx[21]
      )
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const node_1_changes = {};
      if (dirty & /*$nodes*/
      4194304)
        node_1_changes.node = /*node*/
        ctx2[27];
      if (dirty & /*$nodes, activeNode, parentNodes, activeChildGroups, groupId, activeGroup*/
      4194363)
        node_1_changes.active = /*node*/
        ctx2[27] === /*activeNode*/
        ctx2[5] ? "node" /* node */ : (
          /*parentNodes*/
          ctx2[3].has(
            /*node*/
            ctx2[27]
          ) ? "parent" /* parent */ : (
            /*activeChildGroups*/
            ctx2[1].has(
              /*groupId*/
              ctx2[0]
            ) ? "child" /* child */ : (
              /*activeGroup*/
              ctx2[4] === /*groupId*/
              ctx2[0] ? "sibling" /* sibling */ : null
            )
          )
        );
      if (dirty & /*editedNodeState, $nodes*/
      4194368)
        node_1_changes.editing = /*editedNodeState*/
        ctx2[6].activeNodeId === /*node*/
        ctx2[27] && !/*editedNodeState*/
        ctx2[6].isInSidebar;
      if (dirty & /*editedNodeState, $nodes, pendingConfirmation*/
      4194496)
        node_1_changes.confirmDisableEdit = /*editedNodeState*/
        ctx2[6].activeNodeId === /*node*/
        ctx2[27] && /*pendingConfirmation*/
        ctx2[7].disableEdit === /*node*/
        ctx2[27] && !/*editedNodeState*/
        ctx2[6].isInSidebar;
      if (dirty & /*pendingConfirmation, $nodes*/
      4194432)
        node_1_changes.confirmDelete = /*pendingConfirmation*/
        ctx2[7].deleteNode.has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*activeChildGroups*/
      2)
        node_1_changes.hasActiveChildren = /*activeChildGroups*/
        ctx2[1].size > 0;
      if (dirty & /*groupParentIds, $nodes*/
      4210688)
        node_1_changes.hasChildren = /*groupParentIds*/
        ctx2[14].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*idSection, $nodes*/
      4202496)
        node_1_changes.section = /*idSection*/
        ctx2[13][
          /*node*/
          ctx2[27]
        ];
      if (dirty & /*selectedNodes, $nodes*/
      4194308)
        node_1_changes.selected = /*selectedNodes*/
        ctx2[2].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*pinnedNodes, $nodes*/
      4196352)
        node_1_changes.pinned = /*pinnedNodes*/
        ctx2[11].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*searchResults, $nodes*/
      4194816)
        node_1_changes.isSearchMatch = /*searchResults*/
        ctx2[9].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*firstColumn*/
      32768)
        node_1_changes.firstColumn = /*firstColumn*/
        ctx2[15];
      if (dirty & /*styleRules, $nodes*/
      4259840)
        node_1_changes.style = /*styleRules*/
        ctx2[16].get(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*outlineMode*/
      131072)
        node_1_changes.outlineMode = /*outlineMode*/
        ctx2[17];
      if (dirty & /*collapsedParents, $nodes*/
      4718592)
        node_1_changes.collapsed = /*collapsedParents*/
        ctx2[19].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*hiddenNodes, $nodes*/
      5242880)
        node_1_changes.hidden = /*hiddenNodes*/
        ctx2[20].has(
          /*node*/
          ctx2[27]
        );
      if (dirty & /*alwaysShowCardButtons*/
      2097152)
        node_1_changes.alwaysShowCardButtons = /*alwaysShowCardButtons*/
        ctx2[21];
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function create_each_block4(key_1, ctx) {
  let first;
  let show_if = (
    /*searchQuery*/
    (ctx[8].length === 0 || /*showAllNodes*/
    ctx[10] || !/*searching*/
    ctx[12] && /*searchResults*/
    ctx[9].has(
      /*node*/
      ctx[27]
    )) && !/*allDndNodes*/
    ctx[18].has(
      /*node*/
      ctx[27]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_15(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*searchQuery, showAllNodes, searching, searchResults, $nodes, allDndNodes*/
      4462336)
        show_if = /*searchQuery*/
        (ctx[8].length === 0 || /*showAllNodes*/
        ctx[10] || !/*searching*/
        ctx[12] && /*searchResults*/
        ctx[9].has(
          /*node*/
          ctx[27]
        )) && !/*allDndNodes*/
        ctx[18].has(
          /*node*/
          ctx[27]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*searchQuery, showAllNodes, searching, searchResults, $nodes, allDndNodes*/
          4462336) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment68(ctx) {
  let show_if = (
    /*$nodes*/
    ctx[22].length > 0 && /*searchQuery*/
    (ctx[8].length === 0 || /*showAllNodes*/
    ctx[10] || /*searchResults*/
    ctx[9].size > 0 && /*$nodes*/
    ctx[22].some(
      /*func*/
      ctx[25]
    ))
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block10(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$nodes, searchQuery, showAllNodes, searchResults*/
      4196096)
        show_if = /*$nodes*/
        ctx2[22].length > 0 && /*searchQuery*/
        (ctx2[8].length === 0 || /*showAllNodes*/
        ctx2[10] || /*searchResults*/
        ctx2[9].size > 0 && /*$nodes*/
        ctx2[22].some(
          /*func*/
          ctx2[25]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$nodes, searchQuery, showAllNodes, searchResults*/
          4196096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance67($$self, $$props, $$invalidate) {
  let $nodes;
  let { groupId } = $$props;
  let { columnId } = $$props;
  let { activeChildGroups } = $$props;
  let { selectedNodes } = $$props;
  let { parentNodes } = $$props;
  let { activeGroup } = $$props;
  let { activeNode } = $$props;
  let { editedNodeState } = $$props;
  let { pendingConfirmation } = $$props;
  let { searchQuery } = $$props;
  let { searchResults } = $$props;
  let { showAllNodes } = $$props;
  let { pinnedNodes } = $$props;
  let { searching } = $$props;
  let { idSection } = $$props;
  let { groupParentIds } = $$props;
  let { firstColumn } = $$props;
  let { styleRules } = $$props;
  let { outlineMode } = $$props;
  let { allDndNodes } = $$props;
  let { collapsedParents } = $$props;
  let { hiddenNodes } = $$props;
  let { alwaysShowCardButtons } = $$props;
  const view = getView();
  const nodes = outlineMode ? singleColumnNodesStore(view) : nodesStore(view, columnId, groupId);
  component_subscribe($$self, nodes, (value) => $$invalidate(22, $nodes = value));
  const func2 = (n) => searchResults.has(n);
  $$self.$$set = ($$props2) => {
    if ("groupId" in $$props2)
      $$invalidate(0, groupId = $$props2.groupId);
    if ("columnId" in $$props2)
      $$invalidate(24, columnId = $$props2.columnId);
    if ("activeChildGroups" in $$props2)
      $$invalidate(1, activeChildGroups = $$props2.activeChildGroups);
    if ("selectedNodes" in $$props2)
      $$invalidate(2, selectedNodes = $$props2.selectedNodes);
    if ("parentNodes" in $$props2)
      $$invalidate(3, parentNodes = $$props2.parentNodes);
    if ("activeGroup" in $$props2)
      $$invalidate(4, activeGroup = $$props2.activeGroup);
    if ("activeNode" in $$props2)
      $$invalidate(5, activeNode = $$props2.activeNode);
    if ("editedNodeState" in $$props2)
      $$invalidate(6, editedNodeState = $$props2.editedNodeState);
    if ("pendingConfirmation" in $$props2)
      $$invalidate(7, pendingConfirmation = $$props2.pendingConfirmation);
    if ("searchQuery" in $$props2)
      $$invalidate(8, searchQuery = $$props2.searchQuery);
    if ("searchResults" in $$props2)
      $$invalidate(9, searchResults = $$props2.searchResults);
    if ("showAllNodes" in $$props2)
      $$invalidate(10, showAllNodes = $$props2.showAllNodes);
    if ("pinnedNodes" in $$props2)
      $$invalidate(11, pinnedNodes = $$props2.pinnedNodes);
    if ("searching" in $$props2)
      $$invalidate(12, searching = $$props2.searching);
    if ("idSection" in $$props2)
      $$invalidate(13, idSection = $$props2.idSection);
    if ("groupParentIds" in $$props2)
      $$invalidate(14, groupParentIds = $$props2.groupParentIds);
    if ("firstColumn" in $$props2)
      $$invalidate(15, firstColumn = $$props2.firstColumn);
    if ("styleRules" in $$props2)
      $$invalidate(16, styleRules = $$props2.styleRules);
    if ("outlineMode" in $$props2)
      $$invalidate(17, outlineMode = $$props2.outlineMode);
    if ("allDndNodes" in $$props2)
      $$invalidate(18, allDndNodes = $$props2.allDndNodes);
    if ("collapsedParents" in $$props2)
      $$invalidate(19, collapsedParents = $$props2.collapsedParents);
    if ("hiddenNodes" in $$props2)
      $$invalidate(20, hiddenNodes = $$props2.hiddenNodes);
    if ("alwaysShowCardButtons" in $$props2)
      $$invalidate(21, alwaysShowCardButtons = $$props2.alwaysShowCardButtons);
  };
  return [
    groupId,
    activeChildGroups,
    selectedNodes,
    parentNodes,
    activeGroup,
    activeNode,
    editedNodeState,
    pendingConfirmation,
    searchQuery,
    searchResults,
    showAllNodes,
    pinnedNodes,
    searching,
    idSection,
    groupParentIds,
    firstColumn,
    styleRules,
    outlineMode,
    allDndNodes,
    collapsedParents,
    hiddenNodes,
    alwaysShowCardButtons,
    $nodes,
    nodes,
    columnId,
    func2
  ];
}
var Group = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance67, create_fragment68, safe_not_equal, {
      groupId: 0,
      columnId: 24,
      activeChildGroups: 1,
      selectedNodes: 2,
      parentNodes: 3,
      activeGroup: 4,
      activeNode: 5,
      editedNodeState: 6,
      pendingConfirmation: 7,
      searchQuery: 8,
      searchResults: 9,
      showAllNodes: 10,
      pinnedNodes: 11,
      searching: 12,
      idSection: 13,
      groupParentIds: 14,
      firstColumn: 15,
      styleRules: 16,
      outlineMode: 17,
      allDndNodes: 18,
      collapsedParents: 19,
      hiddenNodes: 20,
      alwaysShowCardButtons: 21
    });
  }
};
var group_default = Group;

// src/view/components/container/column/column.svelte
function add_css10(target) {
  append_styles(target, "svelte-f71k1e", ".column.svelte-f71k1e::-webkit-scrollbar{display:none}.column-buffer.svelte-f71k1e{height:90%;min-width:var(--node-width)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function create_if_block11(ctx) {
  let group_1;
  let current;
  group_1 = new group_default({
    props: {
      groupId: (
        /*group*/
        ctx[26].parentId
      ),
      columnId: (
        /*columnId*/
        ctx[0]
      ),
      parentNodes: (
        /*parentNodes*/
        ctx[4]
      ),
      activeGroup: (
        /*activeGroup*/
        ctx[5]
      ),
      editedNodeState: (
        /*editedNodeState*/
        ctx[7]
      ),
      searchQuery: (
        /*searchQuery*/
        ctx[10]
      ),
      searchResults: (
        /*searchResults*/
        ctx[11]
      ),
      showAllNodes: (
        /*showAllNodes*/
        ctx[9]
      ),
      searching: (
        /*searching*/
        ctx[15]
      ),
      activeChildGroups: (
        /*activeChildGroups*/
        ctx[1]
      ),
      activeNode: (
        /*activeNode*/
        ctx[6]
      ),
      idSection: (
        /*idSection*/
        ctx[16]
      ),
      selectedNodes: (
        /*selectedNodes*/
        ctx[3]
      ),
      pinnedNodes: (
        /*pinnedNodes*/
        ctx[12]
      ),
      groupParentIds: (
        /*groupParentIds*/
        ctx[14]
      ),
      firstColumn: (
        /*firstColumn*/
        ctx[17]
      ),
      pendingConfirmation: (
        /*pendingConfirmation*/
        ctx[8]
      ),
      styleRules: (
        /*styleRules*/
        ctx[18]
      ),
      outlineMode: (
        /*outlineMode*/
        ctx[19]
      ),
      allDndNodes: (
        /*allDndNodes*/
        ctx[13]
      ),
      collapsedParents: (
        /*collapsedParents*/
        ctx[20]
      ),
      hiddenNodes: (
        /*hiddenNodes*/
        ctx[21]
      ),
      alwaysShowCardButtons: (
        /*alwaysShowCardButtons*/
        ctx[22]
      )
    }
  });
  return {
    c() {
      create_component(group_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_1_changes = {};
      if (dirty & /*$groups*/
      8388608)
        group_1_changes.groupId = /*group*/
        ctx2[26].parentId;
      if (dirty & /*columnId*/
      1)
        group_1_changes.columnId = /*columnId*/
        ctx2[0];
      if (dirty & /*parentNodes*/
      16)
        group_1_changes.parentNodes = /*parentNodes*/
        ctx2[4];
      if (dirty & /*activeGroup*/
      32)
        group_1_changes.activeGroup = /*activeGroup*/
        ctx2[5];
      if (dirty & /*editedNodeState*/
      128)
        group_1_changes.editedNodeState = /*editedNodeState*/
        ctx2[7];
      if (dirty & /*searchQuery*/
      1024)
        group_1_changes.searchQuery = /*searchQuery*/
        ctx2[10];
      if (dirty & /*searchResults*/
      2048)
        group_1_changes.searchResults = /*searchResults*/
        ctx2[11];
      if (dirty & /*showAllNodes*/
      512)
        group_1_changes.showAllNodes = /*showAllNodes*/
        ctx2[9];
      if (dirty & /*searching*/
      32768)
        group_1_changes.searching = /*searching*/
        ctx2[15];
      if (dirty & /*activeChildGroups*/
      2)
        group_1_changes.activeChildGroups = /*activeChildGroups*/
        ctx2[1];
      if (dirty & /*activeNode*/
      64)
        group_1_changes.activeNode = /*activeNode*/
        ctx2[6];
      if (dirty & /*idSection*/
      65536)
        group_1_changes.idSection = /*idSection*/
        ctx2[16];
      if (dirty & /*selectedNodes*/
      8)
        group_1_changes.selectedNodes = /*selectedNodes*/
        ctx2[3];
      if (dirty & /*pinnedNodes*/
      4096)
        group_1_changes.pinnedNodes = /*pinnedNodes*/
        ctx2[12];
      if (dirty & /*groupParentIds*/
      16384)
        group_1_changes.groupParentIds = /*groupParentIds*/
        ctx2[14];
      if (dirty & /*firstColumn*/
      131072)
        group_1_changes.firstColumn = /*firstColumn*/
        ctx2[17];
      if (dirty & /*pendingConfirmation*/
      256)
        group_1_changes.pendingConfirmation = /*pendingConfirmation*/
        ctx2[8];
      if (dirty & /*styleRules*/
      262144)
        group_1_changes.styleRules = /*styleRules*/
        ctx2[18];
      if (dirty & /*outlineMode*/
      524288)
        group_1_changes.outlineMode = /*outlineMode*/
        ctx2[19];
      if (dirty & /*allDndNodes*/
      8192)
        group_1_changes.allDndNodes = /*allDndNodes*/
        ctx2[13];
      if (dirty & /*collapsedParents*/
      1048576)
        group_1_changes.collapsedParents = /*collapsedParents*/
        ctx2[20];
      if (dirty & /*hiddenNodes*/
      2097152)
        group_1_changes.hiddenNodes = /*hiddenNodes*/
        ctx2[21];
      if (dirty & /*alwaysShowCardButtons*/
      4194304)
        group_1_changes.alwaysShowCardButtons = /*alwaysShowCardButtons*/
        ctx2[22];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group_1, detaching);
    }
  };
}
function create_each_block5(key_1, ctx) {
  let first;
  let show_if = !/*dndChildGroups*/
  ctx[2].has(
    /*group*/
    ctx[26].parentId
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block11(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*dndChildGroups, $groups*/
      8388612)
        show_if = !/*dndChildGroups*/
        ctx[2].has(
          /*group*/
          ctx[26].parentId
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*dndChildGroups, $groups*/
          8388612) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment69(ctx) {
  let div2;
  let div0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1;
  let current;
  let each_value = ensure_array_like(
    /*$groups*/
    ctx[23]
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[26].parentId
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "column-buffer svelte-f71k1e");
      attr(div1, "class", "column-buffer svelte-f71k1e");
      attr(div2, "class", "column svelte-f71k1e");
      attr(
        div2,
        "id",
        /*columnId*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t1);
      append(div2, div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$groups, columnId, parentNodes, activeGroup, editedNodeState, searchQuery, searchResults, showAllNodes, searching, activeChildGroups, activeNode, idSection, selectedNodes, pinnedNodes, groupParentIds, firstColumn, pendingConfirmation, styleRules, outlineMode, allDndNodes, collapsedParents, hiddenNodes, alwaysShowCardButtons, dndChildGroups*/
      16777215) {
        each_value = ensure_array_like(
          /*$groups*/
          ctx2[23]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div2, outro_and_destroy_block, create_each_block5, t1, get_each_context5);
        check_outros();
      }
      if (!current || dirty & /*columnId*/
      1) {
        attr(
          div2,
          "id",
          /*columnId*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance68($$self, $$props, $$invalidate) {
  let $groups;
  let { columnId } = $$props;
  let { activeChildGroups } = $$props;
  let { dndChildGroups } = $$props;
  let { selectedNodes } = $$props;
  let { parentNodes } = $$props;
  let { activeGroup } = $$props;
  let { activeNode } = $$props;
  let { editedNodeState } = $$props;
  let { pendingConfirmation } = $$props;
  let { showAllNodes } = $$props;
  let { searchQuery } = $$props;
  let { searchResults } = $$props;
  let { pinnedNodes } = $$props;
  let { allDndNodes } = $$props;
  let { groupParentIds } = $$props;
  let { searching } = $$props;
  let { idSection } = $$props;
  let { firstColumn } = $$props;
  let { styleRules } = $$props;
  let { outlineMode } = $$props;
  let { collapsedParents } = $$props;
  let { hiddenNodes } = $$props;
  let { alwaysShowCardButtons } = $$props;
  const view = getView();
  const groups = outlineMode ? singleColumnGroupStore(view) : groupsStore(view, columnId);
  component_subscribe($$self, groups, (value) => $$invalidate(23, $groups = value));
  $$self.$$set = ($$props2) => {
    if ("columnId" in $$props2)
      $$invalidate(0, columnId = $$props2.columnId);
    if ("activeChildGroups" in $$props2)
      $$invalidate(1, activeChildGroups = $$props2.activeChildGroups);
    if ("dndChildGroups" in $$props2)
      $$invalidate(2, dndChildGroups = $$props2.dndChildGroups);
    if ("selectedNodes" in $$props2)
      $$invalidate(3, selectedNodes = $$props2.selectedNodes);
    if ("parentNodes" in $$props2)
      $$invalidate(4, parentNodes = $$props2.parentNodes);
    if ("activeGroup" in $$props2)
      $$invalidate(5, activeGroup = $$props2.activeGroup);
    if ("activeNode" in $$props2)
      $$invalidate(6, activeNode = $$props2.activeNode);
    if ("editedNodeState" in $$props2)
      $$invalidate(7, editedNodeState = $$props2.editedNodeState);
    if ("pendingConfirmation" in $$props2)
      $$invalidate(8, pendingConfirmation = $$props2.pendingConfirmation);
    if ("showAllNodes" in $$props2)
      $$invalidate(9, showAllNodes = $$props2.showAllNodes);
    if ("searchQuery" in $$props2)
      $$invalidate(10, searchQuery = $$props2.searchQuery);
    if ("searchResults" in $$props2)
      $$invalidate(11, searchResults = $$props2.searchResults);
    if ("pinnedNodes" in $$props2)
      $$invalidate(12, pinnedNodes = $$props2.pinnedNodes);
    if ("allDndNodes" in $$props2)
      $$invalidate(13, allDndNodes = $$props2.allDndNodes);
    if ("groupParentIds" in $$props2)
      $$invalidate(14, groupParentIds = $$props2.groupParentIds);
    if ("searching" in $$props2)
      $$invalidate(15, searching = $$props2.searching);
    if ("idSection" in $$props2)
      $$invalidate(16, idSection = $$props2.idSection);
    if ("firstColumn" in $$props2)
      $$invalidate(17, firstColumn = $$props2.firstColumn);
    if ("styleRules" in $$props2)
      $$invalidate(18, styleRules = $$props2.styleRules);
    if ("outlineMode" in $$props2)
      $$invalidate(19, outlineMode = $$props2.outlineMode);
    if ("collapsedParents" in $$props2)
      $$invalidate(20, collapsedParents = $$props2.collapsedParents);
    if ("hiddenNodes" in $$props2)
      $$invalidate(21, hiddenNodes = $$props2.hiddenNodes);
    if ("alwaysShowCardButtons" in $$props2)
      $$invalidate(22, alwaysShowCardButtons = $$props2.alwaysShowCardButtons);
  };
  return [
    columnId,
    activeChildGroups,
    dndChildGroups,
    selectedNodes,
    parentNodes,
    activeGroup,
    activeNode,
    editedNodeState,
    pendingConfirmation,
    showAllNodes,
    searchQuery,
    searchResults,
    pinnedNodes,
    allDndNodes,
    groupParentIds,
    searching,
    idSection,
    firstColumn,
    styleRules,
    outlineMode,
    collapsedParents,
    hiddenNodes,
    alwaysShowCardButtons,
    $groups,
    groups
  ];
}
var Column = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance68,
      create_fragment69,
      safe_not_equal,
      {
        columnId: 0,
        activeChildGroups: 1,
        dndChildGroups: 2,
        selectedNodes: 3,
        parentNodes: 4,
        activeGroup: 5,
        activeNode: 6,
        editedNodeState: 7,
        pendingConfirmation: 8,
        showAllNodes: 9,
        searchQuery: 10,
        searchResults: 11,
        pinnedNodes: 12,
        allDndNodes: 13,
        groupParentIds: 14,
        searching: 15,
        idSection: 16,
        firstColumn: 17,
        styleRules: 18,
        outlineMode: 19,
        collapsedParents: 20,
        hiddenNodes: 21,
        alwaysShowCardButtons: 22
      },
      add_css10
    );
  }
};
var column_default = Column;

// src/view/actions/dnd/scroll-on-dnd-x/helpers/get-horizontal-buffer.ts
var getHorizontalBuffer = (container, direction) => {
  const columnsWrapper = container.firstElementChild;
  if (!columnsWrapper)
    return null;
  return direction === -1 ? columnsWrapper.firstElementChild : columnsWrapper.lastElementChild;
};

// src/view/actions/dnd/scroll-on-dnd-x/helpers/stop-horizontal-reveal.ts
var stopHorizontalReveal = (context) => {
  const isLeftEdge = context.state.direction === -1;
  if (isLeftEdge) {
    if (context.buffer) {
      const bufferRect = context.buffer.getBoundingClientRect();
      if (bufferRect.right - 100 > context.containerRect.left) {
        return true;
      }
    }
  } else if (context.state.direction === 1) {
    if (context.rightColumn) {
      const rect = context.rightColumn.getBoundingClientRect();
      if (rect.right + 100 < context.containerRect.right) {
        return true;
      }
    }
  }
};

// src/view/actions/dnd/scroll-on-dnd-x/helpers/scroll-horizontally.ts
var horizontalScrollStep = 30;
var scrollHorizontally = (context) => {
  if (context.state.direction === 0)
    return;
  if (stopHorizontalReveal(context))
    return;
  context.columnsContainer.scrollLeft += context.state.direction * horizontalScrollStep;
  requestAnimationFrame(() => scrollHorizontally(context));
};

// src/view/actions/dnd/scroll-on-dnd-x/helpers/get-right-most-column.ts
var getRightMostColumn = (container, direction) => {
  return direction === 1 ? Array.from(container.querySelectorAll(".column")).reverse().find(
    (x) => x.querySelectorAll(
      `.lineage-card:not(.${DND_ACTIVE_CLASS})`
    ).length > 0
  ) : null;
};

// src/view/actions/dnd/scroll-on-dnd-x/scroll-on-dnd-x.ts
var scrollOnDndX = (container) => {
  let leftEdge = null;
  let rightEdge = null;
  const view = getView();
  const state2 = {
    direction: 0
  };
  const handleDragEnter = (event) => {
    const containerRect = container.getBoundingClientRect();
    const target = event.target;
    if (!target)
      return;
    state2.direction = target.id === "dnd-edge-left" ? -1 : target.id === "dnd-edge-right" ? 1 : 0;
    const buffer = getHorizontalBuffer(container, state2.direction);
    const rightColumn = getRightMostColumn(container, state2.direction);
    if (!buffer)
      return;
    const context = {
      buffer,
      rightColumn,
      columnsContainer: container,
      containerRect,
      state: state2
    };
    scrollHorizontally(context);
  };
  const handleDragLeave = () => {
    state2.direction = 0;
  };
  setTimeout(() => {
    leftEdge = view.contentEl.querySelector("#dnd-edge-left");
    rightEdge = view.contentEl.querySelector("#dnd-edge-right");
    if (leftEdge && rightEdge) {
      leftEdge.addEventListener("dragenter", handleDragEnter);
      leftEdge.addEventListener("dragleave", handleDragLeave);
      rightEdge.addEventListener("dragenter", handleDragEnter);
      rightEdge.addEventListener("dragleave", handleDragLeave);
    }
  }, 100);
  return {
    destroy() {
      if (leftEdge && rightEdge) {
        leftEdge.removeEventListener("dragenter", handleDragEnter);
        leftEdge.removeEventListener("dragleave", handleDragLeave);
        rightEdge.removeEventListener("dragenter", handleDragEnter);
        rightEdge.removeEventListener("dragleave", handleDragLeave);
      }
    }
  };
};

// src/stores/document/derived/columns-store.ts
var columnsStore = (view) => derived2(view.documentStore, (state2) => state2.document.columns);
var singleColumnStore = (view) => derived2(view.documentStore, (state2) => {
  const column = state2.document.columns[0];
  return column ? [column] : [];
});

// src/view/components/container/buffers/columns-buffer.svelte
function create_fragment70(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "aria-label", "horizontal buffer");
      set_style(div, "min-height", "10px");
      set_style(div, "min-width", "calc(1/var(--zoom-level) * 100vw)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
var Columns_buffer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment70, safe_not_equal, {});
  }
};
var columns_buffer_default = Columns_buffer;

// src/stores/view/derived/dnd-store.ts
var dndStore = (view) => derived2(view.viewStore, (state2) => state2.document.dnd);

// src/stores/view/derived/active-branch-store.ts
var activeBranchStore = (view) => derived2(view.viewStore, (state2) => state2.document.activeBranch);

// src/stores/view/derived/active-node-store.ts
var activeNodeStore = (view) => derived2(view.viewStore, (state2) => state2.document.activeNode);

// src/stores/view/derived/editing-store.ts
var documentStateStore = (view) => derived2(view.viewStore, (state2) => state2.document.editing);

// src/stores/view/derived/search-store.ts
var searchStore = (view) => derived2(view.viewStore, (state2) => state2.search);

// src/stores/document/derived/id-section-store.ts
var IdSectionStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.sections.id_section;
  });
};

// src/stores/view/derived/selected-nodes-store.ts
var selectedNodesStore = (view) => derived2(view.viewStore, (state2) => state2.document.selectedNodes);

// src/stores/document/derived/pinned-nodes-store.ts
var PinnedNodesStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.pinnedNodes.Ids;
  });
};

// src/stores/document/derived/meta.ts
var GroupParentIdsStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.meta.groupParentIds;
  });
};

// src/stores/view/derived/pending-confirmation.ts
var PendingConfirmationStore = (view) => derived2(view.viewStore, (state2) => state2.document.pendingConfirmation);

// src/stores/view/derived/style-rules.ts
var NodeStylesStore = (view) => derived2(view.viewStore, (state2) => state2.styleRules.nodeStyles);
var AllRuleMatchesStore = (view) => derived2(view.viewStore, (state2) => state2.styleRules.allMatches);

// src/lib/tree-utils/get/get-all-children.ts
var getAllChildren = (columns, nodeId) => {
  const columnOfNode = findNodeColumn(columns, nodeId);
  const childGroups = /* @__PURE__ */ new Set([nodeId]);
  for (let i = columnOfNode + 1; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (childGroups.has(group.parentId)) {
        for (const childNodeId of group.nodes) {
          childGroups.add(childNodeId);
        }
      }
    }
  }
  childGroups.delete(nodeId);
  return Array.from(childGroups);
};

// src/view/actions/context-menu/card-context-menu/helpers/text-is-selected.ts
var textIsSelected = () => {
  const selectedText = activeWindow.getSelection()?.toString();
  return selectedText && selectedText.length > 0 ? true : false;
};

// src/stores/view/derived/outline-store.ts
var OutlineStore = (view) => derived2(view.viewStore, (state2) => state2.outline);

// src/view/actions/hide-floating-buttons.ts
var toggleHideButtons = (element2, hide) => {
  element2.toggleClass("hide-floating-buttons", hide);
};
var hideFloatingButtons = (element2) => {
  let timeoutHandle = null;
  let hidden = false;
  const delayedHideButtons = () => {
    timeoutHandle = setTimeout(() => {
      if (!hidden) {
        toggleHideButtons(element2, true);
        hidden = true;
      }
    }, 5 * 1e3);
  };
  const resetHideButtons = () => {
    if (timeoutHandle)
      clearTimeout(timeoutHandle);
    if (hidden) {
      toggleHideButtons(element2, false);
      hidden = false;
    }
  };
  const onMousemove = () => {
    resetHideButtons();
    delayedHideButtons();
  };
  element2.addEventListener("mousemove", onMousemove);
  return {
    destroy: () => {
      resetHideButtons();
      element2.removeEventListener("mousemove", onMousemove);
    }
  };
};

// src/view/actions/dnd/scroll-on-dnd-y/helpers/get-vertical-buffer.ts
var getVerticalBuffer = (direction, column) => {
  if (direction === -1) {
    return column.firstElementChild;
  } else
    return column.lastElementChild;
};

// src/view/actions/dnd/scroll-on-dnd-y/helpers/stop-vertical-reveal.ts
var stopVerticalReveal = (context, column) => {
  const buffer = getVerticalBuffer(context.state.direction, column);
  if (!buffer)
    return true;
  if (context.state.direction === -1) {
    const bufferBottom = buffer.getBoundingClientRect().bottom;
    return bufferBottom - 100 > context.containerRect.top;
  } else if (context.state.direction === 1) {
    const bufferTop = buffer.getBoundingClientRect().top;
    return bufferTop + 100 < context.containerRect.bottom;
  }
};

// src/view/actions/dnd/scroll-on-dnd-y/helpers/scroll-vertically.ts
var verticalScrollStep = 15;
var scrollVertically = (context) => {
  if (context.state.direction === 0)
    return;
  for (const column of context.columns) {
    if (stopVerticalReveal(context, column))
      continue;
    column.scrollTop += context.state.direction * verticalScrollStep;
  }
  requestAnimationFrame(() => scrollVertically(context));
};

// src/view/actions/dnd/scroll-on-dnd-y/scroll-on-dnd-y.ts
var scrollOnDndY = (container) => {
  let topEdge = null;
  let bottomEdge = null;
  const view = getView();
  const state2 = {
    direction: 0
  };
  const handleDragEnter = (event) => {
    event.preventDefault();
    const target = event.target;
    if (!target)
      return;
    state2.direction = target.id === "dnd-edge-top" ? -1 : target.id === "dnd-edge-bottom" ? 1 : 0;
    const columns = Array.from(
      container.querySelectorAll(".column")
    );
    const context = {
      columns,
      containerRect: container.getBoundingClientRect(),
      state: state2,
      edge: target
    };
    scrollVertically(context);
  };
  const handleDragLeave = () => {
    state2.direction = 0;
  };
  setTimeout(() => {
    topEdge = view.contentEl.querySelector("#dnd-edge-top");
    bottomEdge = view.contentEl.querySelector("#dnd-edge-bottom");
    if (topEdge && bottomEdge) {
      topEdge.addEventListener("dragenter", handleDragEnter);
      topEdge.addEventListener("dragleave", handleDragLeave);
      bottomEdge.addEventListener("dragenter", handleDragEnter);
      bottomEdge.addEventListener("dragleave", handleDragLeave);
    }
  }, 100);
  return {
    destroy() {
      if (topEdge && bottomEdge) {
        topEdge.removeEventListener("dragenter", handleDragEnter);
        topEdge.removeEventListener("dragleave", handleDragLeave);
        bottomEdge.removeEventListener("dragenter", handleDragEnter);
        bottomEdge.removeEventListener("dragleave", handleDragLeave);
      }
    }
  };
};

// src/view/components/container/container.svelte
function add_css11(target) {
  append_styles(target, "svelte-1dkv8lc", ".columns-container.svelte-1dkv8lc{--scrollbar-thumb-bg:transparent;--scrollbar-active-thumb-bg:transparent;--scrollbar-bg:transparent}.columns-container.svelte-1dkv8lc::-webkit-scrollbar{display:none}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  child_ctx[45] = i;
  return child_ctx;
}
function create_each_block6(key_1, ctx) {
  let first;
  let column_1;
  let current;
  column_1 = new column_default({
    props: {
      columnId: (
        /*column*/
        ctx[43].id
      ),
      dndChildGroups: (
        /*$dnd*/
        ctx[1].childGroups
      ),
      parentNodes: (
        /*parentNodes*/
        ctx[3]
      ),
      activeGroup: (
        /*$activeBranch*/
        ctx[2].group
      ),
      activeChildGroups: (
        /*$activeBranch*/
        ctx[2].childGroups
      ),
      activeNode: (
        /*$activeNode*/
        ctx[11]
      ),
      editedNodeState: (
        /*$editing*/
        ctx[12]
      ),
      searchQuery: (
        /*$search*/
        ctx[13].query
      ),
      searchResults: (
        /*$search*/
        ctx[13].results
      ),
      showAllNodes: (
        /*$search*/
        ctx[13].showAllNodes
      ),
      searching: (
        /*$search*/
        ctx[13].searching
      ),
      idSection: (
        /*$idSection*/
        ctx[14]
      ),
      selectedNodes: (
        /*$selectedNodes*/
        ctx[15]
      ),
      pinnedNodes: (
        /*pinnedNodes*/
        ctx[6]
      ),
      pendingConfirmation: (
        /*$pendingConfirmation*/
        ctx[16]
      ),
      groupParentIds: (
        /*$groupParentIds*/
        ctx[17]
      ),
      firstColumn: (
        /*i*/
        ctx[45] === 0
      ),
      styleRules: (
        /*$styleRules*/
        ctx[18]
      ),
      outlineMode: (
        /*outlineMode*/
        ctx[0]
      ),
      allDndNodes: (
        /*allDndNodes*/
        ctx[4]
      ),
      collapsedParents: (
        /*$outline*/
        ctx[19].collapsedParents
      ),
      hiddenNodes: (
        /*$outline*/
        ctx[19].hiddenNodes
      ),
      alwaysShowCardButtons: (
        /*$alwaysShowCardButtons*/
        ctx[20]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(column_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const column_1_changes = {};
      if (dirty[0] & /*$columns*/
      1024)
        column_1_changes.columnId = /*column*/
        ctx[43].id;
      if (dirty[0] & /*$dnd*/
      2)
        column_1_changes.dndChildGroups = /*$dnd*/
        ctx[1].childGroups;
      if (dirty[0] & /*parentNodes*/
      8)
        column_1_changes.parentNodes = /*parentNodes*/
        ctx[3];
      if (dirty[0] & /*$activeBranch*/
      4)
        column_1_changes.activeGroup = /*$activeBranch*/
        ctx[2].group;
      if (dirty[0] & /*$activeBranch*/
      4)
        column_1_changes.activeChildGroups = /*$activeBranch*/
        ctx[2].childGroups;
      if (dirty[0] & /*$activeNode*/
      2048)
        column_1_changes.activeNode = /*$activeNode*/
        ctx[11];
      if (dirty[0] & /*$editing*/
      4096)
        column_1_changes.editedNodeState = /*$editing*/
        ctx[12];
      if (dirty[0] & /*$search*/
      8192)
        column_1_changes.searchQuery = /*$search*/
        ctx[13].query;
      if (dirty[0] & /*$search*/
      8192)
        column_1_changes.searchResults = /*$search*/
        ctx[13].results;
      if (dirty[0] & /*$search*/
      8192)
        column_1_changes.showAllNodes = /*$search*/
        ctx[13].showAllNodes;
      if (dirty[0] & /*$search*/
      8192)
        column_1_changes.searching = /*$search*/
        ctx[13].searching;
      if (dirty[0] & /*$idSection*/
      16384)
        column_1_changes.idSection = /*$idSection*/
        ctx[14];
      if (dirty[0] & /*$selectedNodes*/
      32768)
        column_1_changes.selectedNodes = /*$selectedNodes*/
        ctx[15];
      if (dirty[0] & /*pinnedNodes*/
      64)
        column_1_changes.pinnedNodes = /*pinnedNodes*/
        ctx[6];
      if (dirty[0] & /*$pendingConfirmation*/
      65536)
        column_1_changes.pendingConfirmation = /*$pendingConfirmation*/
        ctx[16];
      if (dirty[0] & /*$groupParentIds*/
      131072)
        column_1_changes.groupParentIds = /*$groupParentIds*/
        ctx[17];
      if (dirty[0] & /*$columns*/
      1024)
        column_1_changes.firstColumn = /*i*/
        ctx[45] === 0;
      if (dirty[0] & /*$styleRules*/
      262144)
        column_1_changes.styleRules = /*$styleRules*/
        ctx[18];
      if (dirty[0] & /*outlineMode*/
      1)
        column_1_changes.outlineMode = /*outlineMode*/
        ctx[0];
      if (dirty[0] & /*allDndNodes*/
      16)
        column_1_changes.allDndNodes = /*allDndNodes*/
        ctx[4];
      if (dirty[0] & /*$outline*/
      524288)
        column_1_changes.collapsedParents = /*$outline*/
        ctx[19].collapsedParents;
      if (dirty[0] & /*$outline*/
      524288)
        column_1_changes.hiddenNodes = /*$outline*/
        ctx[19].hiddenNodes;
      if (dirty[0] & /*$alwaysShowCardButtons*/
      1048576)
        column_1_changes.alwaysShowCardButtons = /*$alwaysShowCardButtons*/
        ctx[20];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(column_1, detaching);
    }
  };
}
function create_fragment71(ctx) {
  let div1;
  let div0;
  let columnsbuffer0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let columnsbuffer1;
  let div1_class_value;
  let scrollOnDndX_action;
  let scrollOnDndY_action;
  let hideFloatingButtons_action;
  let current;
  let mounted;
  let dispose;
  columnsbuffer0 = new columns_buffer_default({});
  let each_value = ensure_array_like(
    /*$columns*/
    ctx[10]
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[43].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  columnsbuffer1 = new columns_buffer_default({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(columnsbuffer0.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(columnsbuffer1.$$.fragment);
      attr(div0, "class", "columns");
      attr(div1, "class", div1_class_value = null_to_empty("columns-container " + /*$limitPreviewHeight*/
      (ctx[7] ? " limit-card-height" : "") + /*$applyGap*/
      (ctx[8] ? " gap-between-cards" : "") + /*outlineMode*/
      (ctx[0] ? " outline-mode" : "") + /*$zoom*/
      (ctx[9] !== 1 ? " zoom-enabled" : "")) + " svelte-1dkv8lc");
      attr(div1, "id", "columns-container");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(columnsbuffer0, div0, null);
      append(div0, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t1);
      mount_component(columnsbuffer1, div0, null);
      ctx[42](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "click",
            /*saveNode*/
            ctx[38]
          ),
          listen(
            div1,
            "dblclick",
            /*centerActiveNode*/
            ctx[39]
          ),
          action_destroyer(scrollOnDndX_action = scrollOnDndX.call(null, div1)),
          action_destroyer(scrollOnDndY_action = scrollOnDndY.call(null, div1)),
          action_destroyer(hideFloatingButtons_action = hideFloatingButtons.call(null, div1))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$columns, $dnd, parentNodes, $activeBranch, $activeNode, $editing, $search, $idSection, $selectedNodes, pinnedNodes, $pendingConfirmation, $groupParentIds, $styleRules, outlineMode, allDndNodes, $outline, $alwaysShowCardButtons*/
      2096223) {
        each_value = ensure_array_like(
          /*$columns*/
          ctx2[10]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block6, t1, get_each_context6);
        check_outros();
      }
      if (!current || dirty[0] & /*$limitPreviewHeight, $applyGap, outlineMode, $zoom*/
      897 && div1_class_value !== (div1_class_value = null_to_empty("columns-container " + /*$limitPreviewHeight*/
      (ctx2[7] ? " limit-card-height" : "") + /*$applyGap*/
      (ctx2[8] ? " gap-between-cards" : "") + /*outlineMode*/
      (ctx2[0] ? " outline-mode" : "") + /*$zoom*/
      (ctx2[9] !== 1 ? " zoom-enabled" : "")) + " svelte-1dkv8lc")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(columnsbuffer0.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(columnsbuffer1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(columnsbuffer0.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(columnsbuffer1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(columnsbuffer0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(columnsbuffer1);
      ctx[42](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance69($$self, $$props, $$invalidate) {
  let pinnedNodes;
  let $dnd;
  let $pinnedNodesArray;
  let $activeBranch;
  let $limitPreviewHeight;
  let $applyGap;
  let $zoom;
  let $columns;
  let $activeNode;
  let $editing;
  let $search;
  let $idSection;
  let $selectedNodes;
  let $pendingConfirmation;
  let $groupParentIds;
  let $styleRules;
  let $outline;
  let $alwaysShowCardButtons;
  let { outlineMode } = $$props;
  const view = getView();
  const columns = outlineMode ? singleColumnStore(view) : columnsStore(view);
  component_subscribe($$self, columns, (value) => $$invalidate(10, $columns = value));
  const dnd = dndStore(view);
  component_subscribe($$self, dnd, (value) => $$invalidate(1, $dnd = value));
  const activeBranch = activeBranchStore(view);
  component_subscribe($$self, activeBranch, (value) => $$invalidate(2, $activeBranch = value));
  const activeNode = activeNodeStore(view);
  component_subscribe($$self, activeNode, (value) => $$invalidate(11, $activeNode = value));
  const selectedNodes = selectedNodesStore(view);
  component_subscribe($$self, selectedNodes, (value) => $$invalidate(15, $selectedNodes = value));
  const editing = documentStateStore(view);
  component_subscribe($$self, editing, (value) => $$invalidate(12, $editing = value));
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(13, $search = value));
  const limitPreviewHeight = limitPreviewHeightStore(view);
  component_subscribe($$self, limitPreviewHeight, (value) => $$invalidate(7, $limitPreviewHeight = value));
  const idSection = IdSectionStore(view);
  component_subscribe($$self, idSection, (value) => $$invalidate(14, $idSection = value));
  const styleRules = NodeStylesStore(view);
  component_subscribe($$self, styleRules, (value) => $$invalidate(18, $styleRules = value));
  let parentNodes = /* @__PURE__ */ new Set();
  const groupParentIds = GroupParentIdsStore(view);
  component_subscribe($$self, groupParentIds, (value) => $$invalidate(17, $groupParentIds = value));
  const pinnedNodesArray = PinnedNodesStore(view);
  component_subscribe($$self, pinnedNodesArray, (value) => $$invalidate(41, $pinnedNodesArray = value));
  const outline2 = OutlineStore(view);
  component_subscribe($$self, outline2, (value) => $$invalidate(19, $outline = value));
  const alwaysShowCardButtons = AlwaysShowCardButtons(view);
  component_subscribe($$self, alwaysShowCardButtons, (value) => $$invalidate(20, $alwaysShowCardButtons = value));
  const zoom = zoomLevelStore(view);
  component_subscribe($$self, zoom, (value) => $$invalidate(9, $zoom = value));
  let allDndNodes = /* @__PURE__ */ new Set();
  const applyGap = ApplyGapBetweenCardsStore(view);
  component_subscribe($$self, applyGap, (value) => $$invalidate(8, $applyGap = value));
  const pendingConfirmation = PendingConfirmationStore(view);
  component_subscribe($$self, pendingConfirmation, (value) => $$invalidate(16, $pendingConfirmation = value));
  const saveNode = (event) => {
    const target = event.target;
    if (target.closest(".lng-prev") || target.closest(".active-node")) {
      return;
    }
    if (textIsSelected())
      return;
    const editingState = view.viewStore.getValue().document.editing;
    if (editingState.activeNodeId) {
      saveNodeContent(view, true);
    }
  };
  const centerActiveNode = (event) => {
    if (!event.shiftKey)
      return;
    const target = event.target;
    if (target.closest(".lng-prev") || target.closest(".active-node")) {
      return;
    }
    view.alignBranch.align({ type: "view/align-branch/center-node" });
  };
  let containerRef = null;
  onMount(() => {
    $$invalidate(40, view.container = containerRef, view);
    view.alignBranch.align({ type: "view/life-cycle/mount" });
    focusContainer(view);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerRef = $$value;
      $$invalidate(5, containerRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("outlineMode" in $$props2)
      $$invalidate(0, outlineMode = $$props2.outlineMode);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$activeBranch*/
    4) {
      $:
        $$invalidate(3, parentNodes = new Set($activeBranch.sortedParentNodes));
    }
    if ($$self.$$.dirty[1] & /*$pinnedNodesArray*/
    1024) {
      $:
        $$invalidate(6, pinnedNodes = new Set($pinnedNodesArray));
    }
    if ($$self.$$.dirty[0] & /*outlineMode, $dnd*/
    3 | $$self.$$.dirty[1] & /*view*/
    512) {
      $: {
        if (outlineMode && $dnd.node) {
          $$invalidate(4, allDndNodes = new Set(getAllChildren(view.documentStore.getValue().document.columns, $dnd.node)));
        } else {
          $$invalidate(4, allDndNodes = /* @__PURE__ */ new Set());
        }
      }
    }
  };
  return [
    outlineMode,
    $dnd,
    $activeBranch,
    parentNodes,
    allDndNodes,
    containerRef,
    pinnedNodes,
    $limitPreviewHeight,
    $applyGap,
    $zoom,
    $columns,
    $activeNode,
    $editing,
    $search,
    $idSection,
    $selectedNodes,
    $pendingConfirmation,
    $groupParentIds,
    $styleRules,
    $outline,
    $alwaysShowCardButtons,
    columns,
    dnd,
    activeBranch,
    activeNode,
    selectedNodes,
    editing,
    search2,
    limitPreviewHeight,
    idSection,
    styleRules,
    groupParentIds,
    pinnedNodesArray,
    outline2,
    alwaysShowCardButtons,
    zoom,
    applyGap,
    pendingConfirmation,
    saveNode,
    centerActiveNode,
    view,
    $pinnedNodesArray,
    div1_binding
  ];
}
var Container = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance69, create_fragment71, safe_not_equal, { outlineMode: 0 }, add_css11, [-1, -1]);
  }
};
var container_default = Container;

// src/view/components/container/container-wrapper.svelte
function create_if_block12(ctx) {
  let container;
  let current;
  container = new container_default({
    props: { outlineMode: (
      /*$outlineMode*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(container.$$.fragment);
    },
    m(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*$outlineMode*/
      2)
        container_changes.outlineMode = /*$outlineMode*/
        ctx2[1];
      container.$set(container_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(container, detaching);
    }
  };
}
function create_fragment72(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*unmounting*/
  ctx[0] && create_if_block12(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*unmounting*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*unmounting*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance70($$self, $$props, $$invalidate) {
  let $outlineMode;
  const view = getView();
  let unmounting = false;
  let interval = null;
  const unsubscribe = OutlineModeStore(view).subscribe((state2, action, isInitialRun) => {
    if (isInitialRun)
      return;
    $$invalidate(0, unmounting = true);
    if (interval)
      clearTimeout(interval);
    interval = setTimeout(
      () => {
        $$invalidate(0, unmounting = false);
      },
      16
    );
  });
  onDestroy(() => {
    unsubscribe();
  });
  const outlineMode = OutlineModeStore(view);
  component_subscribe($$self, outlineMode, (value) => $$invalidate(1, $outlineMode = value));
  return [unmounting, $outlineMode, outlineMode];
}
var Container_wrapper = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance70, create_fragment72, safe_not_equal, {});
  }
};
var container_wrapper_default = Container_wrapper;

// src/view/components/container/breadcrumbs/breadcrumbs-item.svelte
function add_css12(target) {
  append_styles(target, "svelte-pls2d1", ".separator.svelte-pls2d1{padding:2px 1px;color:var(--text-faint);min-width:8px}.breadcrumbs-item.svelte-pls2d1{height:30px;color:var(--text-muted);cursor:pointer;padding:2px 6px;max-width:350px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:12px;line-height:25px}.breadcrumbs-item.svelte-pls2d1:hover{background-color:var(--interactive-hover)}.breadcrumbs-item.svelte-pls2d1:first-child{padding-left:8px}.breadcrumbs-item.svelte-pls2d1:last-child{padding-right:8px}.section-number.svelte-pls2d1{font-style:italic;color:var(--text-faint)}");
}
function create_if_block13(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "/";
      attr(span, "class", "separator svelte-pls2d1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment73(ctx) {
  let t0;
  let span;
  let t1_value = (
    /*content*/
    (ctx[2] || /*section*/
    ctx[1]) + ""
  );
  let t1;
  let span_aria_label_value;
  let span_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*index*/
    ctx[0] > 0 && create_if_block13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "aria-label", span_aria_label_value = /*section*/
      ctx[1] + "\n" + /*content*/
      ctx[2]);
      attr(span, "class", span_class_value = null_to_empty(`breadcrumbs-item ${/*content*/
      ctx[2] ? "" : "section-number"}`) + " svelte-pls2d1");
      attr(span, "data-tooltip-position", "top");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          span,
          "click",
          /*onClick*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*index*/
        ctx2[0] > 0
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*content, section*/
      6 && t1_value !== (t1_value = /*content*/
      (ctx2[2] || /*section*/
      ctx2[1]) + ""))
        set_data(t1, t1_value);
      if (dirty & /*section, content*/
      6 && span_aria_label_value !== (span_aria_label_value = /*section*/
      ctx2[1] + "\n" + /*content*/
      ctx2[2])) {
        attr(span, "aria-label", span_aria_label_value);
      }
      if (dirty & /*content*/
      4 && span_class_value !== (span_class_value = null_to_empty(`breadcrumbs-item ${/*content*/
      ctx2[2] ? "" : "section-number"}`) + " svelte-pls2d1")) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance71($$self, $$props, $$invalidate) {
  let { parentId } = $$props;
  let { index } = $$props;
  let { section } = $$props;
  let { content } = $$props;
  const view = getView();
  const viewStore = view.viewStore;
  const onClick = () => {
    viewStore.dispatch({
      type: "view/set-active-node/mouse",
      payload: { id: parentId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("parentId" in $$props2)
      $$invalidate(4, parentId = $$props2.parentId);
    if ("index" in $$props2)
      $$invalidate(0, index = $$props2.index);
    if ("section" in $$props2)
      $$invalidate(1, section = $$props2.section);
    if ("content" in $$props2)
      $$invalidate(2, content = $$props2.content);
  };
  return [index, section, content, onClick, parentId];
}
var Breadcrumbs_item = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance71,
      create_fragment73,
      safe_not_equal,
      {
        parentId: 4,
        index: 0,
        section: 1,
        content: 2
      },
      add_css12
    );
  }
};
var breadcrumbs_item_default = Breadcrumbs_item;

// src/view/components/container/breadcrumbs/breadcrumbs.svelte
function add_css13(target) {
  append_styles(target, "svelte-1uz8lgp", ".breadcrumbs-container.svelte-1uz8lgp{z-index:var(--z-index-breadcrumbs);left:0;bottom:0;display:flex;position:absolute;max-width:calc(100% - var(--size-4-2) * 2 - 34px)}.breadcrumbs.svelte-1uz8lgp{display:flex;align-items:center;justify-content:center;border-style:solid;border-width:1px 1px 0 0;border-color:var(--status-bar-border-color);border-radius:0 6px 0 0;background-color:var(--status-bar-background);max-width:100%;overflow:hidden;font-size:var(--file-header-font-size);color:var(--text-muted);gap:0}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block7(key_1, ctx) {
  let first;
  let item;
  let current;
  item = new breadcrumbs_item_default({
    props: {
      parentId: (
        /*parentId*/
        ctx[7]
      ),
      index: (
        /*index*/
        ctx[9]
      ),
      content: (
        /*$contents*/
        ctx[1][
          /*parentId*/
          ctx[7]
        ]?.content
      ),
      section: (
        /*$sections*/
        ctx[2][
          /*parentId*/
          ctx[7]
        ]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(item.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const item_changes = {};
      if (dirty & /*$activeBranch*/
      1)
        item_changes.parentId = /*parentId*/
        ctx[7];
      if (dirty & /*$activeBranch*/
      1)
        item_changes.index = /*index*/
        ctx[9];
      if (dirty & /*$contents, $activeBranch*/
      3)
        item_changes.content = /*$contents*/
        ctx[1][
          /*parentId*/
          ctx[7]
        ]?.content;
      if (dirty & /*$sections, $activeBranch*/
      5)
        item_changes.section = /*$sections*/
        ctx[2][
          /*parentId*/
          ctx[7]
        ];
      item.$set(item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(item, detaching);
    }
  };
}
function create_fragment74(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*$activeBranch*/
    ctx[0].sortedParentNodes
  );
  const get_key = (ctx2) => (
    /*parentId*/
    ctx2[7]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "breadcrumbs svelte-1uz8lgp");
      attr(div1, "class", "breadcrumbs-container svelte-1uz8lgp");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$activeBranch, $contents, $sections*/
      7) {
        each_value = ensure_array_like(
          /*$activeBranch*/
          ctx2[0].sortedParentNodes
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block7, null, get_each_context7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance72($$self, $$props, $$invalidate) {
  let $activeBranch;
  let $contents;
  let $sections;
  const view = getView();
  const activeBranch = activeBranchStore(view);
  component_subscribe($$self, activeBranch, (value) => $$invalidate(0, $activeBranch = value));
  const contents = documentContentStore(view);
  component_subscribe($$self, contents, (value) => $$invalidate(1, $contents = value));
  const sections = IdSectionStore(view);
  component_subscribe($$self, sections, (value) => $$invalidate(2, $sections = value));
  return [$activeBranch, $contents, $sections, activeBranch, contents, sections];
}
var Breadcrumbs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance72, create_fragment74, safe_not_equal, {}, add_css13);
  }
};
var breadcrumbs_default = Breadcrumbs;

// src/stores/view/derived/navigation-history-store.ts
var navigationHistoryStore = (view) => derived2(view.viewStore, (state2) => state2.navigationHistory);

// src/view/components/container/toolbar/components/navigation-buttons.svelte
function add_css14(target) {
  append_styles(target, "svelte-13yyztm", ".navigation-history.svelte-13yyztm{display:flex;align-items:center;justify-content:center}");
}
function create_default_slot_12(ctx) {
  let arrowleft;
  let current;
  arrowleft = new arrow_left_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(arrowleft.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowleft, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowleft.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowleft.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowleft, detaching);
    }
  };
}
function create_default_slot57(ctx) {
  let arrowright;
  let current;
  arrowright = new arrow_right_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(arrowright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowright, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowright, detaching);
    }
  };
}
function create_fragment75(ctx) {
  let div;
  let button0;
  let t;
  let button1;
  let current;
  button0 = new button_default({
    props: {
      disabled: !/*$navigationHistory*/
      ctx[0].state.canGoBack,
      label: lang.tlb_navigation_navigate_back,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  button1 = new button_default({
    props: {
      disabled: !/*$navigationHistory*/
      ctx[0].state.canGoForward,
      label: lang.tlb_navigation_navigate_forward,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot57] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[4]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t = space();
      create_component(button1.$$.fragment);
      attr(div, "class", "navigation-history buttons-group svelte-13yyztm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t);
      mount_component(button1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*$navigationHistory*/
      1)
        button0_changes.disabled = !/*$navigationHistory*/
        ctx2[0].state.canGoBack;
      if (dirty & /*$$scope*/
      64) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$navigationHistory*/
      1)
        button1_changes.disabled = !/*$navigationHistory*/
        ctx2[0].state.canGoForward;
      if (dirty & /*$$scope*/
      64) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance73($$self, $$props, $$invalidate) {
  let $navigationHistory;
  const view = getView();
  const viewStore = view.viewStore;
  const navigationHistory = navigationHistoryStore(view);
  component_subscribe($$self, navigationHistory, (value) => $$invalidate(0, $navigationHistory = value));
  const click_handler = () => {
    viewStore.dispatch({
      type: "view/set-active-node/history/select-previous"
    });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({
      type: "view/set-active-node/history/select-next"
    });
  };
  return [
    $navigationHistory,
    viewStore,
    navigationHistory,
    click_handler,
    click_handler_1
  ];
}
var Navigation_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance73, create_fragment75, safe_not_equal, {}, add_css14);
  }
};
var navigation_buttons_default = Navigation_buttons;

// src/view/components/container/toolbar/components/search-toggle.svelte
function add_css15(target) {
  append_styles(target, "svelte-17l9x5j", ".search-container.svelte-17l9x5j{display:flex;align-items:center;justify-content:center;gap:var(--size-4-2)}");
}
function create_default_slot58(ctx) {
  let search_1;
  let current;
  search_1 = new search_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(search_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(search_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(search_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(search_1, detaching);
    }
  };
}
function create_fragment76(ctx) {
  let div;
  let button;
  let current;
  button = new button_default({
    props: {
      active: (
        /*$search*/
        ctx[0].showInput
      ),
      label: lang.tlb_search_toggle,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot58] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "search-container buttons-group svelte-17l9x5j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$search*/
      1)
        button_changes.active = /*$search*/
        ctx2[0].showInput;
      if (dirty & /*$$scope*/
      32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button);
    }
  };
}
function instance74($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const viewStore = view.viewStore;
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  const click_handler = () => {
    viewStore.dispatch({ type: "view/search/toggle-input" });
  };
  return [$search, viewStore, search2, click_handler];
}
var Search_toggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance74, create_fragment76, safe_not_equal, {}, add_css15);
  }
};
var search_toggle_default = Search_toggle;

// src/view/components/container/toolbar/components/search-input.svelte
function add_css16(target) {
  append_styles(target, "svelte-krr6j1", ".search-input-element.svelte-krr6j1{height:34px;padding-right:74px !important;padding-left:12px;min-width:250px}@media(max-width: 568px){.search-input-element.svelte-krr6j1{width:100%;min-width:50px}.search-input-wrapper.svelte-krr6j1{width:100%}}.search-input-wrapper.svelte-krr6j1{max-width:100%}.search-input-container.svelte-krr6j1::before{display:none}.no-results.svelte-krr6j1{box-shadow:0 0 0 2px var(--color-red) !important}");
}
function create_if_block14(ctx) {
  let div;
  let eye;
  let div_aria_label_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  eye = new eye_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div = element("div");
      create_component(eye.$$.fragment);
      attr(div, "aria-label", div_aria_label_value = lang.tlb_search_show_all_nodes);
      attr(div, "class", div_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx[0].showAllNodes ? " is-active" : "")) + " svelte-krr6j1");
      set_style(div, "right", "28px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(eye, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler_1*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$search*/
      1 && div_class_value !== (div_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx2[0].showAllNodes ? " is-active" : "")) + " svelte-krr6j1")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(eye.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(eye.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(eye);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment77(ctx) {
  let div2;
  let input;
  let input_autofocus_value;
  let input_class_value;
  let input_placeholder_value;
  let input_value_value;
  let t0;
  let div0;
  let div0_aria_label_value;
  let div0_style_value;
  let t1;
  let t2;
  let div1;
  let text_1;
  let div1_aria_label_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$search*/
    ctx[0].query.length > 0 && create_if_block14(ctx)
  );
  text_1 = new text_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div2 = element("div");
      input = element("input");
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div1 = element("div");
      create_component(text_1.$$.fragment);
      input.autofocus = input_autofocus_value = true;
      attr(input, "class", input_class_value = null_to_empty("search-input search-input-element" + /*$search*/
      (ctx[0].query && /*$search*/
      ctx[0].results.size === 0 && !/*$search*/
      ctx[0].searching ? " no-results" : "")) + " svelte-krr6j1");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = "search");
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      input.value = input_value_value = /*$search*/
      ctx[0].query;
      attr(div0, "aria-label", div0_aria_label_value = lang.tlb_search_clear);
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "style", div0_style_value = "right: 49px; top: -1px;" + /*$search*/
      (ctx[0].query ? "" : " display: none;"));
      attr(div1, "aria-label", div1_aria_label_value = lang.tlb_search_fuzzy_search);
      attr(div1, "class", div1_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx[0].fuzzySearch ? " is-active" : "")) + " svelte-krr6j1");
      set_style(div1, "right", "4px");
      attr(div2, "class", "search-input-wrapper search-input-container svelte-krr6j1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, input);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      mount_component(text_1, div1, null);
      current = true;
      if (true)
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*onInput*/
            ctx[3]
          ),
          listen(
            div0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            div1,
            "click",
            /*click_handler_2*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$search*/
      1 && input_class_value !== (input_class_value = null_to_empty("search-input search-input-element" + /*$search*/
      (ctx2[0].query && /*$search*/
      ctx2[0].results.size === 0 && !/*$search*/
      ctx2[0].searching ? " no-results" : "")) + " svelte-krr6j1")) {
        attr(input, "class", input_class_value);
      }
      if (!current || dirty & /*$search*/
      1 && input_value_value !== (input_value_value = /*$search*/
      ctx2[0].query) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (!current || dirty & /*$search*/
      1 && div0_style_value !== (div0_style_value = "right: 49px; top: -1px;" + /*$search*/
      (ctx2[0].query ? "" : " display: none;"))) {
        attr(div0, "style", div0_style_value);
      }
      if (
        /*$search*/
        ctx2[0].query.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$search*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$search*/
      1 && div1_class_value !== (div1_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx2[0].fuzzySearch ? " is-active" : "")) + " svelte-krr6j1")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      destroy_component(text_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance75($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const viewStore = view.viewStore;
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  const onInput = (
    // eslint-disable-next-line no-undef
    (e) => {
      viewStore.dispatch({
        type: "view/search/set-query",
        payload: { query: e.currentTarget.value }
      });
    }
  );
  const click_handler = () => {
    viewStore.dispatch({
      type: "view/search/set-query",
      payload: { query: "" }
    });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({
      type: "search/view/toggle-show-all-nodes"
    });
  };
  const click_handler_2 = () => {
    viewStore.dispatch({ type: "view/search/toggle-fuzzy-mode" });
    viewStore.dispatch({
      type: "view/search/set-query",
      payload: { query: viewStore.getValue().search.query }
    });
  };
  return [
    $search,
    viewStore,
    search2,
    onInput,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Search_input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance75, create_fragment77, safe_not_equal, {}, add_css16);
  }
};
var search_input_default = Search_input;

// src/view/components/container/toolbar/components/left-sidebar-toggle.svelte
function add_css17(target) {
  append_styles(target, "svelte-lmpj5w", ".badge-container.svelte-lmpj5w{position:relative;display:inline-block}");
}
function create_default_slot59(ctx) {
  let panelleftdashed;
  let current;
  panelleftdashed = new panel_left_dashed_default({ props: { class: "svg-icon", size: "32" } });
  return {
    c() {
      create_component(panelleftdashed.$$.fragment);
    },
    m(target, anchor) {
      mount_component(panelleftdashed, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(panelleftdashed.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(panelleftdashed.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(panelleftdashed, detaching);
    }
  };
}
function create_fragment78(ctx) {
  let div1;
  let div0;
  let button;
  let current;
  button = new button_default({
    props: {
      active: (
        /*$show*/
        ctx[0]
      ),
      label: lang.toolbar_toggle_left_sidebar,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot59] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*toggleLeftSidebar*/
    ctx[2]
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(button.$$.fragment);
      attr(div0, "class", "badge-container svelte-lmpj5w");
      attr(div1, "class", "buttons-group");
      set_style(div1, "overflow", "inherit");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(button, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$show*/
      1)
        button_changes.active = /*$show*/
        ctx2[0];
      if (dirty & /*$$scope*/
      16) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button);
    }
  };
}
function instance76($$self, $$props, $$invalidate) {
  let $show;
  const view = getView();
  const show = ShowLeftSidebarStore(view);
  component_subscribe($$self, show, (value) => $$invalidate(0, $show = value));
  const toggleLeftSidebar = () => {
    view.plugin.settings.dispatch({ type: "view/left-sidebar/toggle" });
  };
  return [$show, show, toggleLeftSidebar];
}
var Left_sidebar_toggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance76, create_fragment78, safe_not_equal, {}, add_css17);
  }
};
var left_sidebar_toggle_default = Left_sidebar_toggle;

// src/lib/tree-utils/sort/sort-sections.ts
var sortSections = (keys) => {
  return keys.sort((a, b) => {
    const aParts = a.split(".");
    const bParts = b.split(".");
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
      if (aParts[i] === void 0)
        return -1;
      if (bParts[i] === void 0)
        return 1;
      const diff2 = Number(aParts[i]) - Number(bParts[i]);
      if (diff2 !== 0)
        return diff2;
    }
    return 0;
  });
};

// src/lib/tree-utils/sort/sort-node-ids-by-section-number.ts
var sortNodeIdsBySectionNumber = (sections, ids) => {
  const pinnedSections = ids.map((id2) => sections.id_section[id2]);
  const sortedSections = sortSections(pinnedSections);
  return sortedSections.map((section) => sections.section_id[section]);
};

// src/view/components/container/toolbar/components/search/search-navigation-buttons.svelte
function add_css18(target) {
  append_styles(target, "svelte-1owtmzs", ".search-container.svelte-1owtmzs{display:flex;align-items:center;justify-content:center}.search-stats.svelte-1owtmzs{color:var(--text-muted);font-size:var(--status-bar-font-size);font-variant-numeric:tabular-nums;padding:5px 10px;border-left:1px solid var(--text-faint)}");
}
function create_default_slot_13(ctx) {
  let chevronup;
  let current;
  chevronup = new chevron_up_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(chevronup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronup, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(chevronup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronup, detaching);
    }
  };
}
function create_default_slot60(ctx) {
  let chevrondown;
  let current;
  chevrondown = new chevron_down_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(chevrondown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevrondown, detaching);
    }
  };
}
function create_fragment79(ctx) {
  let div1;
  let button0;
  let t0;
  let button1;
  let t1;
  let div0;
  let t2_value = `${/*sortedResults*/
  ctx[0].indexOf(
    /*$activeNode*/
    ctx[1]
  ) + 1} / ${/*sortedResults*/
  ctx[0].length}`;
  let t2;
  let current;
  button0 = new button_default({
    props: {
      disabled: (
        /*sortedResults*/
        ctx[0].length === 0
      ),
      label: lang.tlb_search_previous_result,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*selectPreviousResult*/
    ctx[4]
  );
  button1 = new button_default({
    props: {
      disabled: (
        /*sortedResults*/
        ctx[0].length === 0
      ),
      label: lang.tlb_search_next_result,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot60] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*selectNextResult*/
    ctx[3]
  );
  return {
    c() {
      div1 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "search-stats svelte-1owtmzs");
      attr(div1, "class", "search-container buttons-group svelte-1owtmzs");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(button0, div1, null);
      append(div1, t0);
      mount_component(button1, div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, t2);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*sortedResults*/
      1)
        button0_changes.disabled = /*sortedResults*/
        ctx2[0].length === 0;
      if (dirty & /*$$scope*/
      128) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*sortedResults*/
      1)
        button1_changes.disabled = /*sortedResults*/
        ctx2[0].length === 0;
      if (dirty & /*$$scope*/
      128) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      if ((!current || dirty & /*sortedResults, $activeNode*/
      3) && t2_value !== (t2_value = `${/*sortedResults*/
      ctx2[0].indexOf(
        /*$activeNode*/
        ctx2[1]
      ) + 1} / ${/*sortedResults*/
      ctx2[0].length}`))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance77($$self, $$props, $$invalidate) {
  let $activeNode;
  const view = getView();
  let { results } = $$props;
  const activeNode = activeNodeStore(view);
  component_subscribe($$self, activeNode, (value) => $$invalidate(1, $activeNode = value));
  let sortedResults;
  const selectNextResult = () => {
    if (sortedResults.length === 0)
      return;
    const currentIndex = sortedResults.indexOf($activeNode);
    const nextId = sortedResults[(currentIndex + 1) % sortedResults.length];
    view.viewStore.dispatch({
      type: "view/set-active-node/mouse",
      payload: { id: nextId }
    });
  };
  const selectPreviousResult = () => {
    if (sortedResults.length === 0)
      return;
    const currentIndex = sortedResults.indexOf($activeNode) === -1 ? sortedResults.length : sortedResults.indexOf($activeNode);
    const prevId = sortedResults[(currentIndex - 1 + sortedResults.length) % sortedResults.length];
    view.viewStore.dispatch({
      type: "view/set-active-node/mouse",
      payload: { id: prevId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("results" in $$props2)
      $$invalidate(5, results = $$props2.results);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*results*/
    32) {
      $: {
        $$invalidate(0, sortedResults = sortNodeIdsBySectionNumber(view.documentStore.getValue().sections, results));
      }
    }
  };
  return [
    sortedResults,
    $activeNode,
    activeNode,
    selectNextResult,
    selectPreviousResult,
    results
  ];
}
var Search_navigation_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance77, create_fragment79, safe_not_equal, { results: 5 }, add_css18);
  }
};
var search_navigation_buttons_default = Search_navigation_buttons;

// src/stores/document/derived/history-store.ts
var historyStore = (view) => {
  return derived2(view.documentStore, (state2) => {
    return state2.history;
  });
};

// src/view/components/container/toolbar/components/document-history-buttons.svelte
var import_obsidian6 = require("obsidian");
function add_css19(target) {
  append_styles(target, "svelte-5lrsw4", ".navigation-history.svelte-5lrsw4{display:flex;align-items:center;justify-content:center}");
}
function create_default_slot_2(ctx) {
  let historyicon;
  let current;
  historyicon = new history_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(historyicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(historyicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(historyicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(historyicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(historyicon, detaching);
    }
  };
}
function create_default_slot_14(ctx) {
  let undoicon;
  let current;
  undoicon = new undo_2_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(undoicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(undoicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(undoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(undoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(undoicon, detaching);
    }
  };
}
function create_default_slot61(ctx) {
  let redoicon;
  let current;
  redoicon = new redo_2_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(redoicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(redoicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(redoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(redoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(redoicon, detaching);
    }
  };
}
function create_fragment80(ctx) {
  let div;
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let current;
  button0 = new button_default({
    props: {
      disabled: (
        /*$history*/
        ctx[0].items.length === 0
      ),
      label: lang.controls_history,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*toggleSnapshotsModal*/
    ctx[2]
  );
  button1 = new button_default({
    props: {
      disabled: !/*$history*/
      ctx[0].state.canGoBack,
      label: lang.controls_history_undo,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*selectPreviousSnapshot*/
    ctx[4]
  );
  button2 = new button_default({
    props: {
      disabled: !/*$history*/
      ctx[0].state.canGoForward,
      label: lang.controls_history_redo,
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot61] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*selectNextSnapshot*/
    ctx[3]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      attr(div, "class", "navigation-history buttons-group svelte-5lrsw4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t0);
      mount_component(button1, div, null);
      append(div, t1);
      mount_component(button2, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*$history*/
      1)
        button0_changes.disabled = /*$history*/
        ctx2[0].items.length === 0;
      if (dirty & /*$$scope*/
      128) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$history*/
      1)
        button1_changes.disabled = !/*$history*/
        ctx2[0].state.canGoBack;
      if (dirty & /*$$scope*/
      128) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$history*/
      1)
        button2_changes.disabled = !/*$history*/
        ctx2[0].state.canGoForward;
      if (dirty & /*$$scope*/
      128) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
    }
  };
}
function instance78($$self, $$props, $$invalidate) {
  let $history;
  const view = getView();
  const history = historyStore(view);
  component_subscribe($$self, history, (value) => $$invalidate(0, $history = value));
  const isEditing2 = (view2) => view2.viewStore.getValue().document.editing.activeNodeId;
  const toggleSnapshotsModal = () => view.viewStore.dispatch({ type: "view/snapshots/toggle-modal" });
  const selectNextSnapshot = () => {
    if (isEditing2(view))
      new import_obsidian6.Notice(lang.error_apply_snapshot_while_editing);
    else
      view.documentStore.dispatch({
        type: "document/history/select-next-snapshot"
      });
  };
  const selectPreviousSnapshot = () => {
    if (isEditing2(view))
      new import_obsidian6.Notice(lang.error_apply_snapshot_while_editing);
    else
      view.documentStore.dispatch({
        type: "document/history/select-previous-snapshot"
      });
  };
  return [
    $history,
    history,
    toggleSnapshotsModal,
    selectNextSnapshot,
    selectPreviousSnapshot
  ];
}
var Document_history_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance78, create_fragment80, safe_not_equal, {}, add_css19);
  }
};
var document_history_buttons_default = Document_history_buttons;

// src/view/components/container/toolbar/components/search-actions.svelte
var import_obsidian7 = require("obsidian");

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/get-text-of-flat-nodes.ts
var getTextOfFlatNodes = (view, nodes, copyAsOutline = false) => {
  if (nodes.length === 1)
    copyAsOutline = false;
  const documentState = view.documentStore.getValue();
  const documentContent = documentState.document.content;
  const sortedNodes = sortNodeIdsBySectionNumber(
    documentState.sections,
    nodes
  );
  return sortedNodes.map((id2) => {
    const content = documentContent[id2].content;
    return (copyAsOutline ? "- " : "") + content;
  }).join(copyAsOutline ? "\n" : "\n\n");
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-flat-nodes-to-clipboard.ts
var copyFlatNodesToClipboard = async (view, nodes, copyAsOutline = false) => {
  const text2 = getTextOfFlatNodes(view, nodes, copyAsOutline);
  await navigator.clipboard.writeText(text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-flat-search-results-to-clipboard.ts
var copyFlatSearchResultsToClipboard = async (view) => {
  const results = Array.from(view.viewStore.getValue().search.results.keys());
  await copyFlatNodesToClipboard(view, results, true);
};

// src/lib/tree-utils/get/get-sorted-child-groups.ts
var getSortedChildGroups = (columns, currentParentNode, remove = false) => {
  const childGroupsArray = traverseDown(columns, currentParentNode, false);
  const childGroups = new Set(childGroupsArray);
  const sortedChildGroups = [];
  for (const column of columns) {
    const childGroupsOfColumns = [];
    const groups = [];
    for (const group of column.groups) {
      if (childGroups.has(group.parentId)) {
        childGroupsOfColumns.push(group);
      } else {
        groups.push(group);
      }
    }
    if (remove)
      column.groups = groups;
    if (childGroupsOfColumns.length > 0)
      sortedChildGroups.push(childGroupsOfColumns);
  }
  return sortedChildGroups;
};

// src/lib/tree-utils/delete/delete-node-by-id.ts
var deleteNodeById = (columns, content, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (let i = 0; i < group.nodes.length; i++) {
        const _nodeId2 = group.nodes[i];
        if (_nodeId2 === nodeId) {
          group.nodes.splice(i, 1);
          group.nodes = [...group.nodes];
          if (content)
            delete content[_nodeId2];
          return;
        }
      }
    }
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/get-branch.ts
var getBranch = (columns, content, nodeId, mode) => {
  const cut = mode === "cut";
  const sortedChildGroups = getSortedChildGroups(columns, nodeId, cut);
  const newContent = {};
  for (const sortedChildGroup of sortedChildGroups) {
    for (const group of sortedChildGroup) {
      for (const node of group.nodes) {
        if (node in content) {
          newContent[node] = content[node];
          if (cut)
            delete content[node];
        }
      }
    }
  }
  newContent[nodeId] = content[nodeId];
  const branch = {
    sortedChildGroups,
    content: newContent,
    nodeId,
    mode
  };
  if (cut)
    deleteNodeById(columns, content, nodeId);
  return clone(branch);
};

// src/lib/tree-utils/create/create-column.ts
var createColumn = () => ({
  id: id.column(),
  groups: []
});

// src/lib/tree-utils/create/create-group.ts
var createGroup = (parentId) => ({
  nodes: [],
  parentId
});

// src/lib/data-conversion/x-to-json/branch-to-json.ts
var branchToColumns = (branch) => {
  const columns = [];
  columns.push(createColumn());
  columns[columns.length - 1].groups.push(createGroup("root"));
  columns[columns.length - 1].groups[0].nodes.push(branch.nodeId);
  for (const groups of branch.sortedChildGroups) {
    columns.push(createColumn());
    for (const group of groups) {
      columns[columns.length - 1].groups.push(group);
    }
  }
  return columns;
};
var branchToJson = (branches) => {
  const trees = [];
  for (const branch of branches) {
    const tree = columnsToJson(branchToColumns(branch), branch.content);
    trees.push(tree[0]);
  }
  return trees;
};

// src/lib/data-conversion/branch-to-x/branch-to-outline.ts
var branchToOutline = (branches) => {
  return jsonToOutline(branchToJson(branches));
};

// src/lib/tree-utils/sort/sort-sections-by-depth.ts
var sortSectionsByDepthDesc = (keys) => {
  return keys.sort((a, b) => {
    const aParts = a.split(".");
    const bParts = b.split(".");
    return bParts.length - aParts.length;
  });
};

// src/lib/tree-utils/sort/sort-node-ids-by-depth-desc.ts
var sortNodeIdsByDepthDesc = (sections, ids) => {
  const sectionNumbers = ids.map((id2) => sections.id_section[id2]);
  const sortedSections = sortSectionsByDepthDesc(sectionNumbers);
  return sortedSections.map((section) => sections.section_id[section]);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/get-search-results-from-document.ts
var getSearchResultsFromDocument = (results, document2, sections) => {
  const sortedByDepth = sortNodeIdsByDepthDesc(sections, results);
  const documentClone = clone(document2);
  const branches = sortedByDepth.map(
    (node) => getBranch(documentClone.columns, documentClone.content, node, "cut")
  );
  const branchesMap = new Map(
    branches.map((branch) => [branch.nodeId, branch])
  );
  const rootNodes = Array.from(branchesMap.keys());
  const sortedBranches = sortNodeIdsBySectionNumber(sections, rootNodes).map(
    (id2) => branchesMap.get(id2)
  );
  const isASingleNode = branches.length === 1 && branches[0].sortedChildGroups.length === 0;
  return isASingleNode ? branches[0].content[branches[0].nodeId].content : branchToOutline(sortedBranches);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-search-results-to-clipboard.ts
var copySearchResultsToClipboard = async (view) => {
  const results = Array.from(view.viewStore.getValue().search.results.keys());
  const documentState = view.documentStore.getValue();
  const outline2 = getSearchResultsFromDocument(
    results,
    documentState.document,
    documentState.sections
  );
  await navigator.clipboard.writeText(outline2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/cut-search-results.ts
var cutSearchResults = async (view) => {
  copySearchResultsToClipboard(view);
  const viewState = view.viewStore.getValue();
  const documentState = view.documentStore.getValue();
  const results = Array.from(viewState.search.results.keys());
  if (results.length === 0)
    return;
  const sections = documentState.sections;
  const sortedByDepth = sortNodeIdsByDepthDesc(sections, results);
  const activeNodeIsAMatch = viewState.search.results.has(
    viewState.document.activeNode
  );
  const activeSearchNode = activeNodeIsAMatch ? viewState.document.activeNode : sortNodeIdsBySectionNumber(sections, results)[0];
  view.documentStore.dispatch({
    type: "document/cut-node",
    payload: {
      nodeId: activeSearchNode,
      selectedNodes: new Set(sortedByDepth)
    }
  });
};

// src/view/components/container/toolbar/components/search-actions.svelte
function add_css20(target) {
  append_styles(target, "svelte-17l9x5j", ".search-container.svelte-17l9x5j{display:flex;align-items:center;justify-content:center;gap:var(--size-4-2)}");
}
function create_default_slot62(ctx) {
  let copy;
  let current;
  copy = new copy_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(copy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(copy, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(copy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(copy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(copy, detaching);
    }
  };
}
function create_fragment81(ctx) {
  let div;
  let button;
  let current;
  button = new button_default({
    props: {
      label: "Search actions",
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot62] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*showContextMenu*/
    ctx[0]
  );
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "search-container buttons-group svelte-17l9x5j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      4) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button);
    }
  };
}
function instance79($$self) {
  const view = getView();
  const showContextMenu2 = (e) => {
    const menu = new import_obsidian7.Menu();
    menu.addItem((item) => {
      item.setTitle(lang.toolbar_copy_search_results);
      item.setIcon("copy");
      item.onClick(() => copySearchResultsToClipboard(view));
    });
    menu.addItem((item) => {
      item.setTitle(lang.toolbar_copy_search_results_wo_subitems);
      item.setIcon("copy");
      item.onClick(() => copyFlatSearchResultsToClipboard(view));
    });
    menu.addItem((item) => {
      item.setTitle(lang.toolbar_cut_search_results);
      item.setIcon("scissors");
      item.onClick(() => cutSearchResults(view));
    });
    menu.showAtMouseEvent(e);
  };
  return [showContextMenu2];
}
var Search_actions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance79, create_fragment81, safe_not_equal, {}, add_css20);
  }
};
var search_actions_default = Search_actions;

// src/view/components/container/toolbar/toolbar.svelte
function add_css21(target) {
  append_styles(target, "svelte-scr2c", ".navigation-history-container.svelte-scr2c{z-index:var(--z-index-breadcrumbs);left:var(--size-4-2);top:var(--size-4-2);display:flex;position:absolute;gap:var(--size-4-2);flex-wrap:wrap;max-width:90%}");
}
function create_if_block15(ctx) {
  let searchinput;
  let t;
  let if_block_anchor;
  let current;
  searchinput = new search_input_default({});
  let if_block = (
    /*$search*/
    ctx[0].query.length > 0 && create_if_block_16(ctx)
  );
  return {
    c() {
      create_component(searchinput.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(searchinput, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$search*/
        ctx2[0].query.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$search*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchinput.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(searchinput.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(searchinput, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_16(ctx) {
  let searchnavigationbuttons;
  let t;
  let if_block_anchor;
  let current;
  searchnavigationbuttons = new search_navigation_buttons_default({
    props: {
      results: Array.from(
        /*$search*/
        ctx[0].results.keys()
      )
    }
  });
  let if_block = (
    /*$search*/
    ctx[0].results.size > 0 && create_if_block_24(ctx)
  );
  return {
    c() {
      create_component(searchnavigationbuttons.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(searchnavigationbuttons, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchnavigationbuttons_changes = {};
      if (dirty & /*$search*/
      1)
        searchnavigationbuttons_changes.results = Array.from(
          /*$search*/
          ctx2[0].results.keys()
        );
      searchnavigationbuttons.$set(searchnavigationbuttons_changes);
      if (
        /*$search*/
        ctx2[0].results.size > 0
      ) {
        if (if_block) {
          if (dirty & /*$search*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchnavigationbuttons.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(searchnavigationbuttons.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(searchnavigationbuttons, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_24(ctx) {
  let searchactions;
  let current;
  searchactions = new search_actions_default({});
  return {
    c() {
      create_component(searchactions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchactions, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(searchactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchactions, detaching);
    }
  };
}
function create_fragment82(ctx) {
  let div;
  let leftsidebartoggle;
  let t0;
  let navigationhistory;
  let t1;
  let documenthistorybuttons;
  let t2;
  let searchtoggle;
  let t3;
  let current;
  leftsidebartoggle = new left_sidebar_toggle_default({});
  navigationhistory = new navigation_buttons_default({});
  documenthistorybuttons = new document_history_buttons_default({});
  searchtoggle = new search_toggle_default({});
  let if_block = (
    /*$search*/
    ctx[0].showInput && create_if_block15(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(leftsidebartoggle.$$.fragment);
      t0 = space();
      create_component(navigationhistory.$$.fragment);
      t1 = space();
      create_component(documenthistorybuttons.$$.fragment);
      t2 = space();
      create_component(searchtoggle.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "navigation-history-container svelte-scr2c");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(leftsidebartoggle, div, null);
      append(div, t0);
      mount_component(navigationhistory, div, null);
      append(div, t1);
      mount_component(documenthistorybuttons, div, null);
      append(div, t2);
      mount_component(searchtoggle, div, null);
      append(div, t3);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$search*/
        ctx2[0].showInput
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$search*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leftsidebartoggle.$$.fragment, local);
      transition_in(navigationhistory.$$.fragment, local);
      transition_in(documenthistorybuttons.$$.fragment, local);
      transition_in(searchtoggle.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(leftsidebartoggle.$$.fragment, local);
      transition_out(navigationhistory.$$.fragment, local);
      transition_out(documenthistorybuttons.$$.fragment, local);
      transition_out(searchtoggle.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(leftsidebartoggle);
      destroy_component(navigationhistory);
      destroy_component(documenthistorybuttons);
      destroy_component(searchtoggle);
      if (if_block)
        if_block.d();
    }
  };
}
function instance80($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  return [$search, search2];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance80, create_fragment82, safe_not_equal, {}, add_css21);
  }
};
var toolbar_default = Toolbar;

// src/view/actions/settings/components/shared/range-setting.ts
var import_obsidian8 = require("obsidian");
var RangeSetting = (element2, settingsStore, props) => {
  let input;
  let resetButton;
  const updateExtraButton = (currentValue) => {
    if (currentValue === props.defaultValue) {
      resetButton.setDisabled(true);
    } else {
      resetButton.setDisabled(false);
    }
  };
  const setValue = () => {
    const settingsState = settingsStore.getValue();
    const currentValue = props.valueSelector(settingsState) ?? props.defaultValue;
    input.setValue(currentValue);
    updateExtraButton(currentValue);
  };
  const setting = new import_obsidian8.Setting(element2);
  setting.setName(props.label);
  if (props.desc) {
    setting.setDesc(props.desc);
  }
  setting.addSlider((cb) => {
    input = cb;
    cb.setLimits(props.min, props.max, props.step);
    cb.onChange((value) => {
      props.onChange(value);
      updateExtraButton(value);
    }).setDynamicTooltip();
  }).addExtraButton((cb) => {
    resetButton = cb;
    cb.setIcon("reset").onClick(() => {
      props.onChange(props.defaultValue);
      setValue();
    }).setTooltip(lang.settings_reset);
  });
  setValue();
};

// src/view/actions/settings/components/font-size.ts
var FontSize = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: 16,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-font-size",
        payload: {
          fontSize: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.fontSize,
    label: lang.settings_appearance_font_size,
    max: 36,
    min: 6,
    step: 1
  });
};

// src/obsidian/helpers/get-theme.ts
var getTheme = () => {
  if (document.body.hasClass("theme-light"))
    return "light";
  else if (document.body.hasClass("theme-dark"))
    return "dark";
  throw new Error("could not detect theme");
};

// src/stores/view/subscriptions/effects/css-variables/helpers/get-default-theme.ts
var getDefaultTheme = () => {
  const textNormal = getComputedStyle(activeDocument.body).getPropertyValue(
    "--text-normal"
  );
  const darkTheme = {
    containerBg: "#373d4c",
    activeBranchBg: "#5b637a",
    activeBranchColor: textNormal
  };
  const lightTheme = {
    containerBg: "#899cb3",
    activeBranchBg: "#cedbeb",
    activeBranchColor: textNormal
  };
  const theme = getTheme();
  return theme === "light" ? lightTheme : darkTheme;
};

// src/view/actions/settings/components/shared/color-setting.ts
var import_obsidian9 = require("obsidian");
var ColorSetting = (container, settingsStore, props) => {
  let input;
  let resetButton;
  const updateExtraButton = (currentValue) => {
    if (currentValue === props.defaultValue) {
      resetButton.setDisabled(true);
    } else {
      resetButton.setDisabled(false);
    }
  };
  const setValue = () => {
    const settingsState = settingsStore.getValue();
    const currentValue = props.valueSelector(settingsState) || props.defaultValue;
    input.onChange(() => void 0);
    input.setValue(currentValue);
    input.onChange((value) => {
      props.onChange(value);
      updateExtraButton(value);
    });
    updateExtraButton(currentValue);
  };
  new import_obsidian9.Setting(container).setName(props.label).addColorPicker((cb) => {
    input = cb;
  }).addExtraButton((cb) => {
    resetButton = cb;
    resetButton.setIcon("reset").onClick(() => {
      props.onChange(void 0);
      setValue();
    }).setTooltip(lang.settings_reset);
  });
  setValue();
};

// src/view/actions/settings/components/background-color.ts
var BackgroundColor = (container, settingsStore) => {
  ColorSetting(container, settingsStore, {
    defaultValue: getDefaultTheme().containerBg,
    label: lang.settings_theme_bg,
    valueSelector: (settings) => settings.view.theme.containerBg,
    onChange: (color) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-container-bg-color",
        payload: {
          backgroundColor: color
        }
      });
    }
  });
};

// src/view/actions/settings/components/active-branch-background.ts
var ActiveBranchBackground = (container, settingsStore) => {
  ColorSetting(container, settingsStore, {
    defaultValue: getDefaultTheme().activeBranchBg,
    label: lang.settings_theme_active_branch_bg,
    valueSelector: (settings) => settings.view.theme.activeBranchBg,
    onChange: (color) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-active-branch-bg-color",
        payload: {
          backgroundColor: color
        }
      });
    }
  });
};

// src/stores/settings/default-settings.ts
var DEFAULT_CARD_WIDTH = 550;
var DEFAULT_CARDS_GAP = 50;
var DEFAULT_INDENTATION_WIDTH = 60;
var DEFAULT_INACTIVE_NODE_OPACITY = 25;
var DEFAULT_H1_FONT_SIZE_EM = 1.802;
var DEFAULT_SETTINGS = () => ({
  documents: {},
  hotkeys: {
    customHotkeys: {}
  },
  view: {
    fontSize: 16,
    h1FontSize_em: DEFAULT_H1_FONT_SIZE_EM,
    theme: {
      inactiveNodeOpacity: DEFAULT_INACTIVE_NODE_OPACITY
    },
    cardWidth: DEFAULT_CARD_WIDTH,
    cardsGap: DEFAULT_CARDS_GAP,
    scrolling: {
      centerActiveNodeH: false,
      centerActiveNodeV: true
    },
    limitPreviewHeight: true,
    zoomLevel: 1,
    showMinimap: false,
    showLeftSidebar: false,
    leftSidebarWidth: 500,
    leftSidebarActiveTab: "pinned-cards",
    applyGapBetweenCards: false,
    outlineMode: false,
    nodeIndentationWidth: DEFAULT_INDENTATION_WIDTH,
    maintainEditMode: false,
    alwaysShowCardButtons: false,
    hiddenVerticalToolbarButtons: []
  },
  general: {
    defaultDocumentFormat: "sections",
    linkPaneType: "tab"
  },
  styleRules: {
    documents: {},
    global: {
      rules: []
    },
    settings: {
      activeTab: "global-rules"
    }
  }
});

// src/view/actions/settings/components/card-width.ts
var CardWidth = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: DEFAULT_CARD_WIDTH,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/layout/set-card-width",
        payload: {
          width: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.cardWidth,
    label: lang.settings_layout_card_width,
    max: 1e3,
    min: 200,
    step: 10
  });
};

// src/view/actions/settings/components/limit-card-height.ts
var import_obsidian10 = require("obsidian");
var LimitCardHeight = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  new import_obsidian10.Setting(element2).setName(lang.settings_layout_limit_card_height).addToggle((cb) => {
    cb.setValue(settingsState.view.limitPreviewHeight).onChange(
      (limit) => {
        settingsStore.dispatch({
          type: "settings/view/layout/set-limit-card-height",
          payload: {
            limit
          }
        });
      }
    );
  });
};

// src/view/actions/settings/components/default-document-format.ts
var import_obsidian11 = require("obsidian");
var DefaultDocumentFormat = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  const setting = new import_obsidian11.Setting(element2).setName(
    lang.settings_general_default_format
  );
  setting.addDropdown((cb) => {
    const value = settingsState.general.defaultDocumentFormat;
    cb.addOptions({
      "html-element": lang.settings_format_html_elements,
      sections: lang.settings_format_html_comments,
      outline: lang.settings_format_outline
    }).setValue(value).onChange((value2) => {
      settingsStore.dispatch({
        type: "settings/general/set-default-document-format",
        payload: {
          format: value2
        }
      });
    });
  });
};

// src/view/actions/settings/components/cards-gap.ts
var CardsGap = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: DEFAULT_CARDS_GAP,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/layout/set-cards-gap",
        payload: {
          gap: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.cardsGap,
    label: lang.settings_layout_space_between_cards,
    max: 500,
    min: 0,
    step: 10
  });
};

// src/view/actions/settings/components/card-indentation-width.ts
var CardIndentationWidth = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: DEFAULT_INDENTATION_WIDTH,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/set-node-indentation-width",
        payload: {
          width: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.nodeIndentationWidth,
    label: lang.settings_layout_indentation_width,
    max: 1e3,
    min: 0,
    step: 5
  });
};

// src/view/actions/settings/components/maintain-edit-mode.ts
var import_obsidian12 = require("obsidian");
var MaintainEditMode2 = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  new import_obsidian12.Setting(element2).setName(lang.settings_general_maintain_edit_mode).setDesc(lang.settings_general_maintain_edit_mode_desc).addToggle((cb) => {
    cb.setValue(settingsState.view.maintainEditMode).onChange(
      (maintain) => {
        settingsStore.dispatch({
          type: "settings/view/set-maintain-edit-mode",
          payload: {
            maintain
          }
        });
      }
    );
  });
};

// src/view/actions/settings/components/inactive-card-opacity.ts
var InactiveCardOpacity = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: DEFAULT_INACTIVE_NODE_OPACITY,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-inactive-node-opacity",
        payload: {
          opacity: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.theme.inactiveNodeOpacity,
    label: lang.settings_appearance_inactive_node_opacity,
    max: 100,
    min: 0,
    step: 5
  });
};

// src/view/actions/settings/components/active-branch-color.ts
var ActiveBranchColor = (container, settingsStore) => {
  ColorSetting(container, settingsStore, {
    defaultValue: getDefaultTheme().activeBranchColor,
    label: lang.settings_theme_active_branch_color,
    valueSelector: (settings) => settings.view.theme.activeBranchColor,
    onChange: (color) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-active-branch-color",
        payload: {
          color
        }
      });
    }
  });
};

// src/view/actions/settings/components/always-show-card-buttons.ts
var import_obsidian13 = require("obsidian");
var AlwaysShowCardButtons2 = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  new import_obsidian13.Setting(element2).setName(lang.settings_always_show_card_buttons).setDesc(lang.settings_always_show_card_buttons_desc).addToggle((cb) => {
    cb.setValue(settingsState.view.alwaysShowCardButtons).onChange(
      (show) => {
        settingsStore.dispatch({
          type: "settings/view/set-always-show-card-buttons",
          payload: {
            show
          }
        });
      }
    );
  });
};

// src/view/actions/settings/components/controls-bar-buttons/controls-bar-buttons.ts
var import_obsidian15 = require("obsidian");

// src/view/modals/vertical-toolbar-buttons/vertical-toolbar-buttons-modal.ts
var import_obsidian14 = require("obsidian");

// src/view/modals/vertical-toolbar-buttons/vertical-toolbar-buttons.ts
var verticalToolbarButtons = [
  {
    id: "settings",
    buttons: [
      {
        id: "hotkeys",
        label: lang.controls_hotkeys,
        icon: keyboard_default
      },
      {
        id: "style-rules",
        label: lang.controls_rules,
        icon: palette_default
      }
    ]
  },
  {
    id: "scroll",
    buttons: [
      {
        id: "center-active-node-h",
        label: lang.controls_toggle_scrolling_mode_horizontal,
        icon: customIcons.alignH
      },
      {
        id: "center-active-node-v",
        label: lang.controls_toggle_scrolling_mode_vertical,
        icon: customIcons.alignV
      }
    ]
  },
  {
    id: "display",
    buttons: [
      {
        id: "outline-mode",
        label: lang.controls_single_column,
        icon: customIcons.outline
      },
      {
        id: "space-between-cards",
        label: lang.controls_gap_between_cards,
        icon: customIcons.gap
      }
    ]
  },
  {
    id: "zoom",
    buttons: [
      {
        id: "zoom-in",
        label: lang.controls_zoom_in,
        icon: plus_default
      },
      {
        id: "zoom-reset",
        label: lang.controls_zoom_reset,
        icon: rotate_ccw_default
      },
      {
        id: "zoom-presets",
        label: lang.controls_zoom_presets,
        icon: scan_search_default
      },
      {
        id: "zoom-out",
        label: lang.controls_zoom_out,
        icon: minus_default
      }
    ]
  }
];

// src/view/modals/vertical-toolbar-buttons/components/vertical-toolbar-icons-selection-modal.svelte
function add_css22(target) {
  append_styles(target, "svelte-1nwvm61", ".buttons-list.svelte-1nwvm61{display:flex;flex-direction:column;& button {\n            background-color: transparent;\n            cursor: initial;\n        }}.button-list-item.svelte-1nwvm61{display:flex;gap:5px;align-items:center;border-top:1px solid var(--background-modifier-border);padding:6px 14px}.button-list-item.svelte-1nwvm61:first-child{border-top:none}.toolbar-icon-label.svelte-1nwvm61{color:var(--text-normal)}");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_else_block7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*button*/
    ctx[9].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      2 && switch_value !== (switch_value = /*button*/
      ctx2[9].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block16(ctx) {
  let html_tag;
  let raw_value = (
    /*button*/
    ctx[9].icon.svg + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$buttons*/
      2 && raw_value !== (raw_value = /*button*/
      ctx2[9].icon.svg + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_default_slot63(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block16, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if ("svg" in /*button*/
    ctx2[9].icon)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_12(key_1, ctx) {
  let div;
  let input;
  let input_checked_value;
  let t0;
  let button_1;
  let t1;
  let span;
  let t2_value = (
    /*button*/
    ctx[9].label + ""
  );
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[5](
        /*button*/
        ctx[9],
        ...args
      )
    );
  }
  button_1 = new button_default({
    props: {
      classes: "control-item",
      label: (
        /*button*/
        ctx[9].label
      ),
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot63] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      create_component(button_1.$$.fragment);
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = !/*button*/
      ctx[9].hidden;
      attr(span, "class", "toolbar-icon-label svelte-1nwvm61");
      attr(div, "class", "button-list-item svelte-1nwvm61");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      append(div, t0);
      mount_component(button_1, div, null);
      append(div, t1);
      append(div, span);
      append(span, t2);
      append(div, t3);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*$buttons*/
      2 && input_checked_value !== (input_checked_value = !/*button*/
      ctx[9].hidden)) {
        input.checked = input_checked_value;
      }
      const button_1_changes = {};
      if (dirty & /*$buttons*/
      2)
        button_1_changes.label = /*button*/
        ctx[9].label;
      if (dirty & /*$$scope, $buttons*/
      4098) {
        button_1_changes.$$scope = { dirty, ctx };
      }
      button_1.$set(button_1_changes);
      if ((!current || dirty & /*$buttons*/
      2) && t2_value !== (t2_value = /*button*/
      ctx[9].label + ""))
        set_data(t2, t2_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(button_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button_1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block8(key_1, ctx) {
  let first;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*group*/
    ctx[6].buttons
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[9].label
  );
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttons, onChange*/
      10) {
        each_value_1 = ensure_array_like(
          /*group*/
          ctx[6].buttons
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_12, each_1_anchor, get_each_context_12);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_fragment83(ctx) {
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div1;
  let button_1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$buttons*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[6].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block8(key, child_ctx));
  }
  return {
    c() {
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      button_1 = element("button");
      button_1.textContent = "Done";
      attr(div0, "class", "buttons-list svelte-1nwvm61");
      attr(button_1, "class", "mod-cta");
      attr(div1, "class", "modal-button-container");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, button_1);
      current = true;
      if (!mounted) {
        dispose = listen(button_1, "click", function() {
          if (is_function(
            /*close*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*$buttons, onChange*/
      10) {
        each_value = ensure_array_like(
          /*$buttons*/
          ctx[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block8, null, get_each_context8);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance81($$self, $$props, $$invalidate) {
  let $buttons;
  let { close } = $$props;
  let { plugin } = $$props;
  const buttons = derived([HiddenVerticalToolbarButtons(plugin)], ([hidden]) => {
    const set = new Set(hidden);
    if (set.size > 0) {
      return verticalToolbarButtons.map((bs) => ({
        id: bs.id,
        buttons: bs.buttons.map((b) => Object.assign(Object.assign({}, b), { hidden: set.has(b.id) }))
      }));
    } else
      return verticalToolbarButtons;
  });
  component_subscribe($$self, buttons, (value) => $$invalidate(1, $buttons = value));
  const onChange = (button, hidden) => {
    plugin.settings.dispatch({
      type: "settings/view/vertical-toolbar/set-hidden-button",
      payload: { id: button, hide: hidden }
    });
  };
  const change_handler = (button, e) => {
    onChange(button.id, !e.currentTarget.checked);
  };
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close = $$props2.close);
    if ("plugin" in $$props2)
      $$invalidate(4, plugin = $$props2.plugin);
  };
  return [close, $buttons, buttons, onChange, plugin, change_handler];
}
var Vertical_toolbar_icons_selection_modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance81, create_fragment83, safe_not_equal, { close: 0, plugin: 4 }, add_css22);
  }
};
var vertical_toolbar_icons_selection_modal_default = Vertical_toolbar_icons_selection_modal;

// src/view/modals/vertical-toolbar-buttons/vertical-toolbar-buttons-modal.ts
var VerticalToolbarButtonsModal = class extends import_obsidian14.Modal {
  constructor(props) {
    super(props.plugin.app);
    this.props = props;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.open = () => {
      this.setTitle(lang.settings_vertical_toolbar_icons_desc);
      this.initState();
      new vertical_toolbar_icons_selection_modal_default({
        target: this.contentEl,
        props: {
          plugin: this.props.plugin,
          close: this.close
        }
      });
      const promise = new Promise((resolve) => {
        this.resolve = resolve;
      });
      super.open();
      return promise;
    };
    this.close = () => {
      this.resolve(void 0);
      super.close();
      for (const unsub of this.subscriptions) {
        unsub();
      }
    };
    this.initState = () => {
    };
  }
};

// src/view/actions/settings/components/controls-bar-buttons/controls-bar-buttons.ts
var ControlsBarButtons = (container, view) => {
  new import_obsidian15.Setting(container).setName(lang.settings_vertical_toolbar_icons).setDesc(lang.settings_vertical_toolbar_icons_desc).addButton((cb) => {
    cb.setButtonText("Manage");
    cb.onClick(() => {
      const modal = new VerticalToolbarButtonsModal({
        plugin: view.plugin
      });
      modal.open();
    });
  });
};

// src/view/actions/settings/components/headings-font-size.ts
var HeadingsFontSize = (element2, settingsStore) => {
  RangeSetting(element2, settingsStore, {
    defaultValue: DEFAULT_H1_FONT_SIZE_EM,
    onChange: (value) => {
      settingsStore.dispatch({
        type: "settings/view/theme/set-h1-font-size",
        payload: {
          fontSize_em: value
        }
      });
    },
    valueSelector: (settingsState) => settingsState.view.h1FontSize_em,
    label: lang.settings_appearance_headings_font_size,
    max: 4,
    min: 1,
    step: 0.1
  });
};

// src/view/actions/settings/components/link-pane-type.ts
var import_obsidian16 = require("obsidian");
var LinkPaneType = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  const setting = new import_obsidian16.Setting(element2).setName(
    lang.settings_general_link_behavior
  );
  setting.setDesc(
    `Hold '${isMacLike ? "cmd" : "control"}' to use the other option`
  );
  setting.addDropdown((cb) => {
    const value = settingsState.general.linkPaneType;
    cb.addOptions({
      split: lang.settings_general_link_split,
      tab: lang.settings_general_link_tab
    }).setValue(value).onChange((value2) => {
      settingsStore.dispatch({
        type: "settings/general/set-link-pane-type",
        payload: {
          position: value2
        }
      });
    });
  });
};

// src/view/actions/settings/render-settings.ts
var setVisibleTab = (tabs, activeTab) => {
  for (const tab of tabs) {
    if (tab.name === activeTab) {
      tab.element.style.visibility = "visible";
    } else {
      tab.element.style.visibility = "hidden";
    }
  }
};
var render = (view, element2, tabs) => {
  const settingsStore = view.plugin.settings;
  const generalTab = activeDocument.createElement("div");
  const appearanceTab = activeDocument.createElement("div");
  const layoutTab = activeDocument.createElement("div");
  tabs.push({ element: generalTab, name: "General" });
  tabs.push({ element: appearanceTab, name: "Appearance" });
  tabs.push({ element: layoutTab, name: "Layout" });
  DefaultDocumentFormat(generalTab, settingsStore);
  LinkPaneType(generalTab, settingsStore);
  MaintainEditMode2(generalTab, settingsStore);
  AlwaysShowCardButtons2(generalTab, settingsStore);
  ControlsBarButtons(generalTab, view);
  BackgroundColor(appearanceTab, settingsStore);
  ActiveBranchBackground(appearanceTab, settingsStore);
  ActiveBranchColor(appearanceTab, settingsStore);
  InactiveCardOpacity(appearanceTab, settingsStore);
  FontSize(appearanceTab, settingsStore);
  HeadingsFontSize(appearanceTab, settingsStore);
  CardWidth(layoutTab, settingsStore);
  CardsGap(layoutTab, settingsStore);
  CardIndentationWidth(layoutTab, settingsStore);
  LimitCardHeight(layoutTab, settingsStore);
  element2.append(generalTab, appearanceTab, layoutTab);
};
var renderSettings = (element2, tab) => {
  const tabs = [];
  const view = getView();
  render(view, element2, tabs);
  setVisibleTab(tabs, tab);
  return {
    update: (tab2) => {
      setVisibleTab(tabs, tab2);
    }
  };
};

// src/view/components/container/modals/settings/vertical-tab-header.svelte
function add_css23(target) {
  append_styles(target, "svelte-1m3tx9d", ".lineage-vertical-tab-header.svelte-1m3tx9d{width:250px;padding:var(--size-4-3);background-color:var(--background-secondary)}");
}
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block9(ctx) {
  let div;
  let t0_value = (
    /*tab*/
    ctx[4] + ""
  );
  let t0;
  let t1;
  let div_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[3](
        /*tab*/
        ctx[4]
      )
    );
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", div_class_value = null_to_empty("vertical-tab-nav-item" + /*tab*/
      (ctx[4] === /*activeTab*/
      ctx[1] ? " is-active" : "")) + " svelte-1m3tx9d");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*activeTab*/
      2 && div_class_value !== (div_class_value = null_to_empty("vertical-tab-nav-item" + /*tab*/
      (ctx[4] === /*activeTab*/
      ctx[1] ? " is-active" : "")) + " svelte-1m3tx9d")) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment84(ctx) {
  let div2;
  let div1;
  let div0;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "vertical-tab-header-group-items");
      attr(div1, "class", "vertical-tab-header-group");
      attr(div2, "class", "lineage-vertical-tab-header svelte-1m3tx9d");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabs, activeTab, setActiveTab*/
      7) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance82($$self, $$props, $$invalidate) {
  let { setActiveTab } = $$props;
  let { activeTab } = $$props;
  const tabs = ["General", "Appearance", "Layout"];
  const click_handler = (tab) => setActiveTab(tab);
  $$self.$$set = ($$props2) => {
    if ("setActiveTab" in $$props2)
      $$invalidate(0, setActiveTab = $$props2.setActiveTab);
    if ("activeTab" in $$props2)
      $$invalidate(1, activeTab = $$props2.activeTab);
  };
  return [setActiveTab, activeTab, tabs, click_handler];
}
var Vertical_tab_header = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance82, create_fragment84, safe_not_equal, { setActiveTab: 0, activeTab: 1 }, add_css23);
  }
};
var vertical_tab_header_default = Vertical_tab_header;

// src/view/components/container/modals/settings/active-settings-tab-store.ts
var ActiveSettingsTabStore = writable("General");

// src/view/components/container/modals/settings/settings.svelte
function add_css24(target) {
  append_styles(target, "svelte-rqy3yr", ".lineage-vertical-tabs-container.svelte-rqy3yr{display:flex}.lineage-vertical-tab-content.svelte-rqy3yr{height:auto;display:grid;flex-direction:column;width:500px;overflow-y:auto;padding-top:var(--size-4-8);padding-bottom:var(--size-4-12);padding-inline-start:var(--size-4-12);padding-inline-end:var(--size-4-12);grid-template-areas:'main';& > div {\n            grid-area: main;\n        }}");
}
function create_fragment85(ctx) {
  let div2;
  let div1;
  let verticaltabheader;
  let t;
  let div0;
  let renderSettings_action;
  let current;
  let mounted;
  let dispose;
  verticaltabheader = new vertical_tab_header_default({
    props: {
      setActiveTab: (
        /*setActiveTab*/
        ctx[1]
      ),
      activeTab: (
        /*$ActiveSettingsTabStore*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      create_component(verticaltabheader.$$.fragment);
      t = space();
      div0 = element("div");
      attr(div0, "class", "lineage-vertical-tab-content svelte-rqy3yr");
      attr(div1, "class", "lineage-vertical-tabs-container svelte-rqy3yr");
      attr(div2, "class", "lineage-modal");
      attr(div2, "id", "lineage-view-settings");
      attr(div2, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      mount_component(verticaltabheader, div1, null);
      append(div1, t);
      append(div1, div0);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(renderSettings_action = renderSettings.call(
          null,
          div0,
          /*$ActiveSettingsTabStore*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const verticaltabheader_changes = {};
      if (dirty & /*$ActiveSettingsTabStore*/
      1)
        verticaltabheader_changes.activeTab = /*$ActiveSettingsTabStore*/
        ctx2[0];
      verticaltabheader.$set(verticaltabheader_changes);
      if (renderSettings_action && is_function(renderSettings_action.update) && dirty & /*$ActiveSettingsTabStore*/
      1)
        renderSettings_action.update.call(
          null,
          /*$ActiveSettingsTabStore*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(verticaltabheader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(verticaltabheader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(verticaltabheader);
      mounted = false;
      dispose();
    }
  };
}
function instance83($$self, $$props, $$invalidate) {
  let $ActiveSettingsTabStore;
  component_subscribe($$self, ActiveSettingsTabStore, ($$value) => $$invalidate(0, $ActiveSettingsTabStore = $$value));
  const setActiveTab = (tab) => {
    ActiveSettingsTabStore.set(tab);
  };
  return [$ActiveSettingsTabStore, setActiveTab];
}
var Settings2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance83, create_fragment85, safe_not_equal, {}, add_css24);
  }
};
var settings_default2 = Settings2;

// src/helpers/relative-time.ts
var rtf1 = new Intl.RelativeTimeFormat("en", { style: "long" });
var relativeTime = (updated) => {
  const difference = Date.now() - updated;
  const days = Math.floor(difference / (1e3 * 60 * 60 * 24));
  const hours = Math.floor(difference / (1e3 * 60 * 60));
  const minutes = Math.floor(difference / (1e3 * 60));
  let relativeTime2;
  if (days > 0) {
    relativeTime2 = rtf1.format(-days, "day");
  } else if (hours > 0) {
    relativeTime2 = rtf1.format(-hours, "hour");
  } else if (minutes > 0) {
    relativeTime2 = rtf1.format(-minutes, "minute");
  } else {
    relativeTime2 = "Just now";
  }
  return relativeTime2;
};

// src/lang/snapshot-action-lang.ts
var snapshotActionLang = {
  "document/update-node-content": (snapshot) => ({
    label: lang.modals_snapshots_updated_node + snapshot.context.affectedSection,
    icon: file_pen_default
  }),
  "document/add-node": (snapshot) => ({
    label: lang.modals_snapshots_created_node + snapshot.context.affectedSection,
    icon: file_plus_default
  }),
  "document/drop-node": (snapshot) => ({
    label: lang.modals_snapshots_dropped_node + snapshot.context.affectedSection,
    icon: file_output_default
  }),
  "document/file/load-from-disk": () => ({
    label: lang.modals_snapshots_document_loaded,
    icon: file_up_default
  }),
  "document/delete-node": (snapshot) => ({
    label: lang.modals_snapshots_deleted_section + snapshot.context.affectedSection,
    icon: file_minus_default
  }),
  "document/move-node": (snapshot) => ({
    label: lang.modals_snapshots_moved_node + snapshot.context.affectedSection,
    icon: file_output_default
  }),
  "document/merge-node": (snapshot) => ({
    label: lang.modals_snapshots_merged_node + snapshot.context.affectedSection,
    icon: merge_default
  }),
  "document/format-headings": () => ({
    label: lang.modals_snapshots_formatted_headings,
    icon: heading_1_default
  }),
  "document/cut-node": (snapshot) => ({
    label: lang.modals_snapshots_cut_section + snapshot.context.affectedSection,
    icon: scissors_default
  }),
  "document/paste-node": (snapshot) => ({
    label: lang.modals_snapshots_pasted_section + snapshot.context.affectedSection,
    icon: clipboard_paste_default
  }),
  "document/extract-node": (snapshot) => ({
    label: lang.modals_snapshots_extracted_node + snapshot.context.affectedSection,
    icon: file_symlink_default,
    iconHtml: customIcons.cards.svg
  }),
  "document/split-node": (snapshot) => ({
    label: lang.modals_snapshots_split_node + snapshot.context.affectedSection,
    icon: split_default
  }),
  "document/sort-direct-child-nodes": (snapshot) => {
    const action = snapshot.context.action;
    return {
      label: lang.modals_snapshots_sorted_child_nodes + snapshot.context.affectedSection,
      icon: action.payload.order === "descending" ? arrow_down_wide_narrow_default : arrow_up_narrow_wide_default
    };
  }
};

// src/view/components/container/modals/snapshots-list/components/snapshot-button.svelte
var import_obsidian17 = require("obsidian");
function add_css25(target) {
  append_styles(target, "svelte-8u3rmg", ":root{--icon-wrapper-width:32px}.snapshot.svelte-8u3rmg{padding:var(--size-4-2);cursor:pointer;display:flex;align-items:center;border-radius:4px;gap:4px;height:66px;flex:1;background-color:var(--background-secondary)}.selected.svelte-8u3rmg{background-color:var(--nav-item-background-selected)}.icon-wrapper.svelte-8u3rmg{width:32px;display:flex;align-items:center;justify-content:center}.snapshot-content.svelte-8u3rmg{display:flex;flex-direction:column;gap:5px;flex:1}.snapshot-body.svelte-8u3rmg{display:flex;justify-content:space-between;gap:5px;width:100%}.snapshot-label.svelte-8u3rmg{font-size:14px;color:var(--color-base-70);display:block;flex:1;max-width:210px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.snapshot-card-content.svelte-8u3rmg{font-size:14px;color:var(--color-base-60);display:block;white-space:nowrap;overflow:hidden;max-width:200px;text-overflow:ellipsis;font-style:italic;opacity:0.9}@media(max-width: 720px){.snapshot-card-content.svelte-8u3rmg{max-width:30vw}}.snapshot-context.svelte-8u3rmg{display:flex;flex-direction:column;align-items:end;height:100%;justify-content:space-between}.snapshot-section-number.svelte-8u3rmg{font-size:11px;color:var(--color-base-60);min-width:16px;text-align:left;margin-left:auto}.snapshot-time.svelte-8u3rmg{font-size:11px;color:var(--color-base-60)}");
}
function create_else_block8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*info*/
    ctx[4].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon label" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = /*info*/
      ctx2[4].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block17(ctx) {
  let html_tag;
  let raw_value = (
    /*info*/
    ctx[4].iconHtml + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_fragment86(ctx) {
  let div6;
  let div0;
  let current_block_type_index;
  let if_block;
  let t0;
  let div4;
  let div2;
  let div1;
  let t2;
  let div3;
  let t3_value = (
    /*snapshot*/
    ctx[0].context.contentOfAffectedSection + ""
  );
  let t3;
  let t4;
  let div5;
  let span0;
  let t6;
  let span1;
  let t8;
  let span2;
  let t9_value = relativeTime(
    /*snapshot*/
    ctx[0].created
  ) + "";
  let t9;
  let span2_data_created_value;
  let div6_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block17, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if ("iconHtml" in /*info*/
    ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      if_block.c();
      t0 = space();
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      div1.textContent = `${/*info*/
      ctx[4].label}`;
      t2 = space();
      div3 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div5 = element("div");
      span0 = element("span");
      span0.textContent = `${/*sections*/
      ctx[5]}`;
      t6 = space();
      span1 = element("span");
      span1.textContent = `${/*chars*/
      ctx[6]}`;
      t8 = space();
      span2 = element("span");
      t9 = text(t9_value);
      attr(div0, "class", "icon-wrapper svelte-8u3rmg");
      attr(div1, "class", "snapshot-label svelte-8u3rmg");
      attr(div2, "class", "snapshot-body svelte-8u3rmg");
      attr(div3, "class", "snapshot-card-content svelte-8u3rmg");
      attr(div4, "class", "snapshot-content svelte-8u3rmg");
      attr(span0, "class", "snapshot-section-number svelte-8u3rmg");
      attr(span1, "class", "snapshot-section-number svelte-8u3rmg");
      attr(span2, "class", "snapshot-time svelte-8u3rmg");
      attr(span2, "data-created", span2_data_created_value = /*snapshot*/
      ctx[0].created);
      attr(div5, "class", "snapshot-context svelte-8u3rmg");
      attr(div6, "aria-label", div6_aria_label_value = /*snapshot*/
      ctx[0].context.contentOfAffectedSection);
      attr(div6, "class", "snapshot svelte-8u3rmg");
      toggle_class(
        div6,
        "selected",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div6, t0);
      append(div6, div4);
      append(div4, div2);
      append(div2, div1);
      append(div4, t2);
      append(div4, div3);
      append(div3, t3);
      append(div6, t4);
      append(div6, div5);
      append(div5, span0);
      append(div5, t6);
      append(div5, span1);
      append(div5, t8);
      append(div5, span2);
      append(span2, t9);
      current = true;
      if (!mounted) {
        dispose = listen(
          div6,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
      if ((!current || dirty & /*snapshot*/
      1) && t3_value !== (t3_value = /*snapshot*/
      ctx2[0].context.contentOfAffectedSection + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & /*snapshot*/
      1) && t9_value !== (t9_value = relativeTime(
        /*snapshot*/
        ctx2[0].created
      ) + ""))
        set_data(t9, t9_value);
      if (!current || dirty & /*snapshot*/
      1 && span2_data_created_value !== (span2_data_created_value = /*snapshot*/
      ctx2[0].created)) {
        attr(span2, "data-created", span2_data_created_value);
      }
      if (!current || dirty & /*snapshot*/
      1 && div6_aria_label_value !== (div6_aria_label_value = /*snapshot*/
      ctx2[0].context.contentOfAffectedSection)) {
        attr(div6, "aria-label", div6_aria_label_value);
      }
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          div6,
          "selected",
          /*active*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance84($$self, $$props, $$invalidate) {
  let { snapshot } = $$props;
  let { active } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const infoFactory = snapshotActionLang[snapshot.context.action.type];
  invariant(infoFactory);
  const info = infoFactory(snapshot);
  const numberOfCharacters = snapshot.context.numberOfCharacters;
  const numberOfSections = snapshot.context.numberOfSections;
  const sections = `${numberOfSections} section${numberOfSections === 1 ? "" : "s"}`;
  const chars = `${numberOfCharacters} char${numberOfCharacters === 1 ? "" : "s"}`;
  const click_handler = () => {
    if (viewStore.getValue().document.editing.activeNodeId)
      new import_obsidian17.Notice(lang.error_apply_snapshot_while_editing);
    else
      documentStore.dispatch({
        type: "document/history/select-snapshot",
        payload: { snapshotId: snapshot.id }
      });
  };
  $$self.$$set = ($$props2) => {
    if ("snapshot" in $$props2)
      $$invalidate(0, snapshot = $$props2.snapshot);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [
    snapshot,
    active,
    documentStore,
    viewStore,
    info,
    sections,
    chars,
    click_handler
  ];
}
var Snapshot_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance84, create_fragment86, safe_not_equal, { snapshot: 0, active: 1 }, add_css25);
  }
};
var snapshot_button_default = Snapshot_button;

// src/view/actions/update-relative-time.ts
var updateRelativeTime = (element2) => {
  const interval = setInterval(() => {
    const children2 = Array.from(
      element2.querySelectorAll("[data-created]")
    );
    for (const child of children2) {
      const created = child.dataset["created"];
      if (created && !isNaN(+created))
        child.textContent = relativeTime(+created);
    }
  }, 30 * 1e3);
  return {
    destroy: () => {
      clearInterval(interval);
    }
  };
};

// src/view/components/container/modals/snapshots-list/file-histoy.svelte
function add_css26(target) {
  append_styles(target, "svelte-1eg4s92", ".snapshots-list.svelte-1eg4s92{width:400px;display:flex;flex-direction:column;gap:var(--size-4-2);height:fit-content;max-height:400px;overflow-y:auto;padding-left:var(--size-4-2);padding-right:var(--size-4-2)}.snapshots-modal.svelte-1eg4s92{left:var(--size-4-2);top:50px}@media(max-width: 720px){.snapshots-list.svelte-1eg4s92{width:initial}}");
}
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  child_ctx[5] = i;
  return child_ctx;
}
function create_each_block10(key_1, ctx) {
  let first;
  let snapshotbutton;
  let current;
  snapshotbutton = new snapshot_button_default({
    props: {
      snapshot: (
        /*snapshot*/
        ctx[3]
      ),
      active: (
        /*$history*/
        ctx[0].items.length - /*index*/
        ctx[5] - 1 === /*$history*/
        ctx[0].state.activeIndex
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(snapshotbutton.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(snapshotbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const snapshotbutton_changes = {};
      if (dirty & /*$history*/
      1)
        snapshotbutton_changes.snapshot = /*snapshot*/
        ctx[3];
      if (dirty & /*$history*/
      1)
        snapshotbutton_changes.active = /*$history*/
        ctx[0].items.length - /*index*/
        ctx[5] - 1 === /*$history*/
        ctx[0].state.activeIndex;
      snapshotbutton.$set(snapshotbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(snapshotbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(snapshotbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(snapshotbutton, detaching);
    }
  };
}
function create_fragment87(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let updateRelativeTime_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*$history*/
  ctx[0].items].sort(func));
  const get_key = (ctx2) => (
    /*snapshot*/
    ctx2[3].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block10(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "snapshots-list svelte-1eg4s92");
      attr(div1, "class", "lineage-modal snapshots-modal svelte-1eg4s92");
      set_style(div1, "padding-left", "0");
      set_style(div1, "padding-right", "0");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(updateRelativeTime_action = updateRelativeTime.call(null, div0));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$history*/
      1) {
        each_value = ensure_array_like([.../*$history*/
        ctx2[0].items].sort(func));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block10, null, get_each_context10);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
var func = (a, b) => b.created - a.created;
function instance85($$self, $$props, $$invalidate) {
  let $history;
  const view = getView();
  const history = historyStore(view);
  component_subscribe($$self, history, (value) => $$invalidate(0, $history = value));
  return [$history, history];
}
var File_histoy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance85, create_fragment87, safe_not_equal, {}, add_css26);
  }
};
var file_histoy_default = File_histoy;

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/mod-key-dictionary.ts
var modKeyDictionary = {
  Mod: modKey,
  Alt: "Alt",
  Ctrl: "Ctrl",
  Meta: "Meta",
  Shift: "Shift"
};

// src/view/components/container/modals/hotkeys/components/hotkey/editor-state/render-editor-state.svelte
function add_css27(target) {
  append_styles(target, "svelte-12gga04", ".editor-state.svelte-12gga04{display:flex;align-items:center;justify-content:center;padding:2px;background-color:var(--color-base-100);color:var(--color-base-00);& svg {\n            width: 14px;\n            height: 14px;\n        }}");
}
function create_fragment88(ctx) {
  let kbd;
  let raw_value = (
    /*cursorIcon*/
    ctx[2][
      /*hotkey*/
      ctx[0].editorState
    ] + ""
  );
  let kbd_class_value;
  let kbd_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      kbd = element("kbd");
      attr(kbd, "class", kbd_class_value = null_to_empty("editor-state " + /*classes*/
      ctx[1][
        /*hotkey*/
        ctx[0].editorState
      ]) + " svelte-12gga04");
      attr(kbd, "aria-label", kbd_aria_label_value = /*label*/
      ctx[3][
        /*hotkey*/
        ctx[0].editorState
      ]);
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      kbd.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          kbd,
          "click",
          /*wrappedOnClick*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*hotkey*/
      1 && raw_value !== (raw_value = /*cursorIcon*/
      ctx2[2][
        /*hotkey*/
        ctx2[0].editorState
      ] + ""))
        kbd.innerHTML = raw_value;
      ;
      if (dirty & /*hotkey*/
      1 && kbd_class_value !== (kbd_class_value = null_to_empty("editor-state " + /*classes*/
      ctx2[1][
        /*hotkey*/
        ctx2[0].editorState
      ]) + " svelte-12gga04")) {
        attr(kbd, "class", kbd_class_value);
      }
      if (dirty & /*hotkey*/
      1 && kbd_aria_label_value !== (kbd_aria_label_value = /*label*/
      ctx2[3][
        /*hotkey*/
        ctx2[0].editorState
      ])) {
        attr(kbd, "aria-label", kbd_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance86($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let { onClick = void 0 } = $$props;
  const classes = {
    both: "editor-state--both",
    "editor-on": "editor-state--on",
    "editor-off": "editor-state--off"
  };
  const cursorIcon = {
    both: customIcons.cursor.svg,
    "editor-on": customIcons.cursor.svg,
    "editor-off": customIcons.cursorOff.svg
  };
  const label = {
    both: lang.modal_hk_editor_state_both,
    "editor-on": lang.modal_hk_editor_state_on,
    "editor-off": lang.modal_hk_editor_state_off
  };
  const wrappedOnClick = () => {
    if (onClick) {
      onClick();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("onClick" in $$props2)
      $$invalidate(5, onClick = $$props2.onClick);
  };
  return [hotkey, classes, cursorIcon, label, wrappedOnClick, onClick];
}
var Render_editor_state = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance86, create_fragment88, safe_not_equal, { hotkey: 0, onClick: 5 }, add_css27);
  }
};
var render_editor_state_default = Render_editor_state;

// src/view/components/container/modals/hotkeys/components/hotkey/render-hotkey.svelte
function add_css28(target) {
  append_styles(target, "svelte-sbdud0", ".hotkey-buttons.svelte-sbdud0{width:100%;height:100%;position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;gap:5px;opacity:0;background-color:var(--color-base-70)}.hotkey-button.svelte-sbdud0{border:none;width:16px;height:16px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-buttons.svelte-sbdud0:hover{opacity:0.8}.hotkey-key.svelte-sbdud0{color:var(--text-on-accent);background-color:#175c5a}.blank-hotkey.svelte-sbdud0{background-color:var(--color-base-30)}");
}
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_if_block_25(ctx) {
  let button;
  let trash;
  let current;
  let mounted;
  let dispose;
  trash = new trash_default({ props: { class: "svg-icon", size: 8 } });
  return {
    c() {
      button = element("button");
      create_component(trash.$$.fragment);
      attr(button, "class", "hotkey-button svelte-sbdud0");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(trash, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*makeBlank*/
            ctx[1]
          ))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(trash.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trash.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(trash);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block9(ctx) {
  let t0;
  let kbd;
  let t1_value = (
    /*hotkey*/
    ctx[2].key + ""
  );
  let t1;
  let t2;
  let each_1_anchor;
  let current;
  let if_block = (
    /*hotkey*/
    ctx[2].editorState !== "both" && create_if_block_17(ctx)
  );
  let each_value = ensure_array_like(
    /*hotkey*/
    ctx[2].modifiers
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      kbd = element("kbd");
      t1 = text(t1_value);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(kbd, "class", "hotkey-key svelte-sbdud0");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, kbd, anchor);
      append(kbd, t1);
      insert(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hotkey*/
        ctx2[2].editorState !== "both"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hotkey*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*hotkey*/
      4) && t1_value !== (t1_value = /*hotkey*/
      ctx2[2].key + ""))
        set_data(t1, t1_value);
      if (dirty & /*hotkey*/
      4) {
        each_value = ensure_array_like(
          /*hotkey*/
          ctx2[2].modifiers
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(kbd);
        detach(t2);
        detach(each_1_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block18(ctx) {
  let kbd;
  return {
    c() {
      kbd = element("kbd");
      kbd.textContent = "blank";
      attr(kbd, "class", "blank-hotkey svelte-sbdud0");
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
    }
  };
}
function create_if_block_17(ctx) {
  let editorstate;
  let current;
  editorstate = new render_editor_state_default({ props: { hotkey: (
    /*hotkey*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(editorstate.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editorstate, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editorstate_changes = {};
      if (dirty & /*hotkey*/
      4)
        editorstate_changes.hotkey = /*hotkey*/
        ctx2[2];
      editorstate.$set(editorstate_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editorstate.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editorstate.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editorstate, detaching);
    }
  };
}
function create_each_block11(ctx) {
  let kbd;
  let t_value = modKeyDictionary[
    /*modifier*/
    ctx[3]
  ] + "";
  let t;
  return {
    c() {
      kbd = element("kbd");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      append(kbd, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hotkey*/
      4 && t_value !== (t_value = modKeyDictionary[
        /*modifier*/
        ctx2[3]
      ] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
    }
  };
}
function create_fragment89(ctx) {
  let div;
  let button;
  let pen;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  pen = new pen_default({ props: { class: "svg-icon", size: 8 } });
  let if_block0 = (
    /*hotkey*/
    ctx[2].key && create_if_block_25(ctx)
  );
  const if_block_creators = [create_if_block18, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*hotkey*/
    ctx2[2].key)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(pen.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      if_block1_anchor = empty();
      attr(button, "class", "hotkey-button svelte-sbdud0");
      attr(div, "class", "hotkey-buttons svelte-sbdud0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(pen, button, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      insert(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*enableEditing*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*hotkey*/
        ctx[2].key
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*hotkey*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_25(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pen.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(pen.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t1);
        detach(if_block1_anchor);
      }
      destroy_component(pen);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance87($$self, $$props, $$invalidate) {
  let { enableEditing } = $$props;
  let { makeBlank } = $$props;
  let { hotkey } = $$props;
  $$self.$$set = ($$props2) => {
    if ("enableEditing" in $$props2)
      $$invalidate(0, enableEditing = $$props2.enableEditing);
    if ("makeBlank" in $$props2)
      $$invalidate(1, makeBlank = $$props2.makeBlank);
    if ("hotkey" in $$props2)
      $$invalidate(2, hotkey = $$props2.hotkey);
  };
  return [enableEditing, makeBlank, hotkey];
}
var Render_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance87,
      create_fragment89,
      safe_not_equal,
      {
        enableEditing: 0,
        makeBlank: 1,
        hotkey: 2
      },
      add_css28
    );
  }
};
var render_hotkey_default = Render_hotkey;

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/hotkey-to-string.ts
var hotkeyToString = (hotkey) => hotkey.key.toUpperCase() + hotkey.modifiers.sort().join("");

// src/view/actions/keyboard-shortcuts/helpers/commands/update-view-hotkeys-dictionary.ts
var viewHotkeys = {
  current: {}
};
var updateViewHotkeysDictionary = (hotkeys) => {
  viewHotkeys.current = {};
  for (const viewHotkey of hotkeys) {
    for (const hotkey of viewHotkey.hotkeys) {
      invariant(hotkey.editorState);
      if (hotkey.key === "")
        continue;
      viewHotkeys.current[hotkeyToString(hotkey)] = {
        ...viewHotkey,
        editorState: hotkey.editorState
      };
    }
  }
};

// src/view/components/container/modals/hotkeys/components/hotkey/editor-state/edit-editor-state.svelte
function create_fragment90(ctx) {
  let editorstate;
  let current;
  editorstate = new render_editor_state_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      onClick: (
        /*onClick*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(editorstate.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editorstate, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const editorstate_changes = {};
      if (dirty & /*hotkey*/
      1)
        editorstate_changes.hotkey = /*hotkey*/
        ctx2[0];
      editorstate.$set(editorstate_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editorstate.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editorstate.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editorstate, detaching);
    }
  };
}
function instance88($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  const view = getView();
  const onClick = () => {
    view.plugin.settings.dispatch({
      type: "settings/hotkeys/toggle-editor-state",
      payload: {
        command: commandName,
        type: isPrimary ? "primary" : "secondary"
      }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(2, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(3, isPrimary = $$props2.isPrimary);
  };
  return [hotkey, onClick, commandName, isPrimary];
}
var Edit_editor_state = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance88, create_fragment90, safe_not_equal, { hotkey: 0, commandName: 2, isPrimary: 3 });
  }
};
var edit_editor_state_default = Edit_editor_state;

// src/view/components/container/modals/hotkeys/components/hotkey/edit-hotkey.svelte
function add_css29(target) {
  append_styles(target, "svelte-1xi2oy8", ".container.svelte-1xi2oy8{display:flex;gap:5px;align-items:center;justify-content:center}.hotkey-container.svelte-1xi2oy8{display:flex;flex-direction:column;align-items:center;gap:5px}.input.svelte-1xi2oy8{width:115px;height:25px;text-align:center;font-size:14px}.modifiers.svelte-1xi2oy8{display:flex;gap:5px;width:100%;justify-content:center}.disabled.svelte-1xi2oy8{background-color:var(--color-base-50)}button.svelte-1xi2oy8:disabled{cursor:not-allowed}.save-and-cancel-buttons.svelte-1xi2oy8{display:flex;gap:5px;flex-direction:column}.hotkey-button.svelte-1xi2oy8{background-color:transparent;color:var(--color-base-25);border:none;width:20px;height:20px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-key.svelte-1xi2oy8{color:lightgrey;background-color:#175c5a;border-color:#227f7d}");
}
function create_if_block19(ctx) {
  let kbd;
  let t_value = "Ctrl" /* Ctrl */ + "";
  let t;
  let kbd_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      kbd = element("kbd");
      t = text(t_value);
      attr(kbd, "class", kbd_class_value = null_to_empty(!/*CTRL*/
      ctx[8] ? "disabled" : "") + " svelte-1xi2oy8");
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      append(kbd, t);
      if (!mounted) {
        dispose = listen(
          kbd,
          "click",
          /*toggleCtrl*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*CTRL*/
      256 && kbd_class_value !== (kbd_class_value = null_to_empty(!/*CTRL*/
      ctx2[8] ? "disabled" : "") + " svelte-1xi2oy8")) {
        attr(kbd, "class", kbd_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment91(ctx) {
  let div3;
  let editeditorstate;
  let t0;
  let div1;
  let div0;
  let t1;
  let kbd0;
  let t2;
  let kbd0_class_value;
  let t3;
  let kbd1;
  let t4_value = "Alt" /* Alt */ + "";
  let t4;
  let kbd1_class_value;
  let t5;
  let kbd2;
  let t6_value = "Shift" /* Shift */ + "";
  let t6;
  let kbd2_class_value;
  let t7;
  let input;
  let input_placeholder_value;
  let t8;
  let div2;
  let button0;
  let x;
  let button0_aria_label_value;
  let t9;
  let button1;
  let rotateccw;
  let button1_aria_label_value;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  editeditorstate = new edit_editor_state_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      commandName: (
        /*commandName*/
        ctx[1]
      ),
      isPrimary: (
        /*isPrimary*/
        ctx[2]
      )
    }
  });
  let if_block = isMacLike && create_if_block19(ctx);
  x = new x_default({ props: { class: "svg-icon", size: 8 } });
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon", size: 8 } });
  return {
    c() {
      div3 = element("div");
      create_component(editeditorstate.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      kbd0 = element("kbd");
      t2 = text(modKey);
      t3 = space();
      kbd1 = element("kbd");
      t4 = text(t4_value);
      t5 = space();
      kbd2 = element("kbd");
      t6 = text(t6_value);
      t7 = space();
      input = element("input");
      t8 = space();
      div2 = element("div");
      button0 = element("button");
      create_component(x.$$.fragment);
      t9 = space();
      button1 = element("button");
      create_component(rotateccw.$$.fragment);
      attr(kbd0, "class", kbd0_class_value = null_to_empty(!/*MOD*/
      ctx[5] ? "disabled" : "") + " svelte-1xi2oy8");
      attr(kbd1, "class", kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[7] ? "disabled" : "") + " svelte-1xi2oy8");
      attr(kbd2, "class", kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[6] ? "disabled" : "") + " svelte-1xi2oy8");
      attr(div0, "class", "modifiers svelte-1xi2oy8");
      attr(input, "class", "search-input input hotkey-key svelte-1xi2oy8");
      attr(input, "placeholder", input_placeholder_value = "Key");
      attr(input, "spellcheck", "false");
      attr(input, "type", "text");
      attr(div1, "class", "hotkey-container svelte-1xi2oy8");
      attr(button0, "aria-label", button0_aria_label_value = lang.modals_hk_editor_cancel);
      attr(button0, "class", "hotkey-button svelte-1xi2oy8");
      attr(button1, "aria-label", button1_aria_label_value = lang.settings_reset);
      attr(button1, "class", "hotkey-button svelte-1xi2oy8");
      button1.disabled = button1_disabled_value = /*hotkey*/
      ctx[0].key.length > 0 && !/*hotkey*/
      ctx[0].isCustom;
      attr(div2, "class", "save-and-cancel-buttons svelte-1xi2oy8");
      attr(div3, "class", "container svelte-1xi2oy8");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(editeditorstate, div3, null);
      append(div3, t0);
      append(div3, div1);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t1);
      append(div0, kbd0);
      append(kbd0, t2);
      append(div0, t3);
      append(div0, kbd1);
      append(kbd1, t4);
      append(div0, t5);
      append(div0, kbd2);
      append(kbd2, t6);
      append(div1, t7);
      append(div1, input);
      set_input_value(
        input,
        /*key*/
        ctx[4]
      );
      append(div3, t8);
      append(div3, div2);
      append(div2, button0);
      mount_component(x, button0, null);
      append(div2, t9);
      append(div2, button1);
      mount_component(rotateccw, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            kbd0,
            "click",
            /*toggleMod*/
            ctx[10]
          ),
          listen(
            kbd1,
            "click",
            /*toggleAlt*/
            ctx[12]
          ),
          listen(
            kbd2,
            "click",
            /*toggleShift*/
            ctx[11]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[15]
          ),
          listen(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[9]
          ),
          listen(button0, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }),
          listen(
            button1,
            "click",
            /*reset*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const editeditorstate_changes = {};
      if (dirty & /*hotkey*/
      1)
        editeditorstate_changes.hotkey = /*hotkey*/
        ctx[0];
      if (dirty & /*commandName*/
      2)
        editeditorstate_changes.commandName = /*commandName*/
        ctx[1];
      if (dirty & /*isPrimary*/
      4)
        editeditorstate_changes.isPrimary = /*isPrimary*/
        ctx[2];
      editeditorstate.$set(editeditorstate_changes);
      if (isMacLike)
        if_block.p(ctx, dirty);
      if (!current || dirty & /*MOD*/
      32 && kbd0_class_value !== (kbd0_class_value = null_to_empty(!/*MOD*/
      ctx[5] ? "disabled" : "") + " svelte-1xi2oy8")) {
        attr(kbd0, "class", kbd0_class_value);
      }
      if (!current || dirty & /*ALT*/
      128 && kbd1_class_value !== (kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[7] ? "disabled" : "") + " svelte-1xi2oy8")) {
        attr(kbd1, "class", kbd1_class_value);
      }
      if (!current || dirty & /*SHIFT*/
      64 && kbd2_class_value !== (kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[6] ? "disabled" : "") + " svelte-1xi2oy8")) {
        attr(kbd2, "class", kbd2_class_value);
      }
      if (dirty & /*key*/
      16 && input.value !== /*key*/
      ctx[4]) {
        set_input_value(
          input,
          /*key*/
          ctx[4]
        );
      }
      if (!current || dirty & /*hotkey*/
      1 && button1_disabled_value !== (button1_disabled_value = /*hotkey*/
      ctx[0].key.length > 0 && !/*hotkey*/
      ctx[0].isCustom)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(editeditorstate.$$.fragment, local);
      transition_in(x.$$.fragment, local);
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editeditorstate.$$.fragment, local);
      transition_out(x.$$.fragment, local);
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(editeditorstate);
      if (if_block)
        if_block.d();
      destroy_component(x);
      destroy_component(rotateccw);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance89($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  let { onCancel } = $$props;
  const view = getView();
  let key = hotkey.key;
  let MOD = hotkey.modifiers.includes("Mod");
  let SHIFT = hotkey.modifiers.includes("Shift");
  let ALT = hotkey.modifiers.includes("Alt");
  let CTRL = hotkey.modifiers.includes("Ctrl");
  const onKeyDown = (e) => {
    e.preventDefault();
    if (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)
      return;
    if (e.key === " " || e.key === "META")
      return;
    $$invalidate(4, key = e.key);
    save();
  };
  const toggleMod = () => {
    $$invalidate(5, MOD = !MOD);
    save();
  };
  const toggleShift = () => {
    $$invalidate(6, SHIFT = !SHIFT);
    save();
  };
  const toggleAlt = () => {
    $$invalidate(7, ALT = !ALT);
    save();
  };
  const toggleCtrl = () => {
    $$invalidate(8, CTRL = !CTRL);
    save();
  };
  const save = () => {
    let modifiers = [];
    if (MOD)
      modifiers.push("Mod");
    if (SHIFT)
      modifiers.push("Shift");
    if (ALT)
      modifiers.push("Alt");
    if (CTRL && isMacLike)
      modifiers.push("Ctrl");
    view.plugin.settings.dispatch({
      type: "settings/hotkeys/set-custom-hotkey",
      payload: {
        hotkey: { key, modifiers },
        type: isPrimary ? "primary" : "secondary",
        command: commandName
      }
    });
  };
  const reset = () => {
    view.plugin.settings.dispatch({
      type: "settings/hotkeys/reset-custom-hotkey",
      payload: {
        command: commandName,
        type: isPrimary ? "primary" : "secondary"
      }
    });
    setTimeout(() => {
      $$invalidate(5, MOD = hotkey.modifiers.includes("Mod"));
      $$invalidate(7, ALT = hotkey.modifiers.includes("Alt"));
      $$invalidate(6, SHIFT = hotkey.modifiers.includes("Shift"));
      $$invalidate(8, CTRL = hotkey.modifiers.includes("Ctrl"));
      $$invalidate(4, key = hotkey.key);
    });
    focusContainer(view);
  };
  function input_input_handler() {
    key = this.value;
    $$invalidate(4, key);
  }
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(1, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(2, isPrimary = $$props2.isPrimary);
    if ("onCancel" in $$props2)
      $$invalidate(3, onCancel = $$props2.onCancel);
  };
  return [
    hotkey,
    commandName,
    isPrimary,
    onCancel,
    key,
    MOD,
    SHIFT,
    ALT,
    CTRL,
    onKeyDown,
    toggleMod,
    toggleShift,
    toggleAlt,
    toggleCtrl,
    reset,
    input_input_handler
  ];
}
var Edit_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance89,
      create_fragment91,
      safe_not_equal,
      {
        hotkey: 0,
        commandName: 1,
        isPrimary: 2,
        onCancel: 3
      },
      add_css29
    );
  }
};
var edit_hotkey_default = Edit_hotkey;

// src/view/components/container/modals/hotkeys/components/hotkey/hotkey.svelte
var import_classnames4 = __toESM(require_classnames());
function add_css30(target) {
  append_styles(target, "svelte-1ctyvzu", ".hotkey.svelte-1ctyvzu{padding:5px;background-color:var(--color-base-50);display:flex;gap:5px;border-radius:3px;width:fit-content;position:relative}.editing.svelte-1ctyvzu{background-color:var(--color-base-60)}.hotkey--is-custom.svelte-1ctyvzu{background-color:var(--custom-hotkey-bg)}.obsidian-conflict.svelte-1ctyvzu{background-color:var(--color-red)}.plugin-conflict.svelte-1ctyvzu{background-color:var(--color-orange)}");
}
function create_else_block10(ctx) {
  let renderhotkey;
  let current;
  renderhotkey = new render_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      enableEditing: (
        /*func_1*/
        ctx[7]
      ),
      makeBlank: (
        /*makeBlank*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      create_component(renderhotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(renderhotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const renderhotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        renderhotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      renderhotkey.$set(renderhotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(renderhotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renderhotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(renderhotkey, detaching);
    }
  };
}
function create_if_block20(ctx) {
  let edithotkey;
  let current;
  edithotkey = new edit_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      onCancel: (
        /*func*/
        ctx[6]
      ),
      isPrimary: (
        /*isPrimary*/
        ctx[2]
      ),
      commandName: (
        /*commandName*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(edithotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edithotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edithotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        edithotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      if (dirty & /*isPrimary*/
      4)
        edithotkey_changes.isPrimary = /*isPrimary*/
        ctx2[2];
      if (dirty & /*commandName*/
      2)
        edithotkey_changes.commandName = /*commandName*/
        ctx2[1];
      edithotkey.$set(edithotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edithotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edithotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edithotkey, detaching);
    }
  };
}
function create_fragment92(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_aria_label_value;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block20, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$editing*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "aria-label", div_aria_label_value = /*hotkey*/
      ctx[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx[0].pluginConflict}"` : ""
      ));
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames4.default)(
        "hotkey",
        /*hotkey*/
        ctx[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx[0].pluginConflict && "plugin-conflict",
        /*hotkey*/
        ctx[0].isCustom && "hotkey--is-custom",
        /*$editing*/
        ctx[3] && "editing"
      )) + " svelte-1ctyvzu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*hotkey*/
      1 && div_aria_label_value !== (div_aria_label_value = /*hotkey*/
      ctx2[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx2[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx2[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx2[0].pluginConflict}"` : ""
      ))) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!current || dirty & /*hotkey, $editing*/
      9 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames4.default)(
        "hotkey",
        /*hotkey*/
        ctx2[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx2[0].pluginConflict && "plugin-conflict",
        /*hotkey*/
        ctx2[0].isCustom && "hotkey--is-custom",
        /*$editing*/
        ctx2[3] && "editing"
      )) + " svelte-1ctyvzu")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance90($$self, $$props, $$invalidate) {
  let $editing;
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  const view = getView();
  const editing = writable(false);
  component_subscribe($$self, editing, (value) => $$invalidate(3, $editing = value));
  onMount(() => {
    let initialRun = true;
    return editing.subscribe(() => {
      if (initialRun) {
        initialRun = false;
      } else {
        focusContainer(view);
      }
    });
  });
  const makeBlank = () => {
    view.plugin.settings.dispatch({
      type: "settings/hotkeys/set-blank",
      payload: {
        command: commandName,
        type: isPrimary ? "primary" : "secondary"
      }
    });
  };
  const func2 = () => editing.set(false);
  const func_1 = () => editing.set(true);
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(1, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(2, isPrimary = $$props2.isPrimary);
  };
  return [hotkey, commandName, isPrimary, $editing, editing, makeBlank, func2, func_1];
}
var Hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance90, create_fragment92, safe_not_equal, { hotkey: 0, commandName: 1, isPrimary: 2 }, add_css30);
  }
};
var hotkey_default = Hotkey;

// src/lang/hotkeys-lang.ts
var hotkeysLang = {
  save_changes_and_exit_card: lang.hk_save_changes,
  enable_edit_mode: lang.hk_enable_edit_mode,
  enable_edit_mode_and_place_cursor_at_start: lang.hk_enable_edit_mode_and_place_cursor_at_start,
  enable_edit_mode_and_place_cursor_at_end: lang.hk_enable_edit_mode_and_place_cursor_at_end,
  disable_edit_mode: lang.hk_disable_edit_mode,
  add_child: lang.card_btn_add_child_node,
  add_below: lang.card_btn_add_node_below,
  add_above: lang.card_btn_add_node_above,
  add_child_and_split: lang.hk_add_child_and_split,
  add_below_and_split: lang.hk_add_below_and_split,
  add_above_and_split: lang.hk_add_above_and_split,
  delete_card: lang.hk_delete_section,
  go_up: lang.hk_go_up,
  go_down: lang.hk_go_down,
  go_right: lang.hk_go_right,
  go_left: lang.hk_go_Left,
  undo_change: lang.hk_undo_change,
  redo_change: lang.hk_redo_change,
  move_node_up: lang.hk_move_node_up,
  move_node_down: lang.hk_move_node_down,
  move_node_right: lang.hk_move_node_right,
  move_node_left: lang.hk_move_node_left,
  merge_with_node_above: lang.hk_merge_with_node_above,
  merge_with_node_below: lang.hk_merge_with_node_below,
  toggle_search_input: lang.hk_toggle_search_input,
  go_to_beginning_of_group: lang.hk_go_to_beginning_of_group,
  go_to_end_of_group: lang.hk_go_to_end_of_group,
  go_to_beginning_of_column: lang.hk_go_to_beginning_of_column,
  go_to_end_of_column: lang.hk_go_to_end_of_column,
  select_parent: lang.hk_select_parent,
  copy_node: lang.hk_copy_node,
  copy_node_unformatted: lang.hk_copy_node_unformatted,
  copy_node_without_subitems: lang.hk_copy_node_without_subitems,
  cut_node: lang.hk_cut_node,
  paste_node: lang.hk_paste_node,
  navigate_back: lang.hk_navigate_back,
  navigate_forward: lang.hk_navigate_forward,
  navigate_to_next_node: lang.hk_navigate_to_next_node,
  navigate_to_previous_node: lang.hk_navigate_to_previous_node,
  extend_select_up: lang.hk_extend_select_up,
  extend_select_down: lang.hk_extend_select_down,
  extend_select_to_start_of_group: lang.hk_extend_select_to_start_of_group,
  extend_select_to_end_of_group: lang.hk_extend_select_to_end_of_group,
  extend_select_to_start_of_column: lang.hk_extend_select_to_start_of_column,
  extend_select_to_end_of_column: lang.hk_extend_select_to_end_of_column,
  scroll_left: lang.hk_scroll_left,
  scroll_right: lang.hk_scroll_right,
  scroll_up: lang.hk_scroll_up,
  scroll_down: lang.hk_scroll_down,
  align_branch: lang.hk_align_branch,
  zoom_in: lang.hk_zoom_in,
  zoom_out: lang.hk_zoom_out,
  zoom_reset: lang.hk_zoom_reset,
  toggle_collapse: lang.hk_outline_toggle_collapse,
  toggle_collapse_all: lang.hk_outline_toggle_collapse_all,
  toggle_outline_mode: lang.hk_toggle_outline_mode,
  add_parent_sibling: lang.hk_add_parent_sibling,
  select_all_nodes: lang.hk_select_all
};

// src/view/components/container/modals/hotkeys/components/helpers/get-dynamic-label.ts
var HotkeysThatBehaveDifferentlyInOutlineMode = /* @__PURE__ */ new Set(["go_down", "go_up", "go_left", "go_right"]);
var getDynamicLabel = (name, outlineMode) => {
  if (outlineMode) {
    if (name === "go_down") {
      return hotkeysLang["navigate_to_previous_node"];
    } else if (name === "go_up") {
      return hotkeysLang["navigate_to_next_node"];
    } else if (name === "go_left") {
      return lang.hk_select_previous_sibling;
    } else if (name === "go_right") {
      return lang.hk_select_next_sibling;
    }
  }
  return hotkeysLang[name];
};

// src/view/components/container/modals/hotkeys/components/command.svelte
function add_css31(target) {
  append_styles(target, "svelte-1qxnonu", ".command.svelte-1qxnonu{padding:8px;display:flex;align-items:center;justify-content:space-between;border-radius:4px;gap:8px;background-color:var(--color-base-30);flex-wrap:wrap}.hotkeys.svelte-1qxnonu{display:flex;flex-direction:column;align-items:end;gap:5px}.label.svelte-1qxnonu{font-size:14px;color:var(--text-normal);position:relative;display:flex;align-items:center;gap:5px}.info-icon.svelte-1qxnonu{color:#4973A1FF;margin-bottom:-4px;& svg {\n            width: 12px;\n            height: 12px;\n        }}");
}
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[4] = i;
  return child_ctx;
}
function create_if_block21(ctx) {
  let span;
  let info;
  let current;
  info = new info_default({ props: { class: "svg-icon" } });
  return {
    c() {
      span = element("span");
      create_component(info.$$.fragment);
      attr(span, "class", "info-icon svelte-1qxnonu");
      attr(span, "aria-label", "Behaves differently in outline mode");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(info, span, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(info);
    }
  };
}
function create_each_block12(ctx) {
  let hotkey_1;
  let current;
  hotkey_1 = new hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[2]
      ),
      commandName: (
        /*commandHotkeys*/
        ctx[0].name
      ),
      isPrimary: (
        /*i*/
        ctx[4] === 0
      )
    }
  });
  return {
    c() {
      create_component(hotkey_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkey_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const hotkey_1_changes = {};
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.hotkey = /*hotkey*/
        ctx2[2];
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.commandName = /*commandHotkeys*/
        ctx2[0].name;
      hotkey_1.$set(hotkey_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkey_1, detaching);
    }
  };
}
function create_fragment93(ctx) {
  let div1;
  let span;
  let t0_value = getDynamicLabel(
    /*commandHotkeys*/
    ctx[0].name,
    /*labelState*/
    ctx[1].outlineMode
  ) + "";
  let t0;
  let t1;
  let show_if = HotkeysThatBehaveDifferentlyInOutlineMode.has(
    /*commandHotkeys*/
    ctx[0].name
  );
  let t2;
  let div0;
  let current;
  let if_block = show_if && create_if_block21(ctx);
  let each_value = ensure_array_like(
    /*commandHotkeys*/
    ctx[0].hotkeys
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "label svelte-1qxnonu");
      attr(div0, "class", "hotkeys svelte-1qxnonu");
      attr(div1, "class", "command svelte-1qxnonu");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, t0);
      append(span, t1);
      if (if_block)
        if_block.m(span, null);
      append(div1, t2);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*commandHotkeys, labelState*/
      3) && t0_value !== (t0_value = getDynamicLabel(
        /*commandHotkeys*/
        ctx2[0].name,
        /*labelState*/
        ctx2[1].outlineMode
      ) + ""))
        set_data(t0, t0_value);
      if (dirty & /*commandHotkeys*/
      1)
        show_if = HotkeysThatBehaveDifferentlyInOutlineMode.has(
          /*commandHotkeys*/
          ctx2[0].name
        );
      if (show_if) {
        if (if_block) {
          if (dirty & /*commandHotkeys*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & /*commandHotkeys*/
      1) {
        each_value = ensure_array_like(
          /*commandHotkeys*/
          ctx2[0].hotkeys
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance91($$self, $$props, $$invalidate) {
  let { commandHotkeys } = $$props;
  let { labelState } = $$props;
  $$self.$$set = ($$props2) => {
    if ("commandHotkeys" in $$props2)
      $$invalidate(0, commandHotkeys = $$props2.commandHotkeys);
    if ("labelState" in $$props2)
      $$invalidate(1, labelState = $$props2.labelState);
  };
  return [commandHotkeys, labelState];
}
var Command = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance91, create_fragment93, safe_not_equal, { commandHotkeys: 0, labelState: 1 }, add_css31);
  }
};
var command_default = Command;

// src/view/components/container/modals/hotkeys/group.svelte
function add_css32(target) {
  append_styles(target, "svelte-1ct7tgv", ".hotkey-group.svelte-1ct7tgv{background-color:var(--background-secondary);padding:var(--size-4-2);border-radius:3px}.hotkeys-list.svelte-1ct7tgv{display:flex;flex-direction:column;gap:var(--size-4-2);overflow-y:auto}.hotkey-group-name.svelte-1ct7tgv{padding-bottom:10px;padding-left:5px;font-size:16px;color:var(--color-base-70)}");
}
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block13(key_1, ctx) {
  let first;
  let hotkey;
  let current;
  hotkey = new command_default({
    props: {
      commandHotkeys: (
        /*commandHotkeys*/
        ctx[3]
      ),
      labelState: (
        /*labelState*/
        ctx[1]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(hotkey.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(hotkey, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkey_changes = {};
      if (dirty & /*group*/
      1)
        hotkey_changes.commandHotkeys = /*commandHotkeys*/
        ctx[3];
      if (dirty & /*labelState*/
      2)
        hotkey_changes.labelState = /*labelState*/
        ctx[1];
      hotkey.$set(hotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(hotkey, detaching);
    }
  };
}
function create_fragment94(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*commandHotkeys*/
    ctx2[3].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context13(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block13(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*groupName*/
        ctx[2]
      );
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "hotkey-group-name svelte-1ct7tgv");
      attr(div1, "class", "hotkeys-list svelte-1ct7tgv");
      attr(div2, "class", "hotkey-group svelte-1ct7tgv");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*groupName*/
      4)
        set_data(
          t0,
          /*groupName*/
          ctx2[2]
        );
      if (dirty & /*group, labelState*/
      3) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block13, null, get_each_context13);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance92($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let { labelState } = $$props;
  let { groupName } = $$props;
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
    if ("labelState" in $$props2)
      $$invalidate(1, labelState = $$props2.labelState);
    if ("groupName" in $$props2)
      $$invalidate(2, groupName = $$props2.groupName);
  };
  return [group, labelState, groupName];
}
var Group2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance92, create_fragment94, safe_not_equal, { group: 0, labelState: 1, groupName: 2 }, add_css32);
  }
};
var group_default2 = Group2;

// src/view/components/container/modals/hotkeys/front.svelte
function add_css33(target) {
  append_styles(target, "svelte-105pskz", ".front.svelte-105pskz{display:flex;justify-content:space-between;align-items:center;width:100%}.search-input-container.svelte-105pskz{width:100%}");
}
function create_fragment95(ctx) {
  let div2;
  let div1;
  let input;
  let input_placeholder_value;
  let t;
  let div0;
  let div0_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "class", "search-input");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = lang.modals_hk_input_placeholder);
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      attr(div0, "aria-label", div0_aria_label_value = lang.tlb_search_clear);
      attr(div0, "class", "search-input-clear-button");
      attr(div1, "class", "search-input-container svelte-105pskz");
      attr(div2, "class", "front svelte-105pskz");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*searchTerm*/
        ctx[0]
      );
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[1]
          ),
          listen(
            div0,
            "click",
            /*click_handler*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*searchTerm*/
      1 && input.value !== /*searchTerm*/
      ctx2[0]) {
        set_input_value(
          input,
          /*searchTerm*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance93($$self, $$props, $$invalidate) {
  let searchTerm = "";
  const view = getView();
  function input_input_handler() {
    searchTerm = this.value;
    $$invalidate(0, searchTerm);
  }
  const click_handler = () => {
    $$invalidate(0, searchTerm = "");
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*searchTerm*/
    1) {
      $: {
        view.viewStore.dispatch({
          type: "view/hotkeys/set-search-term",
          payload: { searchTerm }
        });
      }
    }
  };
  return [searchTerm, input_input_handler, click_handler];
}
var Front = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance93, create_fragment95, safe_not_equal, {}, add_css33);
  }
};
var front_default = Front;

// src/view/components/container/modals/hotkeys/status-bar.svelte
var import_obsidian18 = require("obsidian");

// src/view/actions/keyboard-shortcuts/helpers/commands/presets/alt-primary-modifier.ts
var AltPrimaryModifier = {
  navigate_back: {
    primary: {
      key: "J",
      modifiers: ["Alt", "Mod", "Shift"]
    }
  },
  navigate_forward: {
    primary: {
      key: "K",
      modifiers: ["Alt", "Mod", "Shift"]
    }
  },
  add_below_and_split: {
    primary: {
      key: "J",
      modifiers: ["Alt"]
    }
  },
  add_above_and_split: {
    primary: {
      key: "K",
      modifiers: ["Alt"]
    }
  },
  add_child_and_split: {
    primary: {
      key: "L",
      modifiers: ["Alt"]
    }
  },
  delete_card: {
    primary: {
      key: "Backspace",
      modifiers: ["Alt"]
    }
  },
  save_changes_and_exit_card: {
    primary: {
      key: "Enter",
      modifiers: ["Alt", "Shift"]
    }
  },
  add_above: {
    primary: {
      key: "ArrowUp",
      modifiers: ["Alt"]
    }
  },
  add_below: {
    primary: {
      key: "ArrowDown",
      modifiers: ["Alt"]
    }
  },
  add_child: {
    primary: {
      key: "ArrowRight",
      modifiers: ["Alt"]
    }
  },
  add_parent_sibling: {
    secondary: {
      key: "H",
      modifiers: ["Alt"]
    },
    primary: {
      key: "ArrowLeft",
      modifiers: ["Alt"]
    }
  }
};

// src/view/components/container/modals/hotkeys/status-bar.svelte
function add_css34(target) {
  append_styles(target, "svelte-183y6er", ".hotkeys-status-bar.svelte-183y6er{display:flex;align-items:center}.conflicts-indicator.svelte-183y6er{font-size:12px;color:var(--color-red)}.hotkeys-menu.svelte-183y6er{margin-left:auto;padding:3px;cursor:pointer;transition:opacity ease 100ms;opacity:0.7;& svg {\n            width: 14px;\n            height: 14px;\n        };&:hover {\n            opacity: 1;\n        }}");
}
function create_if_block22(ctx) {
  let span;
  let t0;
  let t1;
  let t2_value = (
    /*conflicts*/
    ctx[0] === 1 ? "" : "s"
  );
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(
        /*conflicts*/
        ctx[0]
      );
      t1 = text(" command");
      t2 = text(t2_value);
      t3 = text(" with conflicts");
      attr(span, "class", "conflicts-indicator svelte-183y6er");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*conflicts*/
      1)
        set_data(
          t0,
          /*conflicts*/
          ctx2[0]
        );
      if (dirty & /*conflicts*/
      1 && t2_value !== (t2_value = /*conflicts*/
      ctx2[0] === 1 ? "" : "s"))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment96(ctx) {
  let div;
  let t;
  let span;
  let settings;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*conflicts*/
    ctx[0] && create_if_block22(ctx)
  );
  settings = new settings_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      create_component(settings.$$.fragment);
      attr(span, "class", "hotkeys-menu svelte-183y6er");
      attr(div, "class", "hotkeys-status-bar svelte-183y6er");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, span);
      mount_component(settings, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          span,
          "click",
          /*showMenu*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*conflicts*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(settings);
      mounted = false;
      dispose();
    }
  };
}
function instance94($$self, $$props, $$invalidate) {
  let { conflicts } = $$props;
  const view = getView();
  const showMenu = (e) => {
    const menu = new import_obsidian18.Menu();
    menu.addItem((item) => {
      item.setTitle(lang.modals_hk_reset_hotkeys);
      item.onClick(() => {
        view.plugin.settings.dispatch({ type: "settings/hotkeys/reset-all" });
      });
    });
    menu.addItem((item) => {
      item.setTitle(lang.modals_hk_load_alt_hotkeys_preset);
      item.onClick(() => {
        view.plugin.settings.dispatch({
          type: "settings/hotkeys/apply-preset",
          payload: { preset: AltPrimaryModifier }
        });
      });
    });
    menu.showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("conflicts" in $$props2)
      $$invalidate(0, conflicts = $$props2.conflicts);
  };
  return [conflicts, showMenu];
}
var Status_bar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance94, create_fragment96, safe_not_equal, { conflicts: 0 }, add_css34);
  }
};
var status_bar_default = Status_bar;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/navigate-commands.ts
var outlineModeSelector = (view) => view.plugin.settings.getValue().view.outlineMode;
var maintainEditMode = (view) => view.plugin.settings.getValue().view.maintainEditMode;
var maybeEnableEditMode = (view) => {
  const viewState = view.viewStore.getValue();
  const isEditing2 = viewState.document.editing.activeNodeId;
  const activeNode = viewState.document.activeNode;
  if (isEditing2 && maintainEditMode(view)) {
    setTimeout(() => {
      const newActiveNode = view.viewStore.getValue().document.activeNode;
      if (newActiveNode !== activeNode) {
        enableEditModeInMainSplit(view, newActiveNode);
      }
    }, 16);
  }
};
var spatialNavigation = (view, direction) => {
  maybeEnableEditMode(view);
  view.viewStore.dispatch({
    type: "view/set-active-node/keyboard",
    payload: {
      direction
    },
    context: {
      outlineMode: outlineModeSelector(view)
    }
  });
};
var sequentialNavigation = (view, direction) => {
  maybeEnableEditMode(view);
  view.viewStore.dispatch({
    type: "view/set-active-node/sequential/select-next",
    payload: {
      direction,
      sections: view.documentStore.getValue().sections
    },
    context: {
      outlineMode: outlineModeSelector(view)
    }
  });
};
var jump = (view, target) => {
  maybeEnableEditMode(view);
  view.viewStore.dispatch({
    type: "view/set-active-node/keyboard-jump",
    payload: {
      target
    }
  });
};
var navigateCommands = () => {
  const commands = [];
  commands.push(
    {
      name: "go_right",
      callback: (view, event) => {
        event.preventDefault();
        if (!outlineModeSelector(view)) {
          spatialNavigation(view, "right");
        } else {
          spatialNavigation(view, "down");
        }
      },
      hotkeys: [
        { key: "L", modifiers: [], editorState: "editor-off" },
        { key: "ArrowRight", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_left",
      callback: (view, event) => {
        event.preventDefault();
        if (!outlineModeSelector(view)) {
          spatialNavigation(view, "left");
        } else {
          spatialNavigation(view, "up");
        }
      },
      hotkeys: [
        { key: "H", modifiers: [], editorState: "editor-off" },
        { key: "ArrowLeft", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_down",
      callback: (view, event) => {
        event.preventDefault();
        if (!outlineModeSelector(view)) {
          spatialNavigation(view, "down");
        } else {
          sequentialNavigation(view, "forward");
        }
      },
      hotkeys: [
        { key: "J", modifiers: [], editorState: "editor-off" },
        { key: "ArrowDown", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_up",
      callback: (view, event) => {
        event.preventDefault();
        if (!outlineModeSelector(view)) {
          spatialNavigation(view, "up");
        } else {
          sequentialNavigation(view, "back");
        }
      },
      hotkeys: [
        { key: "K", modifiers: [], editorState: "editor-off" },
        { key: "ArrowUp", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "select_parent",
      callback: (view, event) => {
        event.preventDefault();
        spatialNavigation(view, "left");
      },
      hotkeys: [{ key: "G", modifiers: [], editorState: "editor-off" }]
    },
    {
      name: "navigate_to_next_node",
      callback: (view, event) => {
        event.preventDefault();
        sequentialNavigation(view, "forward");
      },
      hotkeys: [{ key: "N", modifiers: [], editorState: "editor-off" }]
    },
    {
      name: "navigate_to_previous_node",
      callback: (view, event) => {
        event.preventDefault();
        sequentialNavigation(view, "back");
      },
      hotkeys: [{ key: "B", modifiers: [], editorState: "editor-off" }]
    },
    {
      name: "go_to_beginning_of_group",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        jump(view, "start-of-group");
      },
      hotkeys: [
        { key: "PageUp", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_to_end_of_group",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        jump(view, "end-of-group");
      },
      hotkeys: [
        { key: "PageDown", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_to_beginning_of_column",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        jump(view, "start-of-column");
      },
      hotkeys: [
        { key: "Home", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "go_to_end_of_column",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        jump(view, "end-of-column");
      },
      hotkeys: [{ key: "End", modifiers: [], editorState: "editor-off" }]
    },
    {
      name: "navigate_back",
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "view/set-active-node/history/select-previous"
        });
      },
      hotkeys: [{ key: "J", modifiers: ["Alt"], editorState: "both" }]
    },
    {
      name: "navigate_forward",
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "view/set-active-node/history/select-next"
        });
      },
      hotkeys: [{ key: "K", modifiers: ["Alt"], editorState: "both" }]
    }
  );
  return commands;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/cancel-changes.ts
var cancelChanges = (view) => {
  const documentViewState = view.viewStore.getValue().document;
  if (documentViewState.pendingConfirmation.disableEdit) {
    view.inlineEditor.unloadNode(void 0, true);
    if (documentViewState.editing.isInSidebar) {
      view.viewStore.dispatch({
        type: "view/editor/disable-sidebar-editor"
      });
    } else {
      view.viewStore.dispatch({
        type: "view/editor/disable-main-editor"
      });
    }
  } else {
    view.inlineEditor.onNextChange(() => {
      view.viewStore.dispatch({
        type: "view/editor/disable/reset-confirmation"
      });
    });
    view.viewStore.dispatch({
      type: "view/editor/disable/confirm",
      payload: {
        id: documentViewState.editing.activeNodeId
      }
    });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/edit-commands.ts
var editCommands = () => {
  return [
    {
      name: "enable_edit_mode",
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "view/editor/enable-main-editor",
          payload: {
            nodeId: view.viewStore.getValue().document.activeNode
          }
        });
      },
      hotkeys: [
        { key: "Enter", modifiers: [], editorState: "editor-off" }
      ]
    },
    {
      name: "enable_edit_mode_and_place_cursor_at_start",
      callback: (view, event) => {
        event.preventDefault();
        const nodeId = view.viewStore.getValue().document.activeNode;
        view.inlineEditor.setNodeCursor(nodeId, { line: 0, ch: 0 });
        view.viewStore.dispatch({
          type: "view/editor/enable-main-editor",
          payload: {
            nodeId
          }
        });
      },
      hotkeys: [
        {
          key: "Enter",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "enable_edit_mode_and_place_cursor_at_end",
      callback: (view, event) => {
        event.preventDefault();
        const nodeId = view.viewStore.getValue().document.activeNode;
        view.inlineEditor.deleteNodeCursor(nodeId);
        view.viewStore.dispatch({
          type: "view/editor/enable-main-editor",
          payload: {
            nodeId
          }
        });
      },
      hotkeys: [
        { key: "Enter", modifiers: ["Alt"], editorState: "editor-off" }
      ]
    },
    {
      name: "save_changes_and_exit_card",
      callback: (view) => {
        saveNodeContent(view);
      },
      hotkeys: [
        {
          key: "Enter",
          modifiers: ["Shift", "Mod"],
          editorState: "editor-on"
        }
      ]
    },
    {
      name: "disable_edit_mode",
      callback: (view) => {
        cancelChanges(view);
      },
      hotkeys: [
        { key: "Escape", modifiers: [], editorState: "editor-on" }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/add-node-and-split-at-cursor.ts
var flattenEditorPosition = (value, cursor2) => {
  const lines = value.split("\n");
  let total = 0;
  for (let i = 0; i < lines.length; i++) {
    if (cursor2.line === i) {
      return total + cursor2.ch;
    } else {
      total += lines[i].length + 1;
    }
  }
  throw new Error(`invalid cursor line: ${cursor2.line} ch: ${cursor2.ch}`);
};
var addNodeAndSplitAtCursor = (view, direction) => {
  let text2 = "";
  let firstHalf = "", secondHalf = "";
  const value = view.inlineEditor.getContent();
  const cursor2 = flattenEditorPosition(value, view.inlineEditor.getCursor());
  if (cursor2 <= value.length) {
    firstHalf = value.substring(0, cursor2);
    secondHalf = value.substring(cursor2);
    if (direction === "up") {
      view.inlineEditor.setContent(secondHalf.trimStart());
      text2 = firstHalf.trimEnd();
    } else {
      view.inlineEditor.setContent(firstHalf.trimEnd());
      text2 = secondHalf.trimStart();
    }
  }
  saveNodeAndInsertNode(view, direction, text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/create-commands.ts
var createCommands = () => {
  return [
    {
      name: "add_above",
      callback: (view) => {
        saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [
        {
          key: "ArrowUp",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "add_below",
      callback: (view) => {
        saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [
        {
          key: "ArrowDown",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "add_child",
      callback: (view) => {
        saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [
        {
          key: "ArrowRight",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "add_parent_sibling",
      callback: (view) => {
        saveNodeAndInsertNode(view, "left");
      },
      hotkeys: [
        {
          key: "ArrowLeft",
          modifiers: ["Mod"],
          editorState: "editor-off"
        },
        {
          key: "H",
          modifiers: ["Mod"],
          editorState: "both"
        }
      ]
    },
    {
      name: "add_above_and_split",
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "up");
        else
          saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [{ key: "K", modifiers: ["Mod"], editorState: "both" }]
    },
    {
      name: "add_below_and_split",
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "down");
        else
          saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [{ key: "J", modifiers: ["Mod"], editorState: "both" }]
    },
    {
      name: "add_child_and_split",
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "right");
        else
          saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [{ key: "L", modifiers: ["Mod"], editorState: "both" }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/move-node.ts
var restoreEditingState = (view, state2) => {
  setTimeout(() => {
    view.viewStore.dispatch({
      type: "view/editor/enable-main-editor",
      payload: {
        nodeId: state2.editedNode
      }
    });
  });
};
var moveNode = async (view, direction) => {
  let state2 = null;
  if (view.inlineEditor.nodeId) {
    state2 = {
      editedNode: view.inlineEditor.nodeId
    };
  }
  saveNodeContent(view);
  const document2 = view.viewStore.getValue().document;
  view.documentStore.dispatch({
    type: "document/move-node",
    payload: {
      direction,
      activeNodeId: document2.activeNode,
      selectedNodes: document2.selectedNodes
    }
  });
  if (state2)
    restoreEditingState(view, state2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/move-commands.ts
var moveCommands = () => {
  return [
    {
      name: "move_node_up",
      callback: (view) => {
        moveNode(view, "up");
      },
      hotkeys: [
        { key: "K", modifiers: ["Alt", "Shift"], editorState: "both" },
        {
          key: "ArrowUp",
          modifiers: ["Alt", "Shift"],
          editorState: "both"
        }
      ]
    },
    {
      name: "move_node_down",
      callback: (view) => {
        moveNode(view, "down");
      },
      hotkeys: [
        { key: "J", modifiers: ["Alt", "Shift"], editorState: "both" },
        {
          key: "ArrowDown",
          modifiers: ["Alt", "Shift"],
          editorState: "both"
        }
      ]
    },
    {
      name: "move_node_right",
      callback: (view) => {
        moveNode(view, "right");
      },
      hotkeys: [
        { key: "L", modifiers: ["Alt", "Shift"], editorState: "both" },
        {
          key: "ArrowRight",
          modifiers: ["Alt", "Shift"],
          editorState: "both"
        }
      ]
    },
    {
      name: "move_node_left",
      callback: (view) => {
        moveNode(view, "left");
      },
      hotkeys: [
        { key: "H", modifiers: ["Alt", "Shift"], editorState: "both" },
        {
          key: "ArrowLeft",
          modifiers: ["Alt", "Shift"],
          editorState: "both"
        }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/merge-node.ts
var mergeNode = (view, direction) => {
  saveNodeContent(view);
  if (view.viewStore.getValue().document.selectedNodes.size > 1) {
    throw new Error(lang.error_hk_cant_merge_multiple_nodes);
  }
  view.documentStore.dispatch({
    type: "document/merge-node",
    payload: {
      direction,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/merge-commands.ts
var mergeCommands = () => {
  return [
    {
      name: "merge_with_node_above",
      callback: (view) => {
        mergeNode(view, "up");
      },
      hotkeys: [
        {
          key: "K",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        },
        {
          key: "ArrowUp",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "merge_with_node_below",
      callback: (view) => {
        mergeNode(view, "down");
      },
      hotkeys: [
        {
          key: "J",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        },
        {
          key: "ArrowDown",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/history-commands.ts
var historyCommands = () => {
  return [
    {
      name: "undo_change",
      callback: (view) => {
        view.documentStore.dispatch({
          type: "document/history/select-previous-snapshot"
        });
      },
      hotkeys: [
        {
          key: "Z",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "redo_change",
      callback: (view) => {
        view.documentStore.dispatch({
          type: "document/history/select-next-snapshot"
        });
      },
      hotkeys: [
        {
          key: "Y",
          modifiers: ["Mod"],
          editorState: "editor-off"
        },
        {
          key: "Z",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        }
      ]
    }
  ];
};

// src/lib/data-conversion/helpers/html-comment-marker/create-html-comment-marker.ts
var level = (parentNumber, index) => `${parentNumber ? parentNumber + "." : ""}${index}`;
var createHtmlCommentMarker = (parentNumber, index) => `
<!--section: ${level(parentNumber, index)}-->`;

// src/lib/data-conversion/json-to-x/json-to-html-comment.ts
var jsonToHtmlComment = (tree, parentNumber = "", text2 = "", includeStructure = true) => {
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    const content = node.content;
    const index = i + 1;
    if (text2)
      text2 = text2 + (includeStructure ? "\n" : "\n\n");
    if (includeStructure) {
      text2 += createHtmlCommentMarker(parentNumber, index) + "\n" + content;
    } else {
      text2 += content;
    }
    if (node.children.length > 0) {
      text2 = jsonToHtmlComment(
        node.children,
        level(parentNumber, index),
        text2,
        includeStructure
      );
    }
  }
  return text2;
};

// src/lib/data-conversion/branch-to-x/branch-to-html-comment.ts
var branchToHtmlComment = (branches) => {
  return jsonToHtmlComment(branchToJson(branches));
};

// src/lib/data-conversion/helpers/html-element-marker/collapsed-span-marker.ts
var expandedSpanMarker = (parentNumber, index) => `<span data-section="${level(parentNumber, index)}"></span>`;

// src/lib/data-conversion/json-to-x/json-to-html-element.ts
var jsonToHtmlElement = (tree, parentNumber = "", text2 = "") => {
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    const index = i + 1;
    if (text2)
      text2 = text2 + "\n\n";
    let content = node.content.trimStart();
    const expandedSpan = expandedSpanMarker(parentNumber, index);
    if (/^#+ /.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else if (/^#[^\s#\uFEFF\u200B]+/.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else if (content.startsWith(">")) {
      content = `${expandedSpan}
${content}`;
    } else if (/^[-*+]\s\[.\]\s/.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else if (/^[-*+]\s/.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else if (/^\d+\.\s/.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else if (content.startsWith("```")) {
      content = `${expandedSpan}
${content}`;
    } else if (content.startsWith("|")) {
      content = `${expandedSpan}

${content}`;
    } else if (/^!?\[\[/.test(content)) {
      content = `${expandedSpan}
${content}`;
    } else {
      content = `${expandedSpan}${content}`;
    }
    text2 += content;
    if (node.children.length > 0) {
      text2 = jsonToHtmlElement(
        node.children,
        level(parentNumber, index),
        text2
      );
    }
  }
  return text2;
};

// src/lib/data-conversion/branch-to-x/branch-to-html-element.ts
var branchToHtmlElement = (branches) => {
  return jsonToHtmlElement(branchToJson(branches));
};

// src/lib/data-conversion/json-to-x/json-to-text.ts
var jsonToText = (nodes) => {
  return jsonToHtmlComment(nodes, void 0, void 0, false);
};

// src/lib/data-conversion/branch-to-x/branch-to-text.ts
var branchToText = (branches) => {
  return jsonToText(branchToJson(branches));
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/map-branches-to-text.ts
var mapBranchesToText = (document2, nodes, format2) => {
  const branches = nodes.map(
    (node) => getBranch(document2.columns, document2.content, node, "copy")
  );
  const isSingleNode = nodes.length === 1 && Object.keys(branches[0].content).length === 1;
  if (isSingleNode) {
    return branches[0].content[nodes[0]].content;
  } else if (format2 === "outline") {
    return branchToOutline(branches);
  } else if (format2 === "html-element") {
    return branchToHtmlElement(branches);
  } else if (format2 === "sections") {
    return branchToHtmlComment(branches);
  } else if (format2 === "unformatted-text") {
    return branchToText(branches);
  } else {
    throw new Error(`Invalid format: ${format2}`);
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/get-active-nodes.ts
var getActiveNodes = (view, isInSidebar) => {
  const viewState = view.viewStore.getValue();
  const documentState = viewState.document;
  let activeNode = "";
  if (isInSidebar) {
    const activeSidebarTab = view.plugin.settings.getValue().view.leftSidebarActiveTab;
    if (activeSidebarTab === "recent-cards") {
      activeNode = viewState.recentNodes.activeNode;
    } else if (activeSidebarTab === "pinned-cards") {
      activeNode = viewState.pinnedNodes.activeNode;
    }
    return [activeNode];
  } else if (documentState.selectedNodes.size > 0) {
    return Array.from(documentState.selectedNodes);
  } else {
    return [documentState.activeNode];
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-active-branches-to-clipboard.ts
var copyActiveBranchesToClipboard = async (view, formatted, isInSidebar) => {
  const nodes = getActiveNodes(view, isInSidebar);
  const text2 = mapBranchesToText(
    view.documentStore.getValue().document,
    nodes,
    formatted ? getPersistedDocumentFormat(view) : "unformatted-text"
  );
  await navigator.clipboard.writeText(text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/cut-node.ts
var cutNode = async (view) => {
  const document2 = view.viewStore.getValue().document;
  await copyActiveBranchesToClipboard(view, true, false);
  view.documentStore.dispatch({
    type: "document/cut-node",
    payload: {
      nodeId: document2.activeNode,
      selectedNodes: document2.selectedNodes
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/paste-node.ts
var import_obsidian19 = require("obsidian");
var pasteNode = async (view) => {
  const viewState = view.viewStore.getValue();
  const clipboardItems = await navigator.clipboard.read();
  let containsImage = false;
  for (const item of clipboardItems) {
    if (item.types.some((type) => type.startsWith("image/"))) {
      containsImage = true;
      break;
    }
  }
  if (containsImage) {
    new import_obsidian19.Notice(lang.error_cant_paste);
  } else {
    const text2 = (await navigator.clipboard.readText()).replace(
      /\r\n/g,
      "\n"
    );
    view.documentStore.dispatch({
      type: "document/paste-node",
      payload: {
        targetNodeId: viewState.document.activeNode,
        text: text2
      }
    });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-active-nodes-to-clipboard.ts
var copyActiveNodesToClipboard = async (view, isInSidebar) => {
  const nodes = getActiveNodes(view, isInSidebar);
  await copyFlatNodesToClipboard(view, nodes);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/clipboard-commands.ts
var clipboardCommands = () => {
  return [
    {
      name: "copy_node",
      callback: async (view, event) => {
        const selectedText = activeWindow.getSelection()?.toString();
        if (selectedText && selectedText.length > 0) {
          return;
        }
        event.preventDefault();
        copyActiveBranchesToClipboard(view, true, false);
      },
      hotkeys: [
        { key: "C", modifiers: ["Mod"], editorState: "editor-off" }
      ]
    },
    {
      name: "copy_node_unformatted",
      callback: async (view, event) => {
        event.preventDefault();
        copyActiveBranchesToClipboard(view, false, false);
      },
      hotkeys: [
        {
          key: "C",
          modifiers: ["Mod", "Alt"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "copy_node_without_subitems",
      callback: async (view, event) => {
        event.preventDefault();
        copyActiveNodesToClipboard(view, false);
      },
      hotkeys: [
        {
          key: "C",
          modifiers: ["Mod", "Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "cut_node",
      callback: async (view, event) => {
        event.preventDefault();
        cutNode(view);
      },
      hotkeys: [
        { key: "X", modifiers: ["Mod"], editorState: "editor-off" }
      ]
    },
    {
      name: "paste_node",
      callback: async (view, event) => {
        event.preventDefault();
        pasteNode(view);
      },
      hotkeys: [
        {
          key: "V",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/selection-commands.ts
var selectionCommands = () => {
  const commands = [];
  commands.push(
    {
      name: "select_all_nodes",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "view/selection/select-all"
        });
      },
      hotkeys: [
        {
          key: "a",
          modifiers: ["Mod"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "extend_select_up",
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard",
          payload: {
            direction: "up"
          },
          context: {
            shiftKey: true,
            outlineMode: view.plugin.settings.getValue().view.outlineMode
          }
        });
      },
      hotkeys: [
        { key: "K", modifiers: ["Shift"], editorState: "editor-off" },
        {
          key: "ArrowUp",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "extend_select_down",
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard",
          payload: {
            direction: "down"
          },
          context: {
            shiftKey: true,
            outlineMode: view.plugin.settings.getValue().view.outlineMode
          }
        });
      },
      hotkeys: [
        { key: "J", modifiers: ["Shift"], editorState: "editor-off" },
        {
          key: "ArrowDown",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "extend_select_to_end_of_column",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard-jump",
          payload: {
            target: "end-of-column"
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        { key: "End", modifiers: ["Shift"], editorState: "editor-off" }
      ]
    },
    {
      name: "extend_select_to_start_of_column",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard-jump",
          payload: {
            target: "start-of-column"
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        {
          key: "Home",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "extend_select_to_end_of_group",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard-jump",
          payload: {
            target: "end-of-group"
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        {
          key: "PageDown",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    },
    {
      name: "extend_select_to_start_of_group",
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "view/set-active-node/keyboard-jump",
          payload: {
            target: "start-of-group"
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        {
          key: "PageUp",
          modifiers: ["Shift"],
          editorState: "editor-off"
        }
      ]
    }
  );
  return commands;
};

// src/lib/align-element/helpers/get-element-by-id.ts
var getElementById = (container, id2) => {
  if (id2)
    return container.querySelector("#" + id2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/scroll-node.ts
var scrollNode = (view, direction) => {
  const container = view.container;
  if (!container)
    return;
  const element2 = getElementById(
    container,
    view.viewStore.getValue().document.activeNode
  );
  if (!element2)
    return;
  const STEP = Math.floor(view.plugin.settings.getValue().view.cardWidth / 4);
  if (direction === "down" || direction === "up") {
    const column = element2.matchParent(".column");
    if (!column)
      return;
    const scrollTop = direction === "up" ? STEP : -STEP;
    requestAnimationFrame(() => {
      column.scrollBy({
        top: scrollTop,
        behavior: "smooth"
      });
    });
  } else {
    const scrollLeft = direction === "left" ? STEP : -STEP;
    requestAnimationFrame(() => {
      container.scrollBy({
        left: scrollLeft,
        behavior: "smooth"
      });
    });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/scroll-commands.ts
var scrollCommands = () => {
  const modifiers = ["Mod", "Alt"];
  return [
    {
      name: "scroll_right",
      callback: (view) => {
        scrollNode(view, "right");
      },
      hotkeys: [{ key: "L", modifiers, editorState: "both" }]
    },
    {
      name: "scroll_left",
      callback: (view) => {
        scrollNode(view, "left");
      },
      hotkeys: [{ key: "H", modifiers, editorState: "both" }]
    },
    {
      name: "scroll_up",
      callback: (view) => {
        scrollNode(view, "up");
      },
      hotkeys: [{ key: "K", modifiers, editorState: "both" }]
    },
    {
      name: "scroll_down",
      callback: (view) => {
        scrollNode(view, "down");
      },
      hotkeys: [{ key: "J", modifiers, editorState: "both" }]
    },
    {
      name: "align_branch",
      callback: (view) => {
        view.alignBranch.align({
          type: "view/align-branch/center-node"
        });
      },
      hotkeys: [{ key: "G", modifiers, editorState: "both" }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/default-view-hotkeys.ts
var defaultViewHotkeys = () => [
  ...navigateCommands(),
  ...editCommands(),
  ...createCommands(),
  ...moveCommands(),
  ...mergeCommands(),
  ...clipboardCommands(),
  ...historyCommands(),
  ...selectionCommands(),
  ...scrollCommands(),
  {
    name: "delete_card",
    callback: (view, e) => {
      const document2 = view.viewStore.getValue().document;
      e.preventDefault();
      e.stopPropagation();
      deleteNode(view, document2.activeNode, true);
    },
    hotkeys: [
      { key: "Backspace", modifiers: ["Mod"], editorState: "editor-off" }
    ]
  },
  {
    name: "toggle_search_input",
    callback: (view, e) => {
      e.preventDefault();
      e.stopPropagation();
      view.viewStore.dispatch({ type: "view/search/toggle-input" });
    },
    hotkeys: [
      { key: "/", modifiers: [], editorState: "editor-off" },
      { key: "f", modifiers: ["Alt"], editorState: "both" }
    ]
  },
  {
    name: "zoom_in",
    callback: (view, e) => {
      e.preventDefault();
      view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { direction: "in" }
      });
    },
    hotkeys: [{ key: "=", modifiers: ["Mod"], editorState: "both" }]
  },
  {
    name: "zoom_out",
    callback: (view, e) => {
      e.preventDefault();
      view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { direction: "out" }
      });
    },
    hotkeys: [{ key: "-", modifiers: ["Mod"], editorState: "both" }]
  },
  {
    name: "zoom_reset",
    callback: (view, e) => {
      e.preventDefault();
      view.plugin.settings.dispatch({
        type: "settings/view/set-zoom-level",
        payload: { value: 1 }
      });
    },
    hotkeys: [{ key: "0", modifiers: ["Mod"], editorState: "both" }]
  },
  {
    name: "toggle_outline_mode",
    callback: (view) => {
      view.plugin.settings.dispatch({
        type: "settings/view/modes/toggle-outline-mode"
      });
    },
    hotkeys: [{ key: "o", modifiers: ["Alt"], editorState: "both" }]
  },
  {
    name: "toggle_collapse",
    callback: (view, e) => {
      e.preventDefault();
      if (!get_store_value(singleColumnStore(view)))
        return;
      view.viewStore.dispatch({
        type: "view/outline/toggle-collapse-node",
        payload: {
          id: view.viewStore.getValue().document.activeNode
        }
      });
    },
    hotkeys: [{ key: "=", modifiers: ["Alt"], editorState: "both" }]
  },
  {
    name: "toggle_collapse_all",
    callback: (view, e) => {
      e.preventDefault();
      if (!get_store_value(singleColumnStore(view)))
        return;
      view.viewStore.dispatch({
        type: "view/outline/toggle-collapse-all"
      });
    },
    hotkeys: [{ key: "=", modifiers: ["Alt", "Mod"], editorState: "both" }]
  }
];

// src/lang/hotkey-groups.ts
var hotkeyGroups = {
  [lang.hkg_create_nodes]: /* @__PURE__ */ new Set([
    "add_child",
    "add_below",
    "add_above",
    "add_parent_sibling",
    "add_child_and_split",
    "add_below_and_split",
    "add_above_and_split"
  ]),
  [lang.hkg_edit_nodes]: /* @__PURE__ */ new Set([
    "enable_edit_mode",
    "enable_edit_mode_and_place_cursor_at_start",
    "enable_edit_mode_and_place_cursor_at_end",
    "disable_edit_mode",
    "save_changes_and_exit_card"
  ]),
  [lang.hkg_move_nodes]: /* @__PURE__ */ new Set([
    "move_node_up",
    "move_node_down",
    "move_node_right",
    "move_node_left"
  ]),
  [lang.hkg_merge_nodes]: /* @__PURE__ */ new Set([
    "merge_with_node_above",
    "merge_with_node_below"
  ]),
  [lang.hkg_delete_nodes]: /* @__PURE__ */ new Set(["delete_card"]),
  [lang.hkg_navigation]: /* @__PURE__ */ new Set([
    "go_up",
    "go_down",
    "go_right",
    "go_left",
    "go_to_beginning_of_group",
    "go_to_end_of_group",
    "go_to_beginning_of_column",
    "go_to_end_of_column",
    "navigate_back",
    "navigate_forward",
    "navigate_to_previous_node",
    "navigate_to_next_node",
    "select_parent"
  ]),
  [lang.hkg_selection]: /* @__PURE__ */ new Set([
    "extend_select_up",
    "extend_select_down",
    "extend_select_to_start_of_group",
    "extend_select_to_end_of_group",
    "extend_select_to_start_of_column",
    "extend_select_to_end_of_column",
    "select_all_nodes"
  ]),
  [lang.hkg_history]: /* @__PURE__ */ new Set(["undo_change", "redo_change"]),
  [lang.hkg_search]: /* @__PURE__ */ new Set(["toggle_search_input"]),
  [lang.hkg_clipboard]: /* @__PURE__ */ new Set([
    "copy_node",
    "copy_node_unformatted",
    "copy_node_without_subitems",
    "cut_node",
    "paste_node"
  ]),
  [lang.hkg_scrolling]: /* @__PURE__ */ new Set([
    "scroll_left",
    "scroll_right",
    "scroll_up",
    "scroll_down",
    "align_branch"
  ]),
  [lang.hkg_zoom]: /* @__PURE__ */ new Set(["zoom_in", "zoom_out", "zoom_reset"]),
  [lang.hkg_outline]: /* @__PURE__ */ new Set([
    "toggle_outline_mode",
    "toggle_collapse",
    "toggle_collapse_all"
  ])
};
var hotkeysGroups = Object.fromEntries(
  Object.entries(hotkeyGroups).map(([group, commands]) => Array.from(commands).map((c) => [c, group])).flat()
);

// src/stores/view/derived/hotkeys-store.ts
var ConflictingHotkeys = (view) => derived2(view.viewStore, (state2) => state2.hotkeys.conflictingHotkeys);
var HotkeysSearchTerm = (view) => derived2(view.viewStore, (state2) => state2.hotkeys.searchTerm);

// src/helpers/array-helpers/group-array-by-property.ts
var groupArrayByProperty = (array, property, grouped = {}) => {
  for (const item of array) {
    const key = String(item[property]);
    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(item);
  }
  for (const key of Object.keys(grouped)) {
    if (grouped[key].length === 0) {
      delete grouped[key];
    }
  }
  return grouped;
};

// src/stores/settings/derived/view-hotkeys-store.ts
var CustomHotkeysStore = (plugin) => derived(plugin.settings, (state2) => state2.hotkeys.customHotkeys);
var ViewHotkeysStore = (plugin) => derived([CustomHotkeysStore(plugin)], ([customHotkeys]) => {
  const viewHotkeys2 = [];
  for (const defaultViewHotkey of defaultViewHotkeys()) {
    const customHotkey = customHotkeys[defaultViewHotkey.name];
    const hotkeys = defaultViewHotkey.hotkeys.map(
      (hotkey, i) => {
        let isCustom = false;
        const persistedHotkey = i === 0 && customHotkey?.primary ? customHotkey.primary : i === 1 && customHotkey?.secondary ? customHotkey?.secondary : null;
        if (persistedHotkey) {
          if ("key" in persistedHotkey) {
            isCustom = persistedHotkey.key.length > 0 && (hotkey.key !== persistedHotkey.key || hotkey.modifiers.join("") !== persistedHotkey.modifiers.join(""));
            hotkey.key = persistedHotkey.key;
            hotkey.modifiers = persistedHotkey.modifiers;
          }
          if ("editorState" in persistedHotkey) {
            isCustom = persistedHotkey.editorState !== hotkey.editorState;
            hotkey.editorState = persistedHotkey.editorState;
          }
        }
        return {
          ...hotkey,
          string_representation: hotkeyToString(hotkey),
          isCustom
        };
      }
    );
    viewHotkeys2.push({
      ...defaultViewHotkey,
      hotkeys,
      group: hotkeysGroups[defaultViewHotkey.name]
    });
  }
  return viewHotkeys2;
});
var ConflictLabeledHotkeysStore = (view) => derived(
  [ViewHotkeysStore(view.plugin), ConflictingHotkeys(view)],
  ([hotkeys, conflicts]) => {
    let numberOfConflictingHotkeys = 0;
    const groupedByHotkey = /* @__PURE__ */ new Map();
    for (const viewHotkey of hotkeys) {
      for (const hotkey of viewHotkey.hotkeys) {
        delete hotkey.obsidianConflict;
        delete hotkey.pluginConflict;
        const conflict = conflicts.get(
          hotkey.string_representation
        );
        if (conflict) {
          hotkey.obsidianConflict = conflict;
          numberOfConflictingHotkeys++;
        } else {
          let set = groupedByHotkey.get(
            hotkey.string_representation
          );
          if (!set) {
            set = /* @__PURE__ */ new Set();
            groupedByHotkey.set(
              hotkey.string_representation,
              set
            );
          }
          set.add(viewHotkey);
        }
      }
    }
    const conflicting = [...groupedByHotkey.entries()].filter(
      (v) => v[1].size > 1
    );
    for (const [string_representation, hotkeys2] of conflicting) {
      const conflicting2 = Array.from(hotkeys2).map((h) => h.name).join(", ");
      for (const pluginHotkey of hotkeys2) {
        for (const hotkey of pluginHotkey.hotkeys) {
          if (!hotkey.key)
            continue;
          if (hotkey.string_representation === string_representation) {
            hotkey.pluginConflict = conflicting2;
            numberOfConflictingHotkeys++;
          }
        }
      }
    }
    return {
      hotkeys: [...hotkeys],
      numberOfConflictingHotkeys
    };
  }
);
var FilteredHotkeysStore = (view) => derived(
  [
    ConflictLabeledHotkeysStore(view),
    HotkeysSearchTerm(view),
    OutlineModeStore(view)
  ],
  ([hotkeys, searchTerm, outlineMode]) => {
    let array = [];
    if (searchTerm) {
      array = hotkeys.hotkeys.filter((c) => {
        const fullName = getDynamicLabel(
          c.name,
          outlineMode
        ).toLowerCase();
        return fullName.includes(searchTerm) || c.group.toLowerCase().includes(searchTerm);
      });
    } else
      array = hotkeys.hotkeys;
    return {
      hotkeys: groupArrayByProperty(array, "group", {
        [lang.hkg_create_nodes]: [],
        [lang.hkg_edit_nodes]: [],
        [lang.hkg_move_nodes]: [],
        [lang.hkg_merge_nodes]: [],
        [lang.hkg_delete_nodes]: [],
        [lang.hkg_clipboard]: [],
        [lang.hkg_navigation]: [],
        [lang.hkg_selection]: [],
        [lang.hkg_scrolling]: [],
        [lang.hkg_history]: [],
        [lang.hkg_search]: [],
        [lang.hkg_zoom]: [],
        [lang.hkg_outline]: []
      }),
      numberOfConflictingHotkeys: hotkeys.numberOfConflictingHotkeys
    };
  }
);

// src/view/components/container/modals/hotkeys/hotkeys.svelte
function add_css35(target) {
  append_styles(target, "svelte-1kffelc", ".groups.svelte-1kffelc{width:500px;display:flex;flex-direction:column;gap:var(--size-4-2);overflow-y:auto;flex:1\n    }@media(max-width: 720px){.groups.svelte-1kffelc{width:fit-content}}");
}
function get_each_context14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  return child_ctx;
}
function create_each_block14(key_1, ctx) {
  let first;
  let group_1;
  let current;
  group_1 = new group_default2({
    props: {
      groupName: (
        /*groupName*/
        ctx[6]
      ),
      group: (
        /*group*/
        ctx[7]
      ),
      labelState: (
        /*labelState*/
        ctx[0]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(group_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const group_1_changes = {};
      if (dirty & /*$store*/
      2)
        group_1_changes.groupName = /*groupName*/
        ctx[6];
      if (dirty & /*$store*/
      2)
        group_1_changes.group = /*group*/
        ctx[7];
      if (dirty & /*labelState*/
      1)
        group_1_changes.labelState = /*labelState*/
        ctx[0];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(group_1, detaching);
    }
  };
}
function create_fragment97(ctx) {
  let div1;
  let front;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let numberofconflicts;
  let current;
  front = new front_default({});
  let each_value = ensure_array_like(Object.entries(
    /*$store*/
    ctx[1].hotkeys
  ));
  const get_key = (ctx2) => (
    /*groupName*/
    ctx2[6]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context14(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block14(key, child_ctx));
  }
  numberofconflicts = new status_bar_default({
    props: {
      conflicts: (
        /*$store*/
        ctx[1].numberOfConflictingHotkeys
      )
    }
  });
  return {
    c() {
      div1 = element("div");
      create_component(front.$$.fragment);
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(numberofconflicts.$$.fragment);
      attr(div0, "class", "groups svelte-1kffelc");
      attr(div1, "class", "lineage-modal lineage-modal--full-height");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(front, div1, null);
      append(div1, t0);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div1, t1);
      mount_component(numberofconflicts, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, $store, labelState*/
      3) {
        each_value = ensure_array_like(Object.entries(
          /*$store*/
          ctx2[1].hotkeys
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block14, null, get_each_context14);
        check_outros();
      }
      const numberofconflicts_changes = {};
      if (dirty & /*$store*/
      2)
        numberofconflicts_changes.conflicts = /*$store*/
        ctx2[1].numberOfConflictingHotkeys;
      numberofconflicts.$set(numberofconflicts_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(front.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(numberofconflicts.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(front.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(numberofconflicts.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(front);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(numberofconflicts);
    }
  };
}
function instance95($$self, $$props, $$invalidate) {
  let $outlineMode;
  let $store;
  const view = getView();
  const store = FilteredHotkeysStore(view);
  component_subscribe($$self, store, (value) => $$invalidate(1, $store = value));
  const outlineMode = OutlineModeStore(view);
  component_subscribe($$self, outlineMode, (value) => $$invalidate(4, $outlineMode = value));
  let labelState;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$outlineMode*/
    16) {
      $: {
        $$invalidate(0, labelState = { outlineMode: $outlineMode });
      }
    }
  };
  return [labelState, $store, store, outlineMode, $outlineMode];
}
var Hotkeys = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance95, create_fragment97, safe_not_equal, {}, add_css35);
  }
};
var hotkeys_default = Hotkeys;

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/event-to-string.ts
var eventToString = (event) => {
  let string = event.key.toUpperCase();
  if (event.altKey)
    string += "Alt" /* Alt */;
  if (isMacLike) {
    if (event.ctrlKey)
      string += "Ctrl" /* Ctrl */;
    if (event.metaKey)
      string += "Mod" /* Mod */;
  } else {
    if (event.ctrlKey)
      string += "Mod" /* Mod */;
  }
  if (event.shiftKey)
    string += "Shift" /* Shift */;
  return string;
};

// src/view/actions/on-escape/helpers/handle-escape-key.ts
var handleEscapeKey = (view) => {
  const viewStore = view.viewStore;
  const value = viewStore.getValue();
  const search2 = value.search;
  const controls = value.ui.controls;
  const selection = value.document.selectedNodes;
  if (controls.showHelpSidebar || controls.showHistorySidebar || controls.showSettingsSidebar || controls.showStyleRulesModal) {
    viewStore.dispatch({
      type: "view/close-modals",
      payload: {
        closeAllModals: true
      }
    });
    return true;
  } else if (value.document.pendingConfirmation.deleteNode.size > 0) {
    viewStore.dispatch({
      type: "view/delete-node/reset-confirmation"
    });
    return true;
  } else if (selection.size > 0) {
    viewStore.dispatch({
      type: "view/selection/clear-selection"
    });
    return true;
  } else if (search2.query) {
    viewStore.dispatch({
      type: "view/search/set-query",
      payload: {
        query: ""
      }
    });
    return true;
  } else if (search2.showInput) {
    viewStore.dispatch({
      type: "view/search/toggle-input"
    });
    return true;
  }
};

// src/lib/errors/errors.ts
var SilentError = class extends Error {
};

// src/lib/store/on-plugin-error.ts
var import_obsidian20 = require("obsidian");

// src/helpers/logger.ts
var __dev__ = false;
var createLogger = () => {
  const debug = (...message) => {
    if (__dev__) {
      console.log(`[DEBUG]: `, ...message);
    }
  };
  const info = (...message) => {
    if (__dev__) {
      console.log(`[INFO]: `, ...message);
    }
  };
  const warn = (...message) => {
    if (__dev__) {
      console.warn(`[WARN]: `, ...message);
    }
  };
  const error = (...message) => {
    console.error(`[ERROR]: `, ...message);
  };
  return { debug, info, warn, error };
};
var logger = createLogger();

// src/lib/store/on-plugin-error.ts
var onPluginError = (error, location, action) => {
  if (error instanceof SilentError && !__dev__) {
    return;
  }
  console.error(`[${location}] action: `, action);
  console.error(`[${location}]`, error);
  const message = error.message.replace(/Invariant failed(: )?/, "");
  if (message)
    new import_obsidian20.Notice(message);
  else
    new import_obsidian20.Notice(lang.error_generic);
};

// src/view/actions/keyboard-shortcuts/view-hotkeys-action.ts
var viewHotkeysAction = (target, {
  view
}) => {
  const state2 = {
    shift: false
  };
  const keyboardEventHandler = (event) => {
    if (event.key === "Escape") {
      const contain = handleEscapeKey(view);
      if (contain)
        return;
    }
    if (event.target.localName === "input")
      return;
    const command = viewHotkeys.current[eventToString(event)];
    if (command) {
      const allow = command.editorState === "editor-on" ? isEditing(view) : command.editorState === "editor-off" ? !isEditing(view) : true;
      if (allow) {
        try {
          command.callback(view, event);
        } catch (error) {
          onPluginError(error, "command", command);
        }
      }
    }
    if (event.shiftKey !== state2.shift) {
      state2.shift = event.shiftKey;
      view.viewStore.dispatch({
        type: event.shiftKey ? "view/keyboard/shift/down" : "view/keyboard/shift/up"
      });
    }
  };
  const onKeyup = (event) => {
    if (event.shiftKey !== state2.shift) {
      state2.shift = event.shiftKey;
      view.viewStore.dispatch({
        type: event.shiftKey ? "view/keyboard/shift/down" : "view/keyboard/shift/up"
      });
    }
  };
  target.addEventListener("keydown", keyboardEventHandler);
  target.addEventListener("keyup", onKeyup);
  return {
    destroy: () => {
      target.removeEventListener("keydown", keyboardEventHandler);
      target.removeEventListener("keyup", onKeyup);
    }
  };
};

// src/view/actions/mouse-wheel-zoom.ts
var mouseWheelZoom = (element2, view) => {
  const listener = (e) => {
    const modKey2 = isMacLike ? e.metaKey : e.ctrlKey;
    if (!modKey2)
      return;
    const delta = e.deltaY;
    view.plugin.settings.dispatch({
      type: "settings/view/set-zoom-level",
      payload: {
        direction: delta < 0 ? "in" : "out"
      }
    });
  };
  element2.addEventListener("wheel", listener);
  return {
    destroy: () => {
      element2.removeEventListener("wheel", listener);
    }
  };
};

// src/stores/minimap/subscriptions/effects/minimap-canvas/worker/consts/constants.ts
var CANVAS_WIDTH_DPX = 176;
var CANVAS_WIDTH_CPX = CANVAS_WIDTH_DPX * 2;
var CHAR_WIDTH_CPX = 6;
var LINE_HEIGHT_CPX = 10;
var N_CHARS_PER_LINE = CANVAS_WIDTH_CPX / CHAR_WIDTH_CPX;
var INDENT_BLOCK_WIDTH_CPX = CHAR_WIDTH_CPX;
var INDENT_BLOCK_SPACE_WIDTH_CPX = CHAR_WIDTH_CPX;
var INDENT_BLOCK_TOTAL_WIDTH_CPX = INDENT_BLOCK_WIDTH_CPX + INDENT_BLOCK_SPACE_WIDTH_CPX;

// src/view/components/container/minimap/event-handlers/helpers/find-card-at-position.ts
var findCardAtPosition = (y, ranges, margin = LINE_HEIGHT_CPX) => {
  const result = Object.values(ranges).find(
    (range) => y >= range.y_start - margin && y <= range.y_end + margin
  );
  return result?.cardId;
};

// src/view/components/container/minimap/event-handlers/on-canvas-click.ts
var dpx_to_cpx = (px) => px * (CANVAS_WIDTH_CPX / CANVAS_WIDTH_DPX);
var cpx_to_dpx = (px) => px * (CANVAS_WIDTH_DPX / CANVAS_WIDTH_CPX);
var LINE_HEIGHT_DPX = cpx_to_dpx(LINE_HEIGHT_CPX);
var onCanvasClick = (e, view) => {
  const minimapStore = view.getMinimapStore();
  const dom = view.getMinimapDom();
  const rect = dom.canvasContainer.getBoundingClientRect();
  const domY = e.clientY - rect.top;
  const minimapState = minimapStore.getValue();
  const y = dpx_to_cpx(domY);
  const ranges = minimapState.ranges.cards;
  const cardId = findCardAtPosition(y, ranges);
  if (cardId) {
    view.viewStore.dispatch({
      type: "view/set-active-node/mouse",
      payload: {
        id: cardId
      }
    });
    focusContainer(view);
  }
};

// src/stores/minimap/derived/minimap-ranges.ts
var MinimapRangesStore = (view) => derived2(view.getMinimapStore(), (state2) => state2.ranges.cards);

// src/view/components/container/minimap/components/indicators.svelte
function add_css36(target) {
  append_styles(target, "svelte-1be7f7d", ".active-card-indicator.svelte-1be7f7d{left:-3px;width:180px;position:absolute;background-color:var(--color-base-70);opacity:0.3;mix-blend-mode:lighten}.search-result-indicator.svelte-1be7f7d{left:-3px;width:180px;position:absolute;background-color:var(--color-yellow);opacity:0.3}");
}
function get_each_context15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block15(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "search-result-indicator svelte-1be7f7d");
      attr(div, "style", div_style_value = `top:${/*searchResultRange*/
      ctx[8].y_start}px; height:${/*searchResultRange*/
      ctx[8].height}px`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$searchResultsRanges*/
      2 && div_style_value !== (div_style_value = `top:${/*searchResultRange*/
      ctx2[8].y_start}px; height:${/*searchResultRange*/
      ctx2[8].height}px`)) {
        attr(div, "style", div_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment98(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let t;
  let each_value = ensure_array_like(
    /*$searchResultsRanges*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block15(get_each_context15(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "active-card-indicator svelte-1be7f7d");
      attr(div0, "style", div0_style_value = `top:${/*$activeCardRange*/
      ctx[0].y_start}px; height:${/*$activeCardRange*/
      ctx[0].height}px`);
      attr(div1, "id", "indicators-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$activeCardRange*/
      1 && div0_style_value !== (div0_style_value = `top:${/*$activeCardRange*/
      ctx2[0].y_start}px; height:${/*$activeCardRange*/
      ctx2[0].height}px`)) {
        attr(div0, "style", div0_style_value);
      }
      if (dirty & /*$searchResultsRanges*/
      2) {
        each_value = ensure_array_like(
          /*$searchResultsRanges*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block15(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance96($$self, $$props, $$invalidate) {
  let $activeCardRange;
  let $searchResultsRanges;
  const view = getView();
  const activeCard = activeNodeStore(view);
  const searchResults = searchStore(view);
  const ranges = MinimapRangesStore(view);
  const activeCardRange = derived([activeCard, ranges], ([activeCard2, ranges2]) => {
    if (activeCard2) {
      const range = ranges2 === null || ranges2 === void 0 ? void 0 : ranges2[activeCard2];
      if (range) {
        const y_start = cpx_to_dpx(range.y_start);
        const y_end = cpx_to_dpx(range.y_end);
        return {
          y_start: y_start + 2 - LINE_HEIGHT_DPX,
          height: LINE_HEIGHT_DPX + (y_end - y_start) - 1
        };
      }
    }
    return { y_start: 0, height: 0 };
  });
  component_subscribe($$self, activeCardRange, (value) => $$invalidate(0, $activeCardRange = value));
  const searchResultsRanges = derived([searchResults, ranges], ([searchResults2, ranges2]) => {
    if (searchResults2) {
      const searchResultsRanges2 = Array.from(searchResults2.results.keys()).map((searchResult) => {
        const range = ranges2 === null || ranges2 === void 0 ? void 0 : ranges2[searchResult];
        if (range) {
          const y_start = cpx_to_dpx(range.y_start);
          const y_end = cpx_to_dpx(range.y_end);
          return {
            y_start: y_start + 2 - LINE_HEIGHT_DPX,
            height: LINE_HEIGHT_DPX + (y_end - y_start) - 1
          };
        }
      }).filter((x) => x);
      return searchResultsRanges2;
    }
    return [];
  });
  component_subscribe($$self, searchResultsRanges, (value) => $$invalidate(1, $searchResultsRanges = value));
  return [$activeCardRange, $searchResultsRanges, activeCardRange, searchResultsRanges];
}
var Indicators = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance96, create_fragment98, safe_not_equal, {}, add_css36);
  }
};
var indicators_default = Indicators;

// src/view/components/container/minimap/event-handlers/on-canvas-wheel.ts
var onCanvasWheel = (e, view) => {
  e.preventDefault();
  view.getMinimapStore().dispatch({
    type: "minimap/mouse-wheel-scroll",
    payload: {
      delta_y_dpx: e.deltaY
    }
  });
};

// src/view/components/container/minimap/event-handlers/create-on-canvas-mousemove.ts
var import_obsidian21 = require("obsidian");
var createOnCanvasMousemove = (view) => {
  let lastActiveCardId = null;
  let minimapStore;
  let dom;
  const hoverHandler = (0, import_obsidian21.debounce)((e) => {
    if (!(e.buttons === 1 || (isMacLike ? e.metaKey : e.ctrlKey)))
      return;
    if (!minimapStore) {
      minimapStore = view.getMinimapStore();
      dom = view.getMinimapDom();
    }
    const rect = dom.canvas.getBoundingClientRect();
    const domY = e.clientY - rect.top;
    const y = dpx_to_cpx(domY);
    const ranges = minimapStore.getValue().ranges.cards;
    const cardId = findCardAtPosition(y, ranges, 0);
    if (cardId && cardId !== lastActiveCardId) {
      lastActiveCardId = cardId;
      view.viewStore.dispatch({
        type: "view/set-active-node/mouse",
        payload: {
          id: cardId
        }
      });
      focusContainer(view);
    }
  }, 100);
  return (e) => hoverHandler(e);
};

// src/lib/store/store.ts
var NO_UPDATE = Symbol("NO_UPDATE");
var Store = class {
  constructor(initialValue, reducer, onError, context) {
    this.subscribers = /* @__PURE__ */ new Set();
    this.isProcessing = false;
    this.actionQueue = [];
    this.reducer = () => this.value;
    // eslint-disable-next-line no-console
    this.onError = (error) => console.error(error);
    this.setContext = (context) => {
      this.context = context;
    };
    this.value = initialValue;
    if (reducer)
      this.reducer = reducer;
    if (onError)
      this.onError = onError;
    if (context)
      this.context = context;
  }
  getValue() {
    return this.value;
  }
  dispatch(action) {
    this.actionQueue.push(action);
    if (!this.isProcessing) {
      this.processActionQueue();
    }
  }
  set(value) {
    this.value = value;
    this.notifySubscribers();
  }
  subscribe(run2) {
    this.subscribers.add(run2);
    try {
      run2(this.value, void 0, true);
    } catch (error) {
      this.onError(error, "subscriber");
    }
    return () => {
      this.subscribers.delete(run2);
    };
  }
  update(updater) {
    this.value = updater(this.value);
    this.notifySubscribers();
  }
  processActionQueue() {
    this.isProcessing = true;
    while (this.actionQueue.length > 0) {
      const action = this.actionQueue.shift();
      try {
        const newValue = this.reducer(
          this.value,
          action,
          this.context
        );
        if (newValue !== NO_UPDATE) {
          this.value = newValue;
          this.notifySubscribers(action);
        }
      } catch (error) {
        this.onError(error, "reducer", action);
      }
    }
    this.isProcessing = false;
  }
  notifySubscribers(action) {
    for (const subscriber of this.subscribers) {
      try {
        subscriber(this.value, action);
      } catch (error) {
        this.onError(error, "subscriber", action);
      }
    }
  }
};

// src/stores/minimap/default-minimap-state.ts
var defaultMinimapState = () => ({
  canvasId: id.canvas(),
  activeCardId: "",
  scrollbar: {
    totalDrawnHeight_cpx: 0,
    scrollPosition_cpx: 0,
    containerHeight_cpx: 0
  },
  ranges: {
    cards: {}
  }
});

// src/stores/minimap/reducers/update-scroll-position.ts
var updateScrollPosition = (state2, delta_y_dpx) => {
  const delta_y_cpx = dpx_to_cpx(delta_y_dpx);
  if (state2.scrollbar.containerHeight_cpx === 0)
    return;
  state2.scrollbar.scrollPosition_cpx = Math.max(
    0,
    Math.min(
      state2.scrollbar.totalDrawnHeight_cpx - state2.scrollbar.containerHeight_cpx,
      state2.scrollbar.scrollPosition_cpx + delta_y_cpx
    )
  );
};

// src/stores/minimap/subscriptions/actions/set-scrollbar-position/calculate-scroll-delta-to-active-card.ts
var calculateScrollDeltaToActiveCard = (y_start_cpx, y_end_cpx, totalDrawnHeight_cpx, scrollPosition_cpx, containerHeight_cpx) => {
  const contentFitsContainer = totalDrawnHeight_cpx <= containerHeight_cpx;
  if (contentFitsContainer) {
    return null;
  }
  const currentScroll_cpx = scrollPosition_cpx;
  const visibleStart_cpx = currentScroll_cpx;
  const visibleEnd_cpx = currentScroll_cpx + containerHeight_cpx;
  const startIsVisible = y_start_cpx > visibleStart_cpx && y_start_cpx < visibleEnd_cpx;
  const endIsVisible = y_end_cpx > visibleStart_cpx && y_end_cpx < visibleEnd_cpx;
  if (startIsVisible && endIsVisible) {
    return null;
  }
  let newScroll_cpx = 0;
  const range_height_cpx = y_end_cpx - y_start_cpx;
  const rangeIsTallerThanContainer = range_height_cpx > containerHeight_cpx;
  if (rangeIsTallerThanContainer) {
    newScroll_cpx = y_start_cpx;
  } else {
    if (!startIsVisible) {
      newScroll_cpx = y_start_cpx - 10;
    } else if (!endIsVisible) {
      newScroll_cpx = y_end_cpx - containerHeight_cpx + 10;
    }
  }
  const maxScroll_cpx = totalDrawnHeight_cpx - containerHeight_cpx;
  newScroll_cpx = Math.max(0, Math.min(newScroll_cpx, maxScroll_cpx));
  return newScroll_cpx;
};

// src/stores/minimap/reducers/derive-scroll-position.ts
var deriveScrollPosition = (state2) => {
  const activeCardRange = state2.ranges.cards[state2.activeCardId];
  if (!activeCardRange)
    return;
  const delta_cpx = calculateScrollDeltaToActiveCard(
    activeCardRange.y_start,
    activeCardRange.y_end,
    state2.scrollbar.totalDrawnHeight_cpx,
    state2.scrollbar.scrollPosition_cpx,
    state2.scrollbar.containerHeight_cpx
  );
  if (typeof delta_cpx === "number") {
    state2.scrollbar.scrollPosition_cpx = delta_cpx;
  }
};

// src/stores/minimap/minimap-reducer.ts
var updateDocumentState = (state2, action) => {
  if (action.type === "minimap/set-card-ranges") {
    state2.ranges.cards = action.payload.ranges;
    const newDocumentHeight = state2.scrollbar.totalDrawnHeight_cpx !== action.payload.height_cpx;
    if (newDocumentHeight) {
      state2.scrollbar.scrollPosition_cpx = 0;
    }
    state2.scrollbar.totalDrawnHeight_cpx = action.payload.height_cpx;
    deriveScrollPosition(state2);
  } else if (action.type === "minimap/set-active-node") {
    state2.activeCardId = action.payload.id;
    deriveScrollPosition(state2);
  } else if (action.type === "minimap/set-container-height") {
    state2.scrollbar.containerHeight_cpx = action.payload.height_cpx;
    deriveScrollPosition(state2);
  } else if (action.type === "minimap/mouse-wheel-scroll") {
    updateScrollPosition(state2, action.payload.delta_y_dpx);
  }
};
var minimapReducer = (store, action) => {
  updateDocumentState(store, action);
  return store;
};

// src/stores/minimap/subscriptions/effects/minimap-canvas/worker/shapes/helpers/chunk-positions-cache.ts
var ChunkPositionsCache = class {
  constructor() {
    this.caches = {};
    this.getCachedResult = (canvasId, nodeId, content, availableLineCharacters) => {
      const cache = this.caches[canvasId];
      if (!cache)
        return;
      const cached = cache.get(nodeId);
      if (cached) {
        const valid = cached.availableLineCharacters === availableLineCharacters && cached.content === content;
        if (valid) {
          return cached.result;
        } else {
          cache.delete(nodeId);
        }
      }
    };
    this.cacheResult = (canvasId, nodeId, content, availableLineCharacters, result) => {
      if (!this.caches[canvasId]) {
        this.caches[canvasId] = /* @__PURE__ */ new Map();
      }
      const cache = this.caches[canvasId];
      cache.set(nodeId, { availableLineCharacters, content, result });
    };
    this.deleteCanvasCache = (canvasId) => {
      delete this.caches[canvasId];
    };
  }
};
var chunkPositionsCache = new ChunkPositionsCache();

// src/stores/minimap/subscriptions/effects/minimap-canvas/worker/consts/minimap-theme.ts
var themes = {
  dark: {
    isLightTheme: false,
    card_active: "#a9a9a9a",
    card_searchResult: "#e0de7177",
    wordBlock: "#99999966",
    indentLine: "#ffffff55",
    chars: {
      ["highlight" /* highlight */]: "#e0de7177",
      // brighter yellow
      ["wikilink" /* wikilink */]: "#027aff77",
      // brighter blue
      ["bold_italic" /* bold_italic */]: "#fb464c66",
      // brighter red
      ["heading" /* heading */]: "#44cf6e77",
      // brighter green
      ["bullet" /* bullet */]: "#E3BFD466",
      // brighter pink
      ["tag" /* tag */]: "#e9973f77",
      // brighter orange
      ["period" /* period */]: "#ffffff88",
      // white
      ["strikethrough" /* strikethrough */]: "#a882ff66",
      // brighter purple
      ["task" /* task */]: "#17e7e077",
      // brighter cyan
      ["comma" /* comma */]: "#17e7e088"
      // white
    }
  },
  light: {
    isLightTheme: true,
    wordBlock: "#70707088",
    card_active: "#aaaaaa",
    card_searchResult: "#e0ac0077",
    indentLine: "#777777aa",
    chars: {
      ["highlight" /* highlight */]: "#e0ac0077",
      // brighter yellow
      ["wikilink" /* wikilink */]: "#086ddd77",
      // brighter blue
      ["bold_italic" /* bold_italic */]: "#e9314777",
      // brighter red
      ["heading" /* heading */]: "#08b94e77",
      // brighter green
      ["bullet" /* bullet */]: "#E77EB277",
      // brighter pink
      ["tag" /* tag */]: "#ec750077",
      // brighter orange
      ["period" /* period */]: "#777777ee",
      // original gray
      ["strikethrough" /* strikethrough */]: "#7852ee77",
      // brighter purple
      ["task" /* task */]: "#17e7e077",
      // brighter cyan
      ["comma" /* comma */]: "#11b3b3"
      //  brighter cyan
    }
  }
};
var minimapTheme = {
  current: themes.dark
};
var refreshMinimapTheme = () => {
  minimapTheme.current = themes[getTheme()];
};

// src/stores/minimap/subscriptions/effects/set-minimap-dom.ts
var setMinimapDom = (view) => {
  const minimapContainer = view.contentEl.querySelector(
    ".minimap-container"
  );
  if (!minimapContainer)
    throw new SilentError("minimapContainer is undefined");
  const canvasContainer = minimapContainer.querySelector(
    ".canvas-container"
  );
  invariant(canvasContainer);
  const scrollIndicator = minimapContainer.querySelector(
    "#scrollIndicator"
  );
  const canvas = minimapContainer.querySelector("canvas");
  invariant(scrollIndicator);
  invariant(canvas);
  canvas.width = CANVAS_WIDTH_CPX;
  const offscreen = canvas.transferControlToOffscreen();
  const dom = {
    offscreen,
    canvas,
    scrollIndicator,
    canvasContainer
  };
  view.setMinimapDom(dom);
};

// inline-worker:__inline-worker
function inlineWorker(scriptText) {
  let blob = new Blob([scriptText], { type: "text/javascript" });
  let url = URL.createObjectURL(blob);
  let worker = new Worker(url);
  URL.revokeObjectURL(url);
  return worker;
}

// src/stores/minimap/subscriptions/effects/minimap-canvas/worker/minimap-renderer.worker.ts
function Worker2() {
  return inlineWorker('var K=(a,t,n)=>{if(!t.has(a))throw TypeError("Cannot "+n)};var h=(a,t,n)=>(K(a,t,"read from private field"),n?n.call(a):t.get(a)),x=(a,t,n)=>{if(t.has(a))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(a):t.set(a,n)},N=(a,t,n,i)=>(K(a,t,"write to private field"),i?i.call(a,n):t.set(a,n),n);var w=class{constructor(){this.caches={};this.getCachedResult=(t,n,i,s)=>{let l=this.caches[t];if(!l)return;let r=l.get(n);if(r){if(r.availableLineCharacters===s&&r.content===i)return r.result;l.delete(n)}};this.cacheResult=(t,n,i,s,l)=>{this.caches[t]||(this.caches[t]=new Map),this.caches[t].set(n,{availableLineCharacters:s,content:i,result:l})};this.deleteCanvasCache=t=>{delete this.caches[t]}}},k=new w;var se={"#":"heading","-":"bullet",".":"period","=":"highlight","*":"bold_italic",_:"bold_italic","[":"wikilink","]":"wikilink","~":"strikethrough",",":"comma"},re=/\\b(dr|mr|mrs|ms|e\\.g|e\\.i|sr|jr|st|ave|rd|no|vs|etc|vol|ed|pp)\\b/i,le=new Set(["^",".","!","`","*","%","?",\'"\',"~","@","\'","(",")","!","{","}","[","]","^","%","$","+","=","\\\\"]),F=(a,t,n,i)=>{var o,C,B,O,X,W;let s=k.getCachedResult(i,n,a,t);if(s)return s;let l=!a.trim();l&&(a="empty");let r=[],e={element:{chunk:"",length_chars:-1,line:0,type:null,x_chars:0},elementMeta:null,parentElementMeta:null,closingTagLength:0,x:0,lineNumber:0};for(let c=0;c<a.length;c++){let m=a[c];if(m===`\n`){e.lineNumber++,e.x=0,e.elementMeta&&e.elementMeta.scope==="multi_line"||(e.elementMeta=null);continue}else if(m===" ")(o=e.elementMeta)!=null&&o.noSpaces&&(e.elementMeta=null);else if(!e.elementMeta||e.elementMeta.scope!=="full_line"){let _=se[m];if(_){let d=a[c+1],ne=a[c+2];if(m==="#"&&e.x===0&&(d===" "||d==="#"))e.elementMeta={elementName:_,scope:"full_line"};else if(m==="#"&&!le.has(d)&&(!e.elementMeta||e.elementMeta.canBeParent||e.elementMeta.elementName===_))(C=e.elementMeta)!=null&&C.canBeParent&&(e.parentElementMeta=e.elementMeta),e.elementMeta={elementName:"tag",scope:"block",noSpaces:!0};else if(m==="-"&&e.x===0)d===" "&&a[c+2]==="["&&a[c+4]==="]"?e.elementMeta={elementName:"task",scope:"block",canBeParent:!0}:e.elementMeta={elementName:"bullet",scope:"block",canBeParent:!0};else if(m==="."&&(!e.elementMeta||e.elementMeta.elementName==="tag")){let f=(a[c-3]||"")+a[c-2]+a[c-1],u=a[c+1];!(u&&u.match(/[A-Z\\d]/))&&a[c-1]&&!a[c-1].match(/[.!?]/)&&!re.test(f)&&!(a[c-1]==="e"&&u==="g")&&!(a[c-1]==="i"&&u==="e")&&(e.elementMeta={elementName:"period",scope:"character"})}else if(m===","&&(!e.elementMeta||e.elementMeta.elementName==="tag")){let f=a[c-1]||"",u=a[c+1]||"";(!f.match(/\\d/)||!u.match(/\\d/))&&(e.elementMeta={elementName:"comma",scope:"character"})}else if(!e.elementMeta||e.elementMeta.canBeParent||e.elementMeta.elementName===_){let f=m==="=",u=f&&d==="="||m==="~"&&d==="~"||m==="["&&d==="["||m==="]"&&d==="]"||m==="*"&&d==="*";if(u||m==="*"&&a[c-1]!=="*"||m==="_"){let V=((B=e.elementMeta)==null?void 0:B.elementName)===_,ie=V?!1:u?ne===" ":d===" ";if(V)e.closingTagLength=u?2:1;else if(!ie){let G=f?"multi_line":"block";(O=e.elementMeta)!=null&&O.canBeParent&&G==="block"&&(e.parentElementMeta=e.elementMeta),e.elementMeta={elementName:_,scope:G,canBeParent:f}}}}}}e.x+1>t?(e.lineNumber++,e.x=0):e.closingTagLength===0&&!e.elementMeta&&e.parentElementMeta&&(e.elementMeta=e.parentElementMeta,e.parentElementMeta=null),e.lineNumber!==e.element.line?(e.element.length_chars=e.element.chunk.length,e.element.length_chars>0&&r.push(e.element),e.element={chunk:m,line:e.lineNumber,x_chars:0,length_chars:-1,type:e.elementMeta?e.elementMeta.elementName:null}):m===" "&&(!e.elementMeta||(X=e.elementMeta)!=null&&X.noSpaces)?(e.element.length_chars=e.element.chunk.length,e.element.length_chars>0&&r.push(e.element),e.element={chunk:"",line:e.lineNumber,x_chars:e.x+1,length_chars:-1,type:null},e.elementMeta=null):((W=e.elementMeta)==null?void 0:W.scope)==="character"?(e.element.length_chars=e.element.chunk.length,e.element.length_chars>0&&r.push(e.element),r.push({chunk:m,line:e.lineNumber,x_chars:e.x,length_chars:1,type:e.elementMeta.elementName}),e.elementMeta=null,e.element={chunk:"",line:e.lineNumber,x_chars:e.x+1,length_chars:-1,type:null}):e.elementMeta&&e.elementMeta.elementName!==e.element.type?(e.element.length_chars=e.element.chunk.length,e.element.length_chars>0&&r.push(e.element),e.element={chunk:m,line:e.lineNumber,x_chars:e.x,length_chars:-1,type:e.elementMeta.elementName}):e.element.chunk+=m,e.closingTagLength>0&&(e.closingTagLength--,e.closingTagLength===0&&(e.parentElementMeta?(e.elementMeta=e.parentElementMeta,e.parentElementMeta=null):e.elementMeta=null)),e.x++}e.element.length_chars=e.element.chunk.length,e.element.length_chars>0&&r.push(e.element);let p={chunks:r,totalLines:e.lineNumber+1,empty:l};return k.cacheResult(i,n,a,t,p),p};var Y=58.666666666666664,z=2;var D=6,oe=6,L=D+oe,S=3100;var me=1,$=(a,t,n)=>{var p;let i=Y-t.depth*z,s=F(a.content,i,a.id,n),l={indentationLines:[],lineNumber:t.nextLineOffset,wordBlocks:[],depth:t.depth,nodeId:a.id,y_px:10*t.nextLineOffset};t.lines.push(l);let r=((p=s.chunks[0])==null?void 0:p.line)||0;for(let o of s.chunks){let C=t.nextLineOffset+o.line;o.line>r&&(l={indentationLines:[],lineNumber:C,wordBlocks:[],depth:t.depth,nodeId:a.id,y_px:10*C},t.lines.push(l),r=o.line),l.wordBlocks.push({width_px:o.length_chars*6,x_px:t.depth*L+o.x_chars*6,empty:s.empty,chunkType:o.type})}t.nextLineOffset=t.nextLineOffset+s.totalLines+1;let e=t.depth;t.depth=e+1;for(let o of a.children)$(o,t,n);t.depth=e},j=(a,t)=>{let n={nextLineOffset:me,depth:0,lines:[]};for(let i of a)$(i,n,t);return{lines:n.lines,totalLines:n.nextLineOffset+1}};var Z=a=>{for(let t=0;t<a.length;t++){let n=a[t],i=n.depth,s=a[t+1],l=!0;s&&s.nodeId===n.nodeId&&(l=!1);for(let r=0;r<i;r++){let e=r*L;n.indentationLines.push({x_px:e,height_px:10-(l?4:0)})}}};var q=(a,t="")=>({id:a,content:t.trim(),children:[]}),Q=(a,t)=>{var s;let n={};for(let l of a)for(let r of l.groups)for(let e of r.nodes){let p=q(e,(s=t[e])==null?void 0:s.content),o=n[r.parentId];o||(o=q(r.parentId),n[r.parentId]=o),o.children.push(p),n[e]=p}let i=[];if(a[0])for(let l of a[0].groups)for(let r of l.nodes){let e=n[r];if(e)i.push(e);else throw new Error(`could not find node ${r}`)}return i};var U=a=>{let t={};for(let n of a){let i=n.y_px,s=n.y_px+10;t[n.nodeId]?t[n.nodeId]={y_start:Math.min(i,t[n.nodeId].y_start),y_end:Math.max(s,t[n.nodeId].y_end),cardId:n.nodeId}:t[n.nodeId]={y_start:i,y_end:s,cardId:n.nodeId}}return t};var M,T,b,y,v=class{constructor(){x(this,M,[]);x(this,T,!0);x(this,b,0);x(this,y,{})}calculateDocument(t,n){let i=Q(t.columns,t.content),s=j(i,n);return N(this,M,s.lines),N(this,b,s.totalLines),Z(s.lines),N(this,T,s.lines.length===0||s.lines.every(l=>l.wordBlocks.length===1&&l.wordBlocks[0].empty)),N(this,y,U(h(this,M))),{totalLines:h(this,b),totalDrawnHeight_cpx:h(this,b)*10,cardRanges:h(this,y)}}get lines(){return h(this,M)}get isEmpty(){return h(this,T)}};M=new WeakMap,T=new WeakMap,b=new WeakMap,y=new WeakMap;var ce=6,ee=(a,t,n,i)=>{let s="",l="";for(let r=0;r<=t.length-1;r++){let e=t[r],p=e.y_px;if(!(p<i.start_cpx)){if(p>i.end_cpx)break;i.start_cpx>0&&(p=p-i.start_cpx);for(let o of e.wordBlocks)o.empty||(l=o.chunkType?n.chars[o.chunkType]:n.wordBlock,l!==s&&(s=l,a.fillStyle=l),a.fillRect(o.x_px,p,o.width_px,ce));s="",a.fillStyle=n.indentLine;for(let o of e.indentationLines)a.fillRect(o.x_px,p,D,o.height_px)}}};var I=class{constructor(t,n,i){this.drawDocument=(t,n)=>{this.canvas.height=n.end_cpx-n.start_cpx,this.shapes.isEmpty?this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height):ee(this.ctx,this.shapes.lines,t,n)};this.ctx=t,this.canvas=n,this.shapes=i}};var pe={dark:{isLightTheme:!1,card_active:"#a9a9a9a",card_searchResult:"#e0de7177",wordBlock:"#99999966",indentLine:"#ffffff55",chars:{highlight:"#e0de7177",wikilink:"#027aff77",bold_italic:"#fb464c66",heading:"#44cf6e77",bullet:"#E3BFD466",tag:"#e9973f77",period:"#ffffff88",strikethrough:"#a882ff66",task:"#17e7e077",comma:"#17e7e088"}},light:{isLightTheme:!0,wordBlock:"#70707088",card_active:"#aaaaaa",card_searchResult:"#e0ac0077",indentLine:"#777777aa",chars:{highlight:"#e0ac0077",wikilink:"#086ddd77",bold_italic:"#e9314777",heading:"#08b94e77",bullet:"#E77EB277",tag:"#ec750077",period:"#777777ee",strikethrough:"#7852ee77",task:"#17e7e077",comma:"#11b3b3"}}},te={current:pe.dark};var E,R=class{constructor(t){x(this,E,void 0);this.canvas_height_cpx=t,this.calculateRenderedRange(0)}updateScrollPosition(t){let n=t,i=t+this.canvas_height_cpx;return n<h(this,E).start_cpx||i>h(this,E).end_cpx?(this.calculateRenderedRange(t),!0):!1}calculateRenderedRange(t){let n=Math.max(0,t-S),i=t+this.canvas_height_cpx+S;N(this,E,{start_cpx:n,end_cpx:i})}get visibleRange(){return h(this,E)}};E=new WeakMap;var P=class{constructor(t,n,i,s){this.state={theme:te.current};this.setTheme=t=>{this.state.theme=t};this.setDocument=(t,n)=>{let i=this.shapes.calculateDocument(t,n);return this.renderer.drawDocument(this.state.theme,this.range.visibleRange),{totalDrawnHeight_cpx:i.totalDrawnHeight_cpx,cardRanges:i.cardRanges}};this.drawDocument=()=>{this.renderer.drawDocument(this.state.theme,this.range.visibleRange)};this.setScrollPosition=t=>this.range.updateScrollPosition(t)?this.range.visibleRange:null;this.shapes=new v,this.renderer=new I(t,n,this.shapes),this.range=new R(s),this.state.theme=i}};var A={canvases:{}};self.onmessage=a=>{let t=a.data.payload,n=null;if(t.type==="worker/initialize"){let i=t.payload.canvas.getContext("2d");i&&(A.canvases[t.payload.canvasId]={minimap:new P(i,t.payload.canvas,t.payload.theme,t.payload.canvas_height_cpx)})}else if(t.type==="worker/destroy")delete A.canvases[t.payload.canvasId],k.deleteCanvasCache(t.payload.canvasId);else{let i=A.canvases[t.payload.canvasId];if(!i)throw new Error("no canvas context");t.type==="minimap/update-theme"?i.minimap.setTheme(t.payload.theme):t.type==="minimap/set/document"?n=i.minimap.setDocument(t.payload.document,t.payload.canvasId):t.type==="minimap/set/scroll-position"?n=i.minimap.setScrollPosition(t.payload.scroll_position_cpx):t.type==="minimap/draw-document"&&i.minimap.drawDocument()}self.postMessage({id:a.data.id,payload:n})};\n');
}

// src/stores/view/subscriptions/effects/style-rules/workers/style-rules.worker.ts
function Worker3() {
  return inlineWorker('var l=(o,u)=>{for(let e of o)for(let t of e.groups)if(t.parentId===u)return t};var S=(o,u)=>{var e,t;return(t=(e=l(o,u))==null?void 0:e.nodes.length)!=null?t:0};var R=o=>o.split(`\n`).filter(u=>u.trim().length>0).length;var N=/(?:[0-9]+(?:(?:,|.)[0-9]+)*|[-\'\u2019A-Za-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\u0B80-\u0BFF\uAC00-\uD7A3\uA960-\uA97C\uD7B0-\uD7C6])+|[\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u4E00-\\u9FD5\\uAC00-\\uD7A3\\uA960-\\uA97C\\uD7B0-\\uD7C6]/g,y=o=>{N.lastIndex=0;let u=o.match(N);return u?u.length:0};var G=/(?:[0-9]+(?:(?:,|.)[0-9]+)*|[-\'\u2019A-Za-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\u0B80-\u0BFF\uAC00-\uD7A3\uA960-\uA97C\uD7B0-\uD7C6])+|[\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u4E00-\\u9FD5\\uAC00-\\uD7A3\\uA960-\\uA97C\\uD7B0-\\uD7C6]/g,b=o=>o.length-o.replace(/--/g,"##").replace(G,"").length;var C=(o,u)=>{for(let e=0;e<o.length;e++){let t=o[e];for(let r of t.groups)if(r.nodes.find(A=>A===u))return e}return-1};var F=(o,u)=>{let e=C(o,u),t=new Set([u]);for(let r=e+1;r<o.length;r++){let A=o[r];for(let n of A.groups)if(t.has(n.parentId))for(let s of n.nodes)t.add(s)}return t.delete(u),Array.from(t)};var v=(o,u)=>F(o,u).length;var x=o=>{var e;return((e=o.match(/^#{1,6} .*/gm))!=null?e:[]).map(t=>t.replace(/^#{1,6} /,""))};var _={"document/update-node-content":{content:!0},"document/format-headings":{content:!0},"document/add-node":{createOrDelete:!0},"document/delete-node":{createOrDelete:!0},"document/merge-node":{createOrDelete:!0},"document/file/load-from-disk":{createOrDelete:!0},"document/extract-node":{createOrDelete:!0},"document/split-node":{createOrDelete:!0},"document/drop-node":{dropOrMove:!0},"document/move-node":{dropOrMove:!0},"document/sort-direct-child-nodes":{dropOrMove:!0},"document/history/select-next-snapshot":{changeHistory:!0},"document/history/select-previous-snapshot":{changeHistory:!0},"document/history/select-snapshot":{changeHistory:!0},"document/paste-node":{clipboard:!0},"document/cut-node":{clipboard:!0}},Q=new Map(Object.entries(_));var d=new Set(["document/history/select-next-snapshot","document/history/select-previous-snapshot","document/history/select-snapshot","document/file/load-from-disk","document/merge-node","document/split-node","document/delete-node","document/extract-node","document/cut-node"]);var D=new Set(["document/drop-node","document/move-node","document/add-node","document/paste-node","document/sort-direct-child-nodes"]);var w=()=>({headings:{},content:{},"line-count":{},"character-count":{},"word-count":{},"headings-word-count":{},"direct-children-count":{},"total-children-count":{},depth:{}}),B=class{constructor(u,e){this.isEmpty=!0;this.resetCache=(u,e,t)=>{this.columns=e,this.content=t,!this.isEmpty&&(d.has(u.type)?(this.cache=w(),this.isEmpty=!0):D.has(u.type)?(this.cache.depth={},this.cache["direct-children-count"]={},this.cache["total-children-count"]={}):u.type==="document/update-node-content"?(delete this.cache.headings[u.payload.nodeId],delete this.cache.content[u.payload.nodeId],delete this.cache["line-count"][u.payload.nodeId],delete this.cache["character-count"][u.payload.nodeId],delete this.cache["word-count"][u.payload.nodeId],delete this.cache["headings-word-count"][u.payload.nodeId]):u.type==="document/format-headings"&&(this.cache.headings={},this.cache.content={},this.cache["line-count"]={},this.cache["character-count"]={},this.cache["word-count"]={},this.cache["headings-word-count"]={}))};this.columns=u,this.content=e,this.cache=w()}cacheResult(u,e,t){this.isEmpty&&(this.isEmpty=!1),this.cache[e][u]=t}getProperty(u,e){var r,A,n,s;if(this.cache[e][u]!==void 0)return this.cache[e][u];let t;switch(e){case"direct-children-count":t=S(this.columns,u);break;case"total-children-count":t=v(this.columns,u);break;case"line-count":t=R((r=this.content[u])==null?void 0:r.content);break;case"word-count":t=y((A=this.content[u])==null?void 0:A.content);break;case"character-count":t=b((n=this.content[u])==null?void 0:n.content);break;case"depth":t=C(this.columns,u)+1;break;case"headings":t=x((s=this.content[u])==null?void 0:s.content).join(" ").toLowerCase();break;case"headings-word-count":t=y(this.getProperty(u,"headings"));break;default:throw new Error(`Unsupported property: ${e}`)}return this.cacheResult(u,e,t),t}};var f=(o,u)=>{for(let e of o)for(let t of e.groups)for(let r of t.nodes)if(r===u)return t};var T=(o,u)=>{for(let e=0;e<o.length;e++){let t=o[e];for(let r of t.groups)for(let A of r.nodes)if(A===u)return[e,r.parentId]}return null};var g=(o,u)=>{let e=[],t=T(o,u);if(!t)return e;let r=t[1],A=t[0];for(let n=A-1;n>=0&&r;n--){e.push(r);let s;for(let c of o[n].groups){for(let i of c.nodes)if(i===r){s=c.parentId;break}if(s)break}r=s}return e};var O=()=>({self:{},"direct-parent":{},"any-parent":{},"direct-children":{},"any-children":{},"self-or-any-parent":{},"self-or-direct-parent":{},"self-or-any-children":{},"self-or-direct-children":{}}),m=class{constructor(u){this.isEmpty=!0;this.resetCache=(u,e)=>{this.columns=e,!this.isEmpty&&(d.has(u.type)||D.has(u.type))&&(this.cache=O(),this.isEmpty=!0)};this.columns=u,this.cache=O()}cacheResult(u,e,t){this.isEmpty&&(this.isEmpty=!1),this.cache[e][u]=t}getTargetNodes(u,e){if(this.cache[u][e]!==void 0)return this.cache[u][e];let t;switch(u){case"self":t=[e];break;case"direct-parent":{let r=f(this.columns,e);t=r?[r.parentId]:[];break}case"self-or-direct-parent":{let r=f(this.columns,e);t=r?[r.parentId,e]:[e];break}case"any-parent":{t=g(this.columns,e);break}case"self-or-any-parent":{t=[...g(this.columns,e),e];break}case"direct-children":{let r=l(this.columns,e);t=r?r.nodes:[];break}case"self-or-direct-children":{let r=l(this.columns,e);t=r?[e,...r.nodes]:[e];break}case"any-children":{t=F(this.columns,e);break}case"self-or-any-children":{t=[e,...F(this.columns,e)];break}}return this.cacheResult(e,u,t),t}};var P=new Set(["equals","not-equals","empty","not-empty"]);var k=(o,u,e)=>{switch(u){case"equals":return o===e;case"not-equals":return o!==e;case"empty":return!o;case"not-empty":return!!o;case"contains":return o.includes(e);case"not-contains":return!o.includes(e);case"starts-with":return o.startsWith(e);case"not-starts-with":return!o.startsWith(e);case"ends-with":return o.endsWith(e);case"not-ends-with":return!o.endsWith(e);case"matches-regex":return new RegExp(e).test(o);case"not-matches-regex":return!new RegExp(e).test(o);default:return!1}};var L=(o,u,e,t)=>{switch(u){case"equals":return o===e;case"not-equals":return o!==e;case"empty":return o===0;case"not-empty":return o!==0;case"greater-than":return o>e;case"less-than":return o<e;case"between":return t!==void 0&&o>=e&&o<=t;case"not-between":return t!==void 0&&(o<e||o>t);default:return!1}};var M=(o,u,e,t,r)=>{var n,s;if(!u.enabled)return!1;let A=t.getTargetNodes(u.scope,o);for(let c of A){let i=(s=(n=e[c])==null?void 0:n.content)!=null?s:"";if("value"in u){let p=!1;if(u.property==="content"||u.property==="headings"){let a=u.property==="content"?i.toLowerCase():r.getProperty(o,"headings");p=k(a,u.operator,u.value.toLowerCase())}else{let a=r.getProperty(c,u.property);if(a===null)throw new Error("Value is null:"+u.property+" - "+c);p=L(a,u.operator,u.value,u.valueB)}if(p)return!0}}return!1};var U=(o,u,e,t)=>{let r={nodeStyles:new Map,allMatches:new Map},A=[...u].sort((n,s)=>n.global&&!s.global?1:n.priority-s.priority);for(let n of o.columns)for(let s of n.groups)for(let c of s.nodes)for(let i of A){if(!i.enabled||typeof i.condition.value=="string"&&i.condition.value.length===0&&!P.has(i.condition.operator))continue;if(M(c,i.condition,o.content,t,e)){r.nodeStyles.has(c)||r.nodeStyles.set(c,i.style);let a=r.allMatches.get(i.id);a||(a=[],r.allMatches.set(i.id,a)),a.push(c)}}return r};var E=class{constructor(){this.processStyleRules=(u,e,t)=>(!this.propertyResolver||!this.targetResolver?this.initialize(u):t&&this.resetResolversCache(u,t),U(u,e,this.propertyResolver,this.targetResolver));this.resetResolversCache=(u,e)=>{this.targetResolver.resetCache(e,u.columns),this.propertyResolver.resetCache(e,u.columns,u.content)};this.initialize=u=>{this.targetResolver=new m(u.columns),this.propertyResolver=new B(u.columns,u.content)}}};var h={};self.onmessage=o=>{let u=o.data,{id:e,payload:t}=u,r=null;switch(t.type){case"destroy":{delete h[t.payload.viewId];break}case"process-rules":{h[t.payload.viewId]||(h[t.payload.viewId]=new E),r=h[t.payload.viewId].processStyleRules(t.payload.document,t.payload.rules,t.payload.action);break}default:throw new Error(`Unhandled event type: ${t.type}`)}self.postMessage({id:e,payload:r})};\n');
}

// src/helpers/worker-promise.ts
var WorkerPromise = class {
  constructor(worker) {
    this.id = 0;
    this.resolvers = {};
    this.run = (payload, shared) => {
      return new Promise((resolve) => {
        if (this.id === 1e3)
          this.id = 0;
        const id2 = this.id++;
        this.resolvers[id2] = resolve;
        if (shared) {
          this.worker.postMessage({ id: id2, payload }, [shared]);
        } else
          this.worker.postMessage({ id: id2, payload });
      });
    };
    this.terminate = () => {
      this.worker.terminate();
    };
    this.onMessage = (message) => {
      const id2 = message.data.id;
      const resolver = this.resolvers[id2];
      if (resolver) {
        resolver(message.data.payload);
        delete this.resolvers[id2];
      }
    };
    this.worker = worker;
    this.worker.addEventListener("message", this.onMessage);
  }
};

// src/obsidian/status-bar/helpers/status-bar.worker.ts
function Worker4() {
  return inlineWorker('var i=(e,t="")=>({id:e,content:t.trim(),children:[]}),p=(e,t)=>{var r;let o={};for(let c of e)for(let s of c.groups)for(let d of s.nodes){let l=i(d,(r=t[d])==null?void 0:r.content),u=o[s.parentId];u||(u=i(s.parentId),o[s.parentId]=u),u.children.push(l),o[d]=l}let n=[];if(e[0])for(let c of e[0].groups)for(let s of c.nodes){let d=o[s];if(d)n.push(d);else throw new Error(`could not find node ${s}`)}return n};var a=(e,t=[])=>{for(let o of e)t.push(o),o.children.length>0&&a(o.children,t);return t},m=e=>e.reduce((t,o)=>t+o.content.length,0),f=e=>{let t=p(e.document.columns,e.document.content),o=a(t),n=m(o);if(n===0)return 0;let r=o.findIndex(d=>d.id===e.activeNode);if(r===-1)return 0;let c=o.slice(0,r+1),s=m(c);return Math.round(s/n*100)};var g=(e,t)=>{for(let o=0;o<e.length;o++){let n=e[o];for(let r of n.groups)if(r.nodes.find(c=>c===t))return o}return-1};var h=(e,t)=>{let o=g(e,t),n=new Set([t]);for(let r=o+1;r<e.length;r++){let c=e[r];for(let s of c.groups)if(n.has(s.parentId))for(let d of s.nodes)n.add(d)}return n.delete(t),Array.from(n)};var C=(e,t)=>h(e,t).length;self.onmessage=e=>{let t=e.data.payload,o=f(t),r={totalChildCount:C(t.document.columns,t.activeNode),progress:o};self.postMessage({id:e.data.id,payload:r})};\n');
}

// src/workers/worker-instances.ts
var minimapWorker = new WorkerPromise(new Worker2());
var rulesWorker = new WorkerPromise(new Worker3());
var statusBarWorker = new WorkerPromise(new Worker4());

// src/stores/minimap/subscriptions/effects/initialize-minimap-worker.ts
var initializeMinimapWorker = async (view) => {
  const canvasContainer = view.getMinimapDom().canvasContainer.parentElement;
  const canvas_height_cpx = dpx_to_cpx(
    canvasContainer.getBoundingClientRect().height
  );
  await minimapWorker.run(
    {
      type: "worker/initialize",
      payload: {
        canvas: view.getMinimapDom().offscreen,
        canvasId: view.getMinimapStore().getValue().canvasId,
        theme: minimapTheme.current,
        canvas_height_cpx
      }
    },
    view.getMinimapDom().offscreen
  );
};

// src/stores/minimap/subscriptions/actions/set-minimap-active-node.ts
var setMinimapActiveNode = (view) => {
  view.getMinimapStore().dispatch({
    type: "minimap/set-active-node",
    payload: {
      id: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/stores/minimap/subscriptions/effects/draw-document.ts
var drawDocument = async (view) => {
  const minimapStore = view.getMinimapStore();
  const state2 = minimapStore.getValue();
  const lineageDocument = view.documentStore.getValue().document;
  const canvasId = state2.canvasId;
  const activeCardId = state2.activeCardId;
  const payload = await minimapWorker.run({
    type: "minimap/set/document",
    payload: {
      document: lineageDocument,
      canvasId,
      activeNodeId: activeCardId
    }
  });
  invariant(payload);
  if ("cardRanges" in payload) {
    minimapStore.dispatch({
      type: "minimap/set-card-ranges",
      payload: {
        ranges: payload.cardRanges,
        height_cpx: payload.totalDrawnHeight_cpx
      }
    });
  }
};

// src/stores/minimap/subscriptions/actions/set-client-height.ts
var getActiveView = async (view) => {
  for (let i = 0; i < 10; i++) {
    const activeView = view.plugin.app.workspace.getActiveViewOfType(LineageView);
    if (activeView) {
      return activeView;
    } else {
      await delay(500);
    }
  }
};
var setClientHeight = async (view) => {
  const activeView = await getActiveView(view);
  if (!activeView)
    return;
  const minimapContainer = activeView.getMinimapDom().scrollIndicator.parentElement;
  invariant(minimapContainer);
  const containerHeight = minimapContainer.clientHeight;
  view.getMinimapStore().dispatch({
    type: "minimap/set-container-height",
    payload: { height_cpx: dpx_to_cpx(containerHeight) }
  });
};

// src/stores/minimap/subscriptions/on-minimap-mount.ts
var onMinimapMount = async (view) => {
  const minimapStore = view.minimapStore;
  invariant(minimapStore);
  refreshMinimapTheme();
  setMinimapDom(view);
  initializeMinimapWorker(view);
  setMinimapActiveNode(view);
  setClientHeight(view);
  await drawDocument(view);
};

// src/stores/minimap/subscriptions/on-minimap-state-update.ts
var onMinimapStateUpdate = (view, action, state2, localState) => {
  const minimapStore = view.minimapStore;
  invariant(minimapStore);
  if (action.type === "minimap/set-active-node" || action.type === "minimap/set-container-height" || action.type === "minimap/mouse-wheel-scroll" || action.type === "minimap/set-card-ranges") {
    const scrollPosition = state2.scrollbar.scrollPosition_cpx;
    if (scrollPosition !== localState.previousScrollPosition) {
      localState.previousScrollPosition = scrollPosition;
      view.minimapEffects.updateVisibleRange(view);
    }
  }
};

// src/stores/minimap/subscriptions/minimap-subscriptions.ts
var minimapSubscriptions = (view) => {
  const localState = {
    previousScrollPosition: 0
  };
  const unsub = view.minimapStore.subscribe(
    (viewState, action, initialRun) => {
      if (initialRun) {
        onMinimapMount(view);
      } else if (action) {
        onMinimapStateUpdate(view, action, viewState, localState);
      }
    }
  );
  return () => {
    unsub();
    minimapWorker.run({
      type: "worker/destroy",
      payload: { canvasId: view.minimapStore.getValue().canvasId }
    });
    view.minimapStore = null;
  };
};

// src/stores/minimap/derived/scrollbar-stores.ts
var calculateThumbHeightDpx = (state2) => {
  const isScrollIndicatorHidden = state2.totalDrawnHeight_cpx <= state2.containerHeight_cpx;
  if (isScrollIndicatorHidden)
    return 0;
  const indicatorHeight_cpx = state2.containerHeight_cpx / state2.totalDrawnHeight_cpx * state2.containerHeight_cpx;
  return cpx_to_dpx(indicatorHeight_cpx);
};
var ScrollThumbHeightStore = (view) => {
  return derived2(view.getMinimapStore(), (state2) => {
    return calculateThumbHeightDpx(state2.scrollbar);
  });
};
var ScrollThumbPositionStore = (view) => {
  return derived2(view.getMinimapStore(), (_state) => {
    const state2 = _state.scrollbar;
    const indicatorHeight_dpx = calculateThumbHeightDpx(state2);
    if (indicatorHeight_dpx === 0)
      return 0;
    const maxScroll_cpx = state2.totalDrawnHeight_cpx - state2.containerHeight_cpx;
    const scrollPercent = state2.scrollPosition_cpx / maxScroll_cpx;
    const containerHeight_dpx = cpx_to_dpx(state2.containerHeight_cpx);
    return scrollPercent * (containerHeight_dpx - indicatorHeight_dpx);
  });
};
var MinimapScrollOffsetStore = (view) => derived2(view.getMinimapStore(), (state2) => {
  const offset = cpx_to_dpx(state2.scrollbar.scrollPosition_cpx);
  return offset > 0 ? -1 * offset : offset;
});

// src/view/components/container/minimap/minimap.svelte
function add_css37(target) {
  append_styles(target, "svelte-lp1si7", ":root{--scroll-indicator-color:rgba(255, 255, 255, 0.2)}.minimap-container.svelte-lp1si7{position:relative;height:100%;width:184px;padding:4px;background:var(--background-primary);overflow:hidden;flex:0 0 auto}canvas.svelte-lp1si7{width:176px;margin-right:4px}.canvas-container.svelte-lp1si7{transition:transform 0.1s ease-out;width:176px}.scroll-indicator.svelte-lp1si7{position:absolute;right:0;top:0;width:4px;background:var(--color-base-50);border-radius:2px;transition:transform 0.1s ease-out}");
}
function create_fragment99(ctx) {
  let div2;
  let div0;
  let indicators;
  let t0;
  let canvas;
  let div0_style_value;
  let t1;
  let div1;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  indicators = new indicators_default({});
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(indicators.$$.fragment);
      t0 = space();
      canvas = element("canvas");
      t1 = space();
      div1 = element("div");
      attr(canvas, "id", "minimap");
      attr(canvas, "class", "svelte-lp1si7");
      attr(div0, "class", "canvas-container svelte-lp1si7");
      attr(div0, "style", div0_style_value = `transform: translateY(${/*$containerOffset*/
      ctx[0]}px)`);
      attr(div1, "class", "scroll-indicator svelte-lp1si7");
      attr(div1, "id", "scrollIndicator");
      attr(div1, "style", div1_style_value = `height: ${/*$thumbHeight*/
      ctx[1]}px; transform: translateY(${/*$thumbPosition*/
      ctx[2]}px)`);
      attr(div2, "class", "minimap-container svelte-lp1si7");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(indicators, div0, null);
      append(div0, t0);
      append(div0, canvas);
      append(div2, t1);
      append(div2, div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*onClick*/
            ctx[3]
          ),
          listen(
            div0,
            "mousemove",
            /*onMousemove*/
            ctx[5]
          ),
          listen(
            div2,
            "wheel",
            /*onWheel*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$containerOffset*/
      1 && div0_style_value !== (div0_style_value = `transform: translateY(${/*$containerOffset*/
      ctx2[0]}px)`)) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty & /*$thumbHeight, $thumbPosition*/
      6 && div1_style_value !== (div1_style_value = `height: ${/*$thumbHeight*/
      ctx2[1]}px; transform: translateY(${/*$thumbPosition*/
      ctx2[2]}px)`)) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(indicators.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(indicators.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(indicators);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance97($$self, $$props, $$invalidate) {
  let $containerOffset;
  let $thumbHeight;
  let $thumbPosition;
  const view = getView();
  view.minimapStore = new Store(defaultMinimapState(), minimapReducer, this.onViewStoreError);
  const onClick = (e) => onCanvasClick(e, view);
  const onWheel = (e) => onCanvasWheel(e, view);
  const onMousemove = createOnCanvasMousemove(view);
  onMount(() => {
    let unsub = null;
    setTimeout(
      () => {
        unsub = minimapSubscriptions(view);
      },
      300
    );
    return () => {
      if (unsub)
        unsub();
    };
  });
  const thumbHeight = ScrollThumbHeightStore(view);
  component_subscribe($$self, thumbHeight, (value) => $$invalidate(1, $thumbHeight = value));
  const thumbPosition = ScrollThumbPositionStore(view);
  component_subscribe($$self, thumbPosition, (value) => $$invalidate(2, $thumbPosition = value));
  const containerOffset = MinimapScrollOffsetStore(view);
  component_subscribe($$self, containerOffset, (value) => $$invalidate(0, $containerOffset = value));
  return [
    $containerOffset,
    $thumbHeight,
    $thumbPosition,
    onClick,
    onWheel,
    onMousemove,
    thumbHeight,
    thumbPosition,
    containerOffset
  ];
}
var Minimap = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance97, create_fragment99, safe_not_equal, {}, add_css37);
  }
};
var minimap_default = Minimap;

// src/view/components/container/right-sidebar/right-sidebar.svelte
function add_css38(target) {
  append_styles(target, "svelte-wtyjlq", ".lineage-right-sidebar.svelte-wtyjlq{--node-width:calc(var(--sidebar-width) - 40px);flex:0 0 auto;width:var(--animated-sidebar-width);position:relative;overflow:hidden;transition:width 0.3s ease}");
}
function create_if_block23(ctx) {
  let minimap;
  let current;
  minimap = new minimap_default({});
  return {
    c() {
      create_component(minimap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(minimap, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(minimap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(minimap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(minimap, detaching);
    }
  };
}
function create_fragment100(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  let if_block = (
    /*showMinimap*/
    ctx[2] && create_if_block23(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = null_to_empty("lineage-right-sidebar") + " svelte-wtyjlq");
      attr(div, "style", div_style_value = "--animated-sidebar-width: " + /*animatedSidebarWidth*/
      ctx[0] + "px; --sidebar-width: " + /*sidebarWidth*/
      ctx[1] + "px; }");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*showMinimap*/
        ctx2[2]
      ) {
        if (if_block) {
          if (dirty & /*showMinimap*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*animatedSidebarWidth, sidebarWidth*/
      3 && div_style_value !== (div_style_value = "--animated-sidebar-width: " + /*animatedSidebarWidth*/
      ctx2[0] + "px; --sidebar-width: " + /*sidebarWidth*/
      ctx2[1] + "px; }")) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
var MIN_WIDTH = 184;
function instance98($$self, $$props, $$invalidate) {
  let $showSidebarStore;
  let animatedSidebarWidth = 0;
  let sidebarWidth = MIN_WIDTH;
  let showMinimap = false;
  let showMinimapTimeout = null;
  const view = getView();
  const showSidebarStore = showMinimapStore(view);
  component_subscribe($$self, showSidebarStore, (value) => $$invalidate(5, $showSidebarStore = value));
  const toggleMinimap = (on) => {
    if (on) {
      $$invalidate(2, showMinimap = true);
      $$invalidate(4, showMinimapTimeout = setTimeout(
        () => {
          view.contentEl.addClass("lineage-view__content-el--minimap-on");
        },
        150
      ));
    } else {
      setTimeout(
        () => {
          view.contentEl.removeClass("lineage-view__content-el--minimap-on");
        },
        150
      );
      $$invalidate(4, showMinimapTimeout = setTimeout(
        () => {
          $$invalidate(2, showMinimap = false);
        },
        400
      ));
    }
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*showMinimapTimeout, $showSidebarStore*/
    48) {
      $: {
        if (showMinimapTimeout)
          clearTimeout(showMinimapTimeout);
        if ($showSidebarStore) {
          $$invalidate(0, animatedSidebarWidth = MIN_WIDTH);
          $$invalidate(1, sidebarWidth = MIN_WIDTH);
          toggleMinimap(true);
        } else {
          $$invalidate(0, animatedSidebarWidth = 0);
          toggleMinimap(false);
        }
      }
    }
  };
  return [
    animatedSidebarWidth,
    sidebarWidth,
    showMinimap,
    showSidebarStore,
    showMinimapTimeout,
    $showSidebarStore
  ];
}
var Right_sidebar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance98, create_fragment100, safe_not_equal, {}, add_css38);
  }
};
var right_sidebar_default = Right_sidebar;

// src/view/actions/click-and-drag/click-and-drag.ts
var clickAndDrag = (element2, view) => {
  let pressed = false;
  let initializedValues = false;
  let container_startX = 0;
  let container_scrollLeft = 0;
  let container_rectLeft = 0;
  let zoomLevel = 1;
  const columns_startY = [];
  const columns_scrollTop = [];
  const columns_rectTop = [];
  let columns = [];
  const onMouseMove = (e) => {
    if (!pressed || e.buttons !== 1)
      return;
    if (!initializedValues) {
      const rect = view.container.getBoundingClientRect();
      container_rectLeft = rect.left;
      container_startX = e.clientX - container_rectLeft;
      container_scrollLeft = view.container.scrollLeft;
      columns = Array.from(view.container.querySelectorAll(".column"));
      for (let i = 0; i < columns.length; i++) {
        const column = columns[i];
        const rect2 = column.getBoundingClientRect();
        columns_scrollTop[i] = column.scrollTop;
        columns_startY[i] = e.clientY - rect2.top;
        columns_rectTop[i] = rect2.top;
      }
      zoomLevel = view.plugin.settings.getValue().view.zoomLevel;
      initializedValues = true;
    }
    const _columns_rectTop = Array.from(columns_rectTop);
    const _columns_scrollTop = Array.from(columns_scrollTop);
    const _columns_startY = Array.from(columns_startY);
    requestAnimationFrame(() => {
      const dx = e.clientX - container_rectLeft - container_startX;
      view.container.scrollLeft = container_scrollLeft - dx;
      for (let i = 0; i < columns.length; i++) {
        const dy = e.clientY - _columns_rectTop[i] - _columns_startY[i];
        const column = columns[i];
        column.scrollTop = _columns_scrollTop[i] - dy / zoomLevel;
      }
    });
  };
  const onKeyDown = (e) => {
    if (e.key === " " && !pressed) {
      const enabled = !isEditing(view) && e.target.tagName !== "INPUT";
      if (enabled) {
        pressed = true;
        view.container.style.cursor = "grab";
        e.preventDefault();
      }
    }
  };
  const onKeyUp = (e) => {
    if (e.key === " " && pressed) {
      pressed = false;
      initializedValues = false;
      setTimeout(() => {
        view.container.style.cursor = "initial";
      }, 50);
    }
  };
  const onMouseDown = (e) => {
    if (pressed) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
  const onMouseUp = (e) => {
    if (pressed) {
      initializedValues = false;
      e.preventDefault();
      e.stopPropagation();
    }
  };
  const hookEvents = () => {
    element2.addEventListener("mousemove", onMouseMove);
    element2.addEventListener("keydown", onKeyDown);
    element2.addEventListener("keyup", onKeyUp);
    element2.addEventListener("mouseup", onMouseUp);
    element2.addEventListener("mousedown", onMouseDown);
  };
  const unhookEvents = () => {
    element2.removeEventListener("mousemove", onMouseMove);
    element2.removeEventListener("keydown", onKeyDown);
    element2.removeEventListener("keyup", onKeyUp);
    element2.removeEventListener("mouseup", onMouseUp);
    element2.removeEventListener("mousedown", onMouseDown);
  };
  hookEvents();
  return {
    destroy: () => {
      unhookEvents();
    }
  };
};

// src/view/components/container/left-sidebar/components/tab-header/components/clickable-icon.svelte
function add_css39(target) {
  append_styles(target, "svelte-1scmxe1", ".lineage-view .clickable-icon.svelte-1scmxe1{cursor:pointer}.theme-dark{& .lineage-view .sidebar-tabs-header .clickable-icon {\n            color: var(--color-base-60);\n        };& .lineage-view .sidebar-tabs-header .clickable-icon:active {\n            color: var(--icon-color-active);\n        }}.theme-light{& .lineage-view .sidebar-tabs-header .clickable-icon {\n            color: var(--color-base-10);\n        };& .lineage-view .sidebar-tabs-header .clickable-icon:active {\n            color: var(--color-base-10);\n        }}.clickable-icon--active.svelte-1scmxe1{color:var(--icon-color-active);background-color:rgba(0, 0, 0, 0.3);background-blend-mode:multiply}");
}
function create_fragment101(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[1]
      );
      attr(button, "class", button_class_value = null_to_empty("clickable-icon nav-action-button " + /*isActive*/
      (ctx[2] ? "clickable-icon--active " : "")) + " svelte-1scmxe1");
      set_style(button, "position", "relative");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onClick*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      2) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx[1]
        );
      }
      if (!current || dirty & /*isActive*/
      4 && button_class_value !== (button_class_value = null_to_empty("clickable-icon nav-action-button " + /*isActive*/
      (ctx[2] ? "clickable-icon--active " : "")) + " svelte-1scmxe1")) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance99($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onClick } = $$props;
  let { label } = $$props;
  let { isActive = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onClick" in $$props2)
      $$invalidate(0, onClick = $$props2.onClick);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("isActive" in $$props2)
      $$invalidate(2, isActive = $$props2.isActive);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [onClick, label, isActive, $$scope, slots];
}
var Clickable_icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance99, create_fragment101, safe_not_equal, { onClick: 0, label: 1, isActive: 2 }, add_css39);
  }
};
var clickable_icon_default = Clickable_icon;

// src/view/components/container/left-sidebar/components/tab-header/tab-header.svelte
function add_css40(target) {
  append_styles(target, "svelte-rqh5hd", ".sidebar-tabs-header.svelte-rqh5hd{display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;align-self:center;justify-self:center;box-sizing:border-box;height:auto}.tab-header-buttons.svelte-rqh5hd{display:flex;align-items:center;justify-content:center;gap:5px}");
}
function create_default_slot_15(ctx) {
  let pin;
  let current;
  pin = new pin_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(pin.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pin, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pin, detaching);
    }
  };
}
function create_default_slot64(ctx) {
  let clock;
  let current;
  clock = new clock_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(clock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clock, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(clock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clock, detaching);
    }
  };
}
function create_fragment102(ctx) {
  let div1;
  let div0;
  let clickableicon0;
  let t;
  let clickableicon1;
  let current;
  clickableicon0 = new clickable_icon_default({
    props: {
      isActive: (
        /*$activeTab*/
        ctx[0] === "pinned-cards"
      ),
      label: lang.sidebar_tab_pinned_nodes,
      onClick: (
        /*func*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  clickableicon1 = new clickable_icon_default({
    props: {
      isActive: (
        /*$activeTab*/
        ctx[0] === "recent-cards"
      ),
      label: lang.sidebar_tab_recent_nodes,
      onClick: (
        /*func_1*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot64] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(clickableicon0.$$.fragment);
      t = space();
      create_component(clickableicon1.$$.fragment);
      attr(div0, "class", "tab-header-buttons svelte-rqh5hd");
      attr(div1, "class", "sidebar-tabs-header svelte-rqh5hd");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(clickableicon0, div0, null);
      append(div0, t);
      mount_component(clickableicon1, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const clickableicon0_changes = {};
      if (dirty & /*$activeTab*/
      1)
        clickableicon0_changes.isActive = /*$activeTab*/
        ctx2[0] === "pinned-cards";
      if (dirty & /*$$scope*/
      64) {
        clickableicon0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      clickableicon0.$set(clickableicon0_changes);
      const clickableicon1_changes = {};
      if (dirty & /*$activeTab*/
      1)
        clickableicon1_changes.isActive = /*$activeTab*/
        ctx2[0] === "recent-cards";
      if (dirty & /*$$scope*/
      64) {
        clickableicon1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      clickableicon1.$set(clickableicon1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(clickableicon0.$$.fragment, local);
      transition_in(clickableicon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clickableicon0.$$.fragment, local);
      transition_out(clickableicon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(clickableicon0);
      destroy_component(clickableicon1);
    }
  };
}
function instance100($$self, $$props, $$invalidate) {
  let $activeTab;
  const view = getView();
  const activeTab = LeftSidebarActiveTabStore(view);
  component_subscribe($$self, activeTab, (value) => $$invalidate(0, $activeTab = value));
  const setActiveTab = (tab) => {
    view.plugin.settings.dispatch({
      type: "view/left-sidebar/set-active-tab",
      payload: { tab }
    });
  };
  const func2 = () => setActiveTab("pinned-cards");
  const func_1 = () => setActiveTab("recent-cards");
  return [$activeTab, activeTab, setActiveTab, func2, func_1];
}
var Tab_header = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance100, create_fragment102, safe_not_equal, {}, add_css40);
  }
};
var tab_header_default = Tab_header;

// src/stores/view/derived/pinned-cards-sidebar.ts
var ActivePinnedCardStore = (view) => derived2(view.viewStore, (state2) => state2.pinnedNodes.activeNode);

// src/view/components/container/left-sidebar/components/no-items/no-items.svelte
function create_fragment103(ctx) {
  let div;
  let t_value = (
    /*variant*/
    (ctx[0] === "pinned" ? lang.sidebar_no_pinned_nodes : lang.sidebar_no_recent_nodes) + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pane-empty");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*variant*/
      1 && t_value !== (t_value = /*variant*/
      (ctx2[0] === "pinned" ? lang.sidebar_no_pinned_nodes : lang.sidebar_no_recent_nodes) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function instance101($$self, $$props, $$invalidate) {
  let { variant } = $$props;
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
  };
  return [variant];
}
var No_items = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance101, create_fragment103, safe_not_equal, { variant: 0 });
  }
};
var no_items_default = No_items;

// src/view/components/container/left-sidebar/components/recent-cards/helpers/scroll-card-into-view.ts
var scrollCardIntoView = (container, activeNodeId) => {
  const activeCard = container.querySelector(
    `#${activeNodeId}`
  );
  if (activeCard) {
    activeCard.scrollIntoView({ behavior: "smooth", block: "nearest" });
  }
};

// src/view/components/container/left-sidebar/components/pinned-cards/actions/scroll-active-pinned-node.ts
var scrollActivePinnedNode = (containerRef) => {
  const view = getView();
  let timeout = null;
  const activePinnedCardStore = ActivePinnedCardStore(view);
  const activePinnedNodeSub = activePinnedCardStore.subscribe(
    (activeNodeId) => {
      if (timeout)
        clearTimeout(timeout);
      timeout = setTimeout(() => {
        if (!containerRef)
          return;
        if (!activeNodeId)
          return;
        scrollCardIntoView(containerRef, activeNodeId);
      }, 200);
    }
  );
  const pinnedNodesStore = PinnedNodesStore(view);
  const pinnedNodesSub = pinnedNodesStore.subscribe(() => {
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(() => {
      if (!containerRef)
        return;
      const activeNodeId = view.viewStore.getValue().pinnedNodes.activeNode;
      if (!activeNodeId)
        return;
      scrollCardIntoView(containerRef, activeNodeId);
    }, 200);
  });
  return {
    destroy: () => {
      activePinnedNodeSub();
      pinnedNodesSub();
    }
  };
};

// src/view/components/container/left-sidebar/components/pinned-cards/pinned-cards-sidebar.svelte
function add_css41(target) {
  append_styles(target, "svelte-1ymcixr", ".pinned-cards-container.svelte-1ymcixr{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;gap:20px;flex:1 1 auto;padding-bottom:10px;overflow-y:auto}");
}
function get_each_context16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_else_block11(ctx) {
  let noitems;
  let current;
  noitems = new no_items_default({ props: { variant: "pinned" } });
  return {
    c() {
      create_component(noitems.$$.fragment);
    },
    m(target, anchor) {
      mount_component(noitems, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(noitems.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(noitems.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(noitems, detaching);
    }
  };
}
function create_if_block24(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*$pinnedNodesArray*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[13]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context16(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block16(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$pinnedNodesArray, $activePinnedCard, $editingStateStore, $pendingConfirmation, $idSection, $styleRules*/
      63) {
        each_value = ensure_array_like(
          /*$pinnedNodesArray*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block16, each_1_anchor, get_each_context16);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_each_block16(key_1, ctx) {
  let first;
  let node_1;
  let current;
  node_1 = new card_default({
    props: {
      node: (
        /*node*/
        ctx[13]
      ),
      active: (
        /*$activePinnedCard*/
        ctx[1] === /*node*/
        ctx[13] ? "node" /* node */ : "sibling" /* sibling */
      ),
      editing: (
        /*$editingStateStore*/
        ctx[2].activeNodeId === /*node*/
        ctx[13] && /*$editingStateStore*/
        ctx[2].isInSidebar === true
      ),
      confirmDisableEdit: (
        /*$editingStateStore*/
        ctx[2].activeNodeId === /*node*/
        ctx[13] && /*$pendingConfirmation*/
        ctx[3].disableEdit === /*node*/
        ctx[13] && /*$editingStateStore*/
        ctx[2].isInSidebar === true
      ),
      confirmDelete: (
        /*$pendingConfirmation*/
        ctx[3].deleteNode.has(
          /*node*/
          ctx[13]
        )
      ),
      isInSidebar: true,
      firstColumn: true,
      section: (
        /*$idSection*/
        ctx[4][
          /*node*/
          ctx[13]
        ]
      ),
      hasActiveChildren: false,
      hasChildren: false,
      selected: false,
      pinned: false,
      style: (
        /*$styleRules*/
        ctx[5].get(
          /*node*/
          ctx[13]
        )
      ),
      outlineMode: false,
      collapsed: false,
      hidden: false,
      alwaysShowCardButtons: true
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(node_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const node_1_changes = {};
      if (dirty & /*$pinnedNodesArray*/
      1)
        node_1_changes.node = /*node*/
        ctx[13];
      if (dirty & /*$activePinnedCard, $pinnedNodesArray*/
      3)
        node_1_changes.active = /*$activePinnedCard*/
        ctx[1] === /*node*/
        ctx[13] ? "node" /* node */ : "sibling" /* sibling */;
      if (dirty & /*$editingStateStore, $pinnedNodesArray*/
      5)
        node_1_changes.editing = /*$editingStateStore*/
        ctx[2].activeNodeId === /*node*/
        ctx[13] && /*$editingStateStore*/
        ctx[2].isInSidebar === true;
      if (dirty & /*$editingStateStore, $pinnedNodesArray, $pendingConfirmation*/
      13)
        node_1_changes.confirmDisableEdit = /*$editingStateStore*/
        ctx[2].activeNodeId === /*node*/
        ctx[13] && /*$pendingConfirmation*/
        ctx[3].disableEdit === /*node*/
        ctx[13] && /*$editingStateStore*/
        ctx[2].isInSidebar === true;
      if (dirty & /*$pendingConfirmation, $pinnedNodesArray*/
      9)
        node_1_changes.confirmDelete = /*$pendingConfirmation*/
        ctx[3].deleteNode.has(
          /*node*/
          ctx[13]
        );
      if (dirty & /*$idSection, $pinnedNodesArray*/
      17)
        node_1_changes.section = /*$idSection*/
        ctx[4][
          /*node*/
          ctx[13]
        ];
      if (dirty & /*$styleRules, $pinnedNodesArray*/
      33)
        node_1_changes.style = /*$styleRules*/
        ctx[5].get(
          /*node*/
          ctx[13]
        );
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(node_1, detaching);
    }
  };
}
function create_fragment104(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let scrollActivePinnedNode_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block24, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$pinnedNodesArray*/
      ctx2[0].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "pinned-cards-container svelte-1ymcixr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(scrollActivePinnedNode_action = scrollActivePinnedNode.call(null, div));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance102($$self, $$props, $$invalidate) {
  let $pinnedNodesArray;
  let $activePinnedCard;
  let $editingStateStore;
  let $pendingConfirmation;
  let $idSection;
  let $styleRules;
  const view = getView();
  const pinnedNodesArray = PinnedNodesStore(view);
  component_subscribe($$self, pinnedNodesArray, (value) => $$invalidate(0, $pinnedNodesArray = value));
  const idSection = IdSectionStore(view);
  component_subscribe($$self, idSection, (value) => $$invalidate(4, $idSection = value));
  const editingStateStore = documentStateStore(view);
  component_subscribe($$self, editingStateStore, (value) => $$invalidate(2, $editingStateStore = value));
  const activePinnedCard = ActivePinnedCardStore(view);
  component_subscribe($$self, activePinnedCard, (value) => $$invalidate(1, $activePinnedCard = value));
  const pendingConfirmation = PendingConfirmationStore(view);
  component_subscribe($$self, pendingConfirmation, (value) => $$invalidate(3, $pendingConfirmation = value));
  const styleRules = NodeStylesStore(view);
  component_subscribe($$self, styleRules, (value) => $$invalidate(5, $styleRules = value));
  return [
    $pinnedNodesArray,
    $activePinnedCard,
    $editingStateStore,
    $pendingConfirmation,
    $idSection,
    $styleRules,
    pinnedNodesArray,
    idSection,
    editingStateStore,
    activePinnedCard,
    pendingConfirmation,
    styleRules
  ];
}
var Pinned_cards_sidebar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance102, create_fragment104, safe_not_equal, {}, add_css41);
  }
};
var pinned_cards_sidebar_default = Pinned_cards_sidebar;

// src/stores/view/derived/recent-nodes.ts
var ActiveRecentNodeStore = (view) => derived2(view.viewStore, (state2) => state2.recentNodes.activeNode);

// src/helpers/array-helpers/remove-duplicates-from-array.ts
var removeDuplicatesFromArray = (array, reverse = false) => {
  const uniqueItems = /* @__PURE__ */ new Set();
  const newArray = [];
  for (let i = array.length - 1; i >= 0; i--) {
    const item = array[i];
    if (!uniqueItems.has(item)) {
      newArray.push(item);
      uniqueItems.add(item);
    }
  }
  return reverse ? newArray : newArray.reverse();
};

// src/view/components/container/left-sidebar/components/recent-cards/recent-cards.svelte
function add_css42(target) {
  append_styles(target, "svelte-gdogae", ".recent-cards-container.svelte-gdogae{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;gap:20px;flex:1 1 auto;padding-bottom:10px;overflow-y:auto}");
}
function get_each_context17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_else_block12(ctx) {
  let noitems;
  let current;
  noitems = new no_items_default({ props: { variant: "recent" } });
  return {
    c() {
      create_component(noitems.$$.fragment);
    },
    m(target, anchor) {
      mount_component(noitems, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(noitems.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(noitems.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(noitems, detaching);
    }
  };
}
function create_if_block25(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*recentNodes*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[15]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context17(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block17(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*recentNodes, $activeRecentCard, $editingStateStore, $pendingConfirmation, $idSection, $styleRules*/
      125) {
        each_value = ensure_array_like(
          /*recentNodes*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block17, each_1_anchor, get_each_context17);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_each_block17(key_1, ctx) {
  let first;
  let node_1;
  let current;
  node_1 = new card_default({
    props: {
      node: (
        /*node*/
        ctx[15]
      ),
      active: (
        /*$activeRecentCard*/
        ctx[2] === /*node*/
        ctx[15] ? "node" /* node */ : "sibling" /* sibling */
      ),
      editing: (
        /*$editingStateStore*/
        ctx[3].activeNodeId === /*node*/
        ctx[15] && /*$editingStateStore*/
        ctx[3].isInSidebar === true
      ),
      confirmDisableEdit: (
        /*$editingStateStore*/
        ctx[3].activeNodeId === /*node*/
        ctx[15] && /*$pendingConfirmation*/
        ctx[4].disableEdit === /*node*/
        ctx[15] && /*$editingStateStore*/
        ctx[3].isInSidebar === true
      ),
      confirmDelete: (
        /*$pendingConfirmation*/
        ctx[4].deleteNode.has(
          /*node*/
          ctx[15]
        )
      ),
      isInSidebar: true,
      firstColumn: true,
      section: (
        /*$idSection*/
        ctx[5][
          /*node*/
          ctx[15]
        ]
      ),
      hasActiveChildren: false,
      hasChildren: false,
      selected: false,
      pinned: false,
      style: (
        /*$styleRules*/
        ctx[6].get(
          /*node*/
          ctx[15]
        )
      ),
      outlineMode: false,
      collapsed: false,
      hidden: false,
      alwaysShowCardButtons: true
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(node_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const node_1_changes = {};
      if (dirty & /*recentNodes*/
      1)
        node_1_changes.node = /*node*/
        ctx[15];
      if (dirty & /*$activeRecentCard, recentNodes*/
      5)
        node_1_changes.active = /*$activeRecentCard*/
        ctx[2] === /*node*/
        ctx[15] ? "node" /* node */ : "sibling" /* sibling */;
      if (dirty & /*$editingStateStore, recentNodes*/
      9)
        node_1_changes.editing = /*$editingStateStore*/
        ctx[3].activeNodeId === /*node*/
        ctx[15] && /*$editingStateStore*/
        ctx[3].isInSidebar === true;
      if (dirty & /*$editingStateStore, recentNodes, $pendingConfirmation*/
      25)
        node_1_changes.confirmDisableEdit = /*$editingStateStore*/
        ctx[3].activeNodeId === /*node*/
        ctx[15] && /*$pendingConfirmation*/
        ctx[4].disableEdit === /*node*/
        ctx[15] && /*$editingStateStore*/
        ctx[3].isInSidebar === true;
      if (dirty & /*$pendingConfirmation, recentNodes*/
      17)
        node_1_changes.confirmDelete = /*$pendingConfirmation*/
        ctx[4].deleteNode.has(
          /*node*/
          ctx[15]
        );
      if (dirty & /*$idSection, recentNodes*/
      33)
        node_1_changes.section = /*$idSection*/
        ctx[5][
          /*node*/
          ctx[15]
        ];
      if (dirty & /*$styleRules, recentNodes*/
      65)
        node_1_changes.style = /*$styleRules*/
        ctx[6].get(
          /*node*/
          ctx[15]
        );
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(node_1, detaching);
    }
  };
}
function create_fragment105(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block25, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*recentNodes*/
      ctx2[0].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "recent-cards-container svelte-gdogae");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[12](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[12](null);
    }
  };
}
var RECENT_NODES_LIMIT = 30;
function instance103($$self, $$props, $$invalidate) {
  let $activeRecentCard;
  let $editingStateStore;
  let $pendingConfirmation;
  let $idSection;
  let $styleRules;
  const view = getView();
  let recentNodes = [];
  let containerRef = null;
  const idSection = IdSectionStore(view);
  component_subscribe($$self, idSection, (value) => $$invalidate(5, $idSection = value));
  const editingStateStore = documentStateStore(view);
  component_subscribe($$self, editingStateStore, (value) => $$invalidate(3, $editingStateStore = value));
  const activeRecentCard = ActiveRecentNodeStore(view);
  component_subscribe($$self, activeRecentCard, (value) => $$invalidate(2, $activeRecentCard = value));
  const pendingConfirmation = PendingConfirmationStore(view);
  component_subscribe($$self, pendingConfirmation, (value) => $$invalidate(4, $pendingConfirmation = value));
  const styleRules = NodeStylesStore(view);
  component_subscribe($$self, styleRules, (value) => $$invalidate(6, $styleRules = value));
  const subscriptions = [];
  subscriptions.push(ActiveRecentNodeStore(view).subscribe((activeNodeId) => {
    setTimeout(
      () => {
        if (!containerRef)
          return;
        if (!activeNodeId)
          return;
        scrollCardIntoView(containerRef, activeNodeId);
      },
      200
    );
  }));
  subscriptions.push(navigationHistoryStore(view).subscribe((state2) => {
    const items = state2.items;
    if (items.length > RECENT_NODES_LIMIT) {
      const itemsToRemove = items.length - RECENT_NODES_LIMIT + 1;
      items.splice(0, itemsToRemove);
    }
    $$invalidate(0, recentNodes = removeDuplicatesFromArray(items, true));
  }));
  onDestroy(() => {
    for (const unsub of subscriptions) {
      unsub();
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerRef = $$value;
      $$invalidate(1, containerRef);
    });
  }
  return [
    recentNodes,
    containerRef,
    $activeRecentCard,
    $editingStateStore,
    $pendingConfirmation,
    $idSection,
    $styleRules,
    idSection,
    editingStateStore,
    activeRecentCard,
    pendingConfirmation,
    styleRules,
    div_binding
  ];
}
var Recent_cards = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance103, create_fragment105, safe_not_equal, {}, add_css42);
  }
};
var recent_cards_default = Recent_cards;

// src/view/components/container/left-sidebar/left-sidebar.svelte
function add_css43(target) {
  append_styles(target, "svelte-11s0o0n", ".sidebar.svelte-11s0o0n{--node-width:calc(var(--sidebar-width) - 40px);flex:0 0 auto;width:var(--animated-sidebar-width);position:relative;overflow:hidden;background-color:rgba(0, 0, 0, 0.2);background-blend-mode:multiply;display:flex;flex-direction:column;padding:10px 0;gap:10px}.width-transition.svelte-11s0o0n{transition:width 0.3s ease}.resizer.svelte-11s0o0n{position:absolute;top:0;height:100%;bottom:0;background-color:transparent;transition:background-color 0.2s;cursor:col-resize;right:0px;width:4px}.resizer.svelte-11s0o0n:hover{background-color:var(--color-accent)}.limit-card-height.svelte-11s0o0n{& .lng-prev {\n            max-height: 65vh;\n        };& .editor-container {\n            max-height: 65vh;\n        }}");
}
function create_if_block_18(ctx) {
  let recentcards;
  let current;
  recentcards = new recent_cards_default({});
  return {
    c() {
      create_component(recentcards.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recentcards, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(recentcards.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recentcards.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recentcards, detaching);
    }
  };
}
function create_if_block26(ctx) {
  let pinnedcards;
  let current;
  pinnedcards = new pinned_cards_sidebar_default({});
  return {
    c() {
      create_component(pinnedcards.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pinnedcards, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pinnedcards.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pinnedcards.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pinnedcards, detaching);
    }
  };
}
function create_fragment106(ctx) {
  let div1;
  let tabheader;
  let t0;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  tabheader = new tab_header_default({});
  const if_block_creators = [create_if_block26, create_if_block_18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$activeTab*/
      ctx2[4] === "pinned-cards"
    )
      return 0;
    if (
      /*$activeTab*/
      ctx2[4] === "recent-cards"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      create_component(tabheader.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "resizer svelte-11s0o0n");
      attr(div1, "class", div1_class_value = null_to_empty("sidebar" + /*isResizing*/
      (ctx[2] ? "" : " width-transition") + /*$limitPreviewHeight*/
      (ctx[3] ? " limit-card-height" : "")) + " svelte-11s0o0n");
      attr(div1, "style", div1_style_value = "--animated-sidebar-width: " + /*animatedSidebarWidth*/
      ctx[0] + "px; --sidebar-width: " + /*sidebarWidth*/
      ctx[1] + "px; }");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(tabheader, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "mousedown",
          /*onStartResize*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & /*isResizing, $limitPreviewHeight*/
      12 && div1_class_value !== (div1_class_value = null_to_empty("sidebar" + /*isResizing*/
      (ctx2[2] ? "" : " width-transition") + /*$limitPreviewHeight*/
      (ctx2[3] ? " limit-card-height" : "")) + " svelte-11s0o0n")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*animatedSidebarWidth, sidebarWidth*/
      3 && div1_style_value !== (div1_style_value = "--animated-sidebar-width: " + /*animatedSidebarWidth*/
      ctx2[0] + "px; --sidebar-width: " + /*sidebarWidth*/
      ctx2[1] + "px; }")) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tabheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(tabheader);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
}
var MIN_WIDTH2 = 250;
function instance104($$self, $$props, $$invalidate) {
  let $limitPreviewHeight;
  let $activeTab;
  let animatedSidebarWidth = 0;
  let sidebarWidth = MIN_WIDTH2;
  let isResizing = false;
  let startX = 0;
  const view = getView();
  const limitPreviewHeight = limitPreviewHeightStore(view);
  component_subscribe($$self, limitPreviewHeight, (value) => $$invalidate(3, $limitPreviewHeight = value));
  const showSidebarStore = ShowLeftSidebarStore(view);
  const unsub = showSidebarStore.subscribe((show) => {
    if (show) {
      $$invalidate(0, animatedSidebarWidth = view.plugin.settings.getValue().view.leftSidebarWidth);
      $$invalidate(1, sidebarWidth = animatedSidebarWidth);
    } else {
      $$invalidate(0, animatedSidebarWidth = 0);
    }
  });
  onDestroy(() => {
    unsub();
  });
  const onStartResize = (event) => {
    $$invalidate(2, isResizing = true);
    startX = event.clientX;
    view.contentEl.addEventListener("mousemove", onResize);
    view.contentEl.addEventListener("mouseup", onStopResize);
  };
  const onResize = (event) => {
    if (!isResizing)
      return;
    const dx = event.clientX - startX;
    $$invalidate(0, animatedSidebarWidth += dx);
    startX = event.clientX;
    if (animatedSidebarWidth > MIN_WIDTH2) {
      $$invalidate(1, sidebarWidth = animatedSidebarWidth);
    }
  };
  const onStopResize = () => {
    $$invalidate(2, isResizing = false);
    view.contentEl.removeEventListener("mousemove", onResize);
    view.contentEl.removeEventListener("mouseup", onStopResize);
    if (animatedSidebarWidth < MIN_WIDTH2) {
      $$invalidate(0, animatedSidebarWidth = MIN_WIDTH2);
    }
    $$invalidate(1, sidebarWidth = animatedSidebarWidth);
    view.plugin.settings.dispatch({
      type: "view/left-sidebar/set-width",
      payload: { width: animatedSidebarWidth }
    });
  };
  const activeTab = LeftSidebarActiveTabStore(view);
  component_subscribe($$self, activeTab, (value) => $$invalidate(4, $activeTab = value));
  return [
    animatedSidebarWidth,
    sidebarWidth,
    isResizing,
    $limitPreviewHeight,
    $activeTab,
    limitPreviewHeight,
    onStartResize,
    activeTab
  ];
}
var Left_sidebar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance104, create_fragment106, safe_not_equal, {}, add_css43);
  }
};
var left_sidebar_default = Left_sidebar;

// src/view/actions/context-menu/show-context-menu.ts
var import_obsidian27 = require("obsidian");

// src/helpers/on-long-press.ts
var onLongPress = (element2, callback, preventDefaultPredicate) => {
  const state2 = { timer: null, longPress: false };
  const onTouchEnd = (e) => {
    if (state2.longPress) {
      state2.longPress = false;
      if (preventDefaultPredicate(e)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
    if (state2.timer)
      clearTimeout(state2.timer);
  };
  const onTouchStart = (e) => {
    if (state2.timer)
      clearTimeout(state2.timer);
    state2.timer = setTimeout(() => {
      state2.longPress = true;
      callback(e);
    }, 500);
  };
  element2.addEventListener("touchstart", onTouchStart);
  element2.addEventListener("touchend", onTouchEnd);
  element2.addEventListener("touchmove", onTouchEnd);
  return () => {
    element2.removeEventListener("touchstart", onTouchStart);
    element2.removeEventListener("touchend", onTouchEnd);
    element2.removeEventListener("touchmove", onTouchEnd);
  };
};

// src/obsidian/context-menu/render-context-menu.ts
var import_obsidian22 = require("obsidian");
var addMenuItem = (menu, menuItem) => {
  if ("type" in menuItem && menuItem.type === "separator") {
    menu.addSeparator();
  } else if ("title" in menuItem) {
    menu.addItem((item) => {
      item.setTitle(menuItem.title).setIcon(menuItem.icon).setDisabled(menuItem.disabled || false).setChecked(menuItem.checked || false);
      if ("submenu" in menuItem) {
        const subMenu = item.setSubmenu();
        for (const subItem of menuItem.submenu) {
          addMenuItem(subMenu, subItem);
        }
      } else {
        item.onClick(menuItem.action);
      }
      if (menuItem.dangerous) {
        if ("dom" in item) {
          item.dom.classList.add("is-warning");
        }
      }
    });
  }
};
var renderContextMenu = (event, menuItems) => {
  const menu = new import_obsidian22.Menu();
  for (const menuItem of menuItems) {
    addMenuItem(menu, menuItem);
  }
  menu.showAtMouseEvent(event);
};

// src/obsidian/context-menu/select-inactive-card.ts
var selectInactiveCard = (view, closestCardElement, isInSidebar, isInRecentCardsList) => {
  const id2 = closestCardElement?.id;
  if (!isInSidebar) {
    view.viewStore.dispatch({
      type: "view/set-active-node/mouse-silent",
      payload: {
        id: id2
      }
    });
  } else if (isInRecentCardsList) {
    view.viewStore.dispatch({
      type: "view/recent-nodes/set-active-node",
      payload: {
        id: id2
      }
    });
  } else {
    view.viewStore.dispatch({
      type: "view/pinned-nodes/set-active-node",
      payload: {
        id: id2
      }
    });
  }
};

// src/obsidian/events/workspace/effects/create-new-file.ts
var import_obsidian23 = require("obsidian");

// src/helpers/sanitize-file-name.ts
var sanitizeFileName = (path, replacement = "-") => {
  const illegalCharacters = /[*"\\/<>:|?]/g;
  const unsafeCharactersForObsidianLinks = /[#^[\]|]/g;
  const dotAtTheStart = /^\./g;
  const controlRe = /[\x00-\x1f\x80-\x9f]/g;
  const reservedRe = /^\.+$/;
  const windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
  const windowsTrailingRe = /[. ]+$/;
  let sanitized = path.replace(/"/g, "'").replace(illegalCharacters, replacement).replace(unsafeCharactersForObsidianLinks, replacement).replace(dotAtTheStart, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
  if (replacement)
    sanitized = sanitized.replace(new RegExp(`${replacement}+`, "g"), replacement).replace(
      new RegExp(`^${replacement}(.)|(.)${replacement}$`, "g"),
      "$1$2"
    );
  return sanitized.trim();
};

// src/obsidian/events/workspace/effects/get-unique-file-name.ts
var getUniqueFileName = (folderPath, files, basename) => {
  basename = sanitizeFileName(basename);
  let index = 1;
  let newFileName = basename;
  while (files.includes(`${newFileName}`)) {
    newFileName = `${basename} (${index})`;
    index++;
  }
  return `${folderPath}/${newFileName}`;
};

// src/obsidian/events/workspace/effects/create-new-file.ts
var createNewFile = async (plugin, folder, data = "", basename = "Untitled") => {
  invariant(folder);
  const children2 = folder.children.map(
    (c) => c instanceof import_obsidian23.TFile && c.extension === "md" ? c.basename : null
  ).filter((f) => f);
  const path = getUniqueFileName(folder.path, children2, basename);
  const newFilePath = path + ".md";
  const file = await plugin.app.vault.create(newFilePath, data);
  invariant(file);
  return file;
};

// src/obsidian/events/workspace/effects/open-file.ts
var openFile = async (plugin, file, newLeaf) => {
  const leaf = plugin.app.workspace.getLeaf(newLeaf);
  await leaf.openFile(file);
  return leaf;
};

// src/view/actions/context-menu/card-context-menu/helpers/export-selection.ts
var exportSelection = async (view, includeSubItems) => {
  const viewState = view.viewStore.getValue();
  const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
  if (isEditing2) {
    saveNodeContent(view);
    setTimeout(() => {
      exportSelection(view, includeSubItems);
    }, 100);
    return;
  }
  let text2 = "";
  const nodes = getActiveNodes(view, false);
  if (includeSubItems) {
    text2 = mapBranchesToText(
      view.documentStore.getValue().document,
      nodes,
      "unformatted-text"
    );
  } else {
    text2 = getTextOfFlatNodes(view, nodes, false);
  }
  const file = view.file;
  const newFile = await createNewFile(
    view.plugin,
    file.parent,
    text2,
    `${file.basename} - exported selection`
  );
  await openFile(view.plugin, newFile, "split");
};

// src/view/actions/context-menu/card-context-menu/create-multiple-nodes-context-menu.ts
var createMultipleNodesContextMenu = (view) => {
  const menuItems = [
    {
      title: lang.cm_copy,
      icon: "documents",
      submenu: [
        {
          title: lang.cm_copy_branches,
          icon: "lineage-cards",
          action: () => copyActiveBranchesToClipboard(view, true, false)
        },
        {
          title: lang.cm_copy_branches_wo_formatting,
          icon: "file-text",
          action: () => copyActiveBranchesToClipboard(view, false, false)
        },
        {
          title: lang.cm_copy_node_wo_subitems,
          icon: "file-text",
          action: () => copyActiveNodesToClipboard(view, false)
        }
      ]
    },
    {
      title: lang.cm_cut,
      icon: "scissors",
      action: () => cutNode(view)
    },
    { type: "separator" },
    {
      title: lang.cm_export_selection,
      icon: "file-text",
      submenu: [
        {
          title: lang.cmd_export_branches_with_subitems,
          icon: "file-text",
          action: () => exportSelection(view, true)
        },
        {
          title: lang.cmd_export_nodes_wo_subitems,
          icon: "file-text",
          action: () => exportSelection(view, false)
        }
      ]
    }
  ];
  return menuItems;
};

// src/view/actions/context-menu/card-context-menu/helpers/insert-block-id.ts
var getExistingBlockId = (lines) => {
  const reversed = [...lines].reverse();
  for (let line of reversed) {
    line = line.trim();
    const match = /\s+\^([a-zA-Z0-9]{4,})$/.exec(line);
    if (match) {
      return match[1];
    }
  }
};
var generateBlockId = () => Math.random().toString(36).substring(2, 8);
var insertBlockId = (text2, __id__) => {
  const lines = text2.trimEnd().split("\n");
  const existingId = getExistingBlockId(lines);
  if (existingId) {
    return {
      blockId: existingId,
      text: text2
    };
  } else {
    const lastLine = lines[lines.length - 1];
    let blockId = null;
    if (lastLine) {
      blockId = __id__ || generateBlockId();
      lines[lines.length - 1] = lines[lines.length - 1] + ` ^${blockId}`;
      return {
        blockId,
        text: lines.join("\n")
      };
    }
  }
};

// src/view/actions/context-menu/card-context-menu/helpers/copy-link-to-block.ts
var import_obsidian24 = require("obsidian");
var copyLinkToBlock = async (view, isInSidebar) => {
  const file = view.file;
  if (!file)
    return;
  const viewState = view.viewStore.getValue();
  const activeTab = view.plugin.settings.getValue().view.leftSidebarActiveTab;
  const activeNode = isInSidebar ? activeTab === "pinned-cards" ? viewState.pinnedNodes.activeNode : viewState.recentNodes.activeNode : viewState.document.activeNode;
  const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
  if (isEditing2) {
    saveNodeContent(view);
    setTimeout(() => {
      copyLinkToBlock(view, isInSidebar);
    }, 100);
    return;
  }
  const documentState = view.documentStore.getValue();
  const content = documentState.document.content[activeNode];
  const text2 = content?.content;
  const output = insertBlockId(text2);
  if (output) {
    const fileName = file.basename;
    view.documentStore.dispatch({
      type: "document/update-node-content",
      payload: {
        content: output.text,
        nodeId: activeNode
      },
      context: {
        isInSidebar: viewState.document.editing.isInSidebar
      }
    });
    const link = `[[${fileName}#^${output.blockId}]]`;
    await navigator.clipboard.writeText(link);
    new import_obsidian24.Notice("Copied");
  } else {
    new import_obsidian24.Notice("Could not copy link to clipboard");
  }
};

// src/view/actions/context-menu/card-context-menu/create-sidebar-context-menu-items.ts
var togglePinNode = (view, activeNode, isPinned, isInSidebar) => {
  const viewState = view.viewStore.getValue();
  const id2 = isInSidebar ? viewState.pinnedNodes.activeNode : activeNode;
  view.documentStore.dispatch({
    type: isPinned ? "document/pinned-nodes/unpin" : "document/pinned-nodes/pin",
    payload: { id: id2 }
  });
};
var createSidebarContextMenuItems = (view, { isPinned, activeNode, isInRecentCardsList }) => {
  const menuItems = [
    {
      title: lang.cm_copy_link_to_block,
      icon: "links-coming-in",
      action: () => copyLinkToBlock(view, true)
    },
    { type: "separator" },
    {
      title: lang.cm_copy,
      icon: "documents",
      action: () => copyActiveNodesToClipboard(view, true)
    },
    { type: "separator" },
    {
      title: isPinned ? lang.cm_unpin_from_left_sidebar : lang.cm_pin_in_left_sidebar,
      icon: isPinned ? "pin-off" : "pin",
      action: () => togglePinNode(view, activeNode, isPinned, true),
      disabled: isInRecentCardsList
    },
    { type: "separator" }
  ];
  return menuItems;
};

// src/view/actions/context-menu/card-context-menu/create-single-node-context-menu-items.ts
var import_obsidian26 = require("obsidian");

// src/view/modals/split-node-modal/split-node-modal.ts
var import_obsidian25 = require("obsidian");

// src/view/modals/split-node-modal/helpers/get-modal-state.ts
var getModalState = () => {
  return getContext("modal-state");
};

// src/view/modals/split-node-modal/components/components/content-preview.svelte
function add_css44(target) {
  append_styles(target, "svelte-20u69o", ".preview.svelte-20u69o{flex-grow:1;max-height:500px;overflow:auto}");
}
function create_if_block27(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "This section does not match any splitting pattern";
      attr(p, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment107(ctx) {
  let div0;
  let t;
  let div1;
  let if_block = !/*$mode*/
  ctx[0] && create_if_block27(ctx);
  return {
    c() {
      div0 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div1 = element("div");
      attr(div1, "class", "preview svelte-20u69o");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (if_block)
        if_block.m(div0, null);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      div1.innerHTML = /*$content*/
      ctx[1];
    },
    p(ctx2, [dirty]) {
      if (!/*$mode*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$content*/
      2)
        div1.innerHTML = /*$content*/
        ctx2[1];
      ;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t);
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance105($$self, $$props, $$invalidate) {
  let $mode;
  let $content;
  const state2 = getModalState();
  const mode = state2.mode;
  component_subscribe($$self, mode, (value) => $$invalidate(0, $mode = value));
  const content = state2.content;
  component_subscribe($$self, content, (value) => $$invalidate(1, $content = value));
  return [$mode, $content, mode, content];
}
var Content_preview = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance105, create_fragment107, safe_not_equal, {}, add_css44);
  }
};
var content_preview_default = Content_preview;

// src/view/modals/split-node-modal/helpers/get-modal-props.ts
var getModalProps = () => {
  return getContext("modal-props");
};

// src/view/modals/split-node-modal/components/components/modal-buttons.svelte
function add_css45(target) {
  append_styles(target, "svelte-6fani8", ".split-content-footer.svelte-6fani8{display:flex;align-items:center;justify-content:space-between}.modes-container.svelte-6fani8{height:50px;display:flex;align-items:center}.buttons-container.svelte-6fani8{display:flex;gap:5px;width:fit-content}label.svelte-6fani8{display:block;text-transform:capitalize}label[data-disabled='true'].svelte-6fani8{opacity:0.6}");
}
function get_each_context18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block18(ctx) {
  let label;
  let input;
  let input_checked_value;
  let input_disabled_value;
  let input_value_value;
  let t0;
  let t1_value = (
    /*_mode*/
    ctx[10] + ""
  );
  let t1;
  let t2;
  let label_data_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      input.checked = input_checked_value = /*$mode*/
      ctx[0] === /*_mode*/
      ctx[10];
      input.disabled = input_disabled_value = /*disabledModes*/
      ctx[4].has(
        /*_mode*/
        ctx[10]
      );
      attr(input, "name", "mode");
      attr(input, "type", "radio");
      input.value = input_value_value = /*_mode*/
      ctx[10];
      attr(input, "tabindex", "0");
      attr(label, "data-disabled", label_data_disabled_value = /*disabledModes*/
      ctx[4].has(
        /*_mode*/
        ctx[10]
      ));
      attr(label, "class", "svelte-6fani8");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$mode*/
      1 && input_checked_value !== (input_checked_value = /*$mode*/
      ctx2[0] === /*_mode*/
      ctx2[10])) {
        input.checked = input_checked_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment108(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let button0;
  let t1;
  let button0_disabled_value;
  let t2;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*modes*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block18(get_each_context18(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      button0 = element("button");
      t1 = text("Split");
      t2 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(div0, "class", "modes-container svelte-6fani8");
      attr(div0, "tabindex", "0");
      attr(button0, "class", "mod-cta");
      button0.disabled = button0_disabled_value = !/*$mode*/
      ctx[0];
      attr(div1, "class", "buttons-container svelte-6fani8");
      attr(div2, "class", "split-content-footer svelte-6fani8");
      attr(div2, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      append(div1, button0);
      append(button0, t1);
      append(div1, t2);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*disabledModes, modes, $mode, onModeChange*/
      53) {
        each_value = ensure_array_like(
          /*modes*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context18(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block18(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$mode*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$mode*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance106($$self, $$props, $$invalidate) {
  let $mode;
  const state2 = getModalState();
  const props = getModalProps();
  const onModeChange = (value) => {
    state2.mode.set(value);
  };
  const mode = state2.mode;
  component_subscribe($$self, mode, (value) => $$invalidate(0, $mode = value));
  const disabledModes = state2.disabledModes;
  const modes = ["headings", "outline", "blocks"];
  const change_handler = (e) => onModeChange(e.currentTarget.value);
  const click_handler = () => props.callbacks.accept();
  const click_handler_1 = () => props.callbacks.reject();
  return [
    $mode,
    props,
    onModeChange,
    mode,
    disabledModes,
    modes,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
var Modal_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance106, create_fragment108, safe_not_equal, {}, add_css45);
  }
};
var modal_buttons_default = Modal_buttons;

// src/view/modals/split-node-modal/components/modal-content.svelte
function add_css46(target) {
  append_styles(target, "svelte-1axt1o3", ".split-content-modal.svelte-1axt1o3{display:flex;flex-direction:column}");
}
function create_fragment109(ctx) {
  let div;
  let content;
  let t;
  let buttons;
  let current;
  content = new content_preview_default({});
  buttons = new modal_buttons_default({});
  return {
    c() {
      div = element("div");
      create_component(content.$$.fragment);
      t = space();
      create_component(buttons.$$.fragment);
      attr(div, "class", "split-content-modal svelte-1axt1o3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(content, div, null);
      append(div, t);
      mount_component(buttons, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(content);
      destroy_component(buttons);
    }
  };
}
function instance107($$self, $$props, $$invalidate) {
  let { state: state2 } = $$props;
  let { props } = $$props;
  setContext("modal-state", state2);
  setContext("modal-props", props);
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state2 = $$props2.state);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  return [state2, props];
}
var Modal_content = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance107, create_fragment109, safe_not_equal, { state: 0, props: 1 }, add_css46);
  }
};
var modal_content_default = Modal_content;

// src/lib/format-detection/has-n-headings.ts
var hasNHeadings = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (/^((\t*)- )?#+ +/.test(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/is-outline.ts
var isOutline = (text2) => {
  const lines = text2.split("\n").filter((x) => x.trim());
  if (lines.length <= 1)
    return false;
  let level2 = 0;
  for (const line of lines) {
    if (!line)
      continue;
    const match = line.match(/^(\t*)- (.*)/);
    if (match) {
      const itemLevel = match[1].length + 1;
      if (itemLevel - level2 > 1) {
        return false;
      }
      level2 = itemLevel;
    } else {
      const match2 = line.match(/^(\t*) {2}/);
      if (match2) {
        const itemLevel = (match2[1] ? match2[1].length : 0) + 1;
        if (itemLevel !== level2) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
};

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, void 0, 0);
        } else {
          basePath = self.addToPath(removePath, void 0, true, 1);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last = path.lastComponent;
    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join(chars) {
    return chars.join("");
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
var characterDiff = new Diff();
function generateOptions(options, defaults) {
  if (typeof options === "function") {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }
  return defaults;
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i = 0; i < tokens.length - 1; i++) {
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }
  return tokens;
};
function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  if (this.options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// src/lib/data-conversion/x-to-json/outline-to-json.ts
var addNewNode = (state2, level2, text2, root = 1) => {
  state2.currentNode = {
    content: text2,
    children: []
  };
  for (const key of Object.keys(state2.currentParents)) {
    const parentLevel = +key;
    if (parentLevel >= level2) {
      delete state2.currentParents[key];
    }
  }
  if (level2 === root) {
    state2.tree.push(state2.currentNode);
  }
  state2.currentParents[level2] = state2.currentNode;
  const parent = state2.currentParents[level2 - 1];
  if (parent) {
    parent.children.push(state2.currentNode);
  } else if (level2 > root)
    throw new Error(`Item [${text2}] does not have a parent`);
};
var updateCurrentNode = (state2, text2) => {
  if (state2.currentNode) {
    if (state2.currentNode.content)
      state2.currentNode.content += "\n";
    state2.currentNode.content += text2;
  } else if (text2.trim()) {
    state2.currentNode = {
      content: text2,
      children: []
    };
    state2.tree.push(state2.currentNode);
  }
};
var outlineToJson = (input) => {
  const lines = input.split("\n");
  const state2 = {
    currentParents: {},
    currentNode: null,
    tree: []
  };
  for (const line of lines) {
    if (parseHtmlCommentMarker(line))
      throw new Error("Outline has a section annotation");
    const outlineMatch = line.match(/^(\t*)- (.*)/);
    if (outlineMatch) {
      const level2 = outlineMatch[1].length + 1;
      addNewNode(state2, level2, outlineMatch[2]);
    } else {
      updateCurrentNode(state2, line.replace(/^\t* {2}|/g, ""));
    }
  }
  return state2.tree;
};

// src/lib/data-conversion/helpers/find-highest-heading-level.ts
var findHighestHeadingLevel = (lines) => {
  let isInCodeBlock = false;
  return lines.reduce((acc, val) => {
    if (val.startsWith("```")) {
      isInCodeBlock = !isInCodeBlock;
    }
    if (isInCodeBlock)
      return acc;
    const match = val.match(/^(#+) +(.*)$/);
    if (match) {
      const level2 = match[1].length;
      if (level2 < acc)
        acc = level2;
    }
    return acc;
  }, 6);
};

// src/lib/data-conversion/x-to-json/headings-to-json.ts
var headingsToJson = (input) => {
  const lines = input.split("\n");
  const highestHeadingLevel = findHighestHeadingLevel(lines);
  const state2 = {
    currentParents: {},
    currentNode: null,
    tree: [],
    isInCodeBlock: false
  };
  for (const line of lines) {
    if (parseHtmlCommentMarker(line))
      throw new Error("input has a section");
    if (line.startsWith("```")) {
      state2.isInCodeBlock = !state2.isInCodeBlock;
    }
    const match = state2.isInCodeBlock ? null : line.match(/^(#+) (.+)/);
    if (match) {
      const level2 = match[1].length;
      addNewNode(state2, level2, line, highestHeadingLevel);
    } else {
      updateCurrentNode(state2, line);
    }
  }
  return state2.tree;
};

// src/lib/data-conversion/helpers/correct-headings.ts
var correctHeadings = (markdown) => {
  const lines = markdown.split("\n");
  const headingRegex = /^(#+) +(.*)$/;
  const highestHeadingLevel = findHighestHeadingLevel(lines);
  const state2 = {
    previousLevel: 0,
    previousCorrectedLevel: 0,
    previousLevels: [],
    isInCodeBlock: false
  };
  const updatedLines = [];
  for (const line of lines) {
    if (line.startsWith("```")) {
      state2.isInCodeBlock = !state2.isInCodeBlock;
    }
    const match = state2.isInCodeBlock ? null : line.match(headingRegex);
    let updatedLine = null;
    if (match) {
      const level2 = match[1].length;
      const text2 = match[2];
      let correctedLevel;
      const parentIndex = state2.previousLevels.findLastIndex(
        (l) => l.level < level2
      );
      const parent = state2.previousLevels[parentIndex];
      if (!parent) {
        correctedLevel = highestHeadingLevel;
      } else if (level2 > state2.previousLevel) {
        correctedLevel = state2.previousCorrectedLevel + 1;
      } else if (level2 < state2.previousLevel) {
        correctedLevel = Math.min(
          highestHeadingLevel,
          level2,
          state2.previousCorrectedLevel - 1
        );
        if (parent) {
          if (correctedLevel <= parent.level && level2 > parent.level) {
            correctedLevel = parent.correctedLevel + 1;
          }
        }
      } else if (level2 === state2.previousLevel) {
        correctedLevel = state2.previousCorrectedLevel;
      } else {
        correctedLevel = level2;
      }
      updatedLine = `${"#".repeat(correctedLevel)} ${text2}`;
      state2.previousLevel = level2;
      state2.previousCorrectedLevel = correctedLevel;
      state2.previousLevels.push({ level: level2, correctedLevel });
    }
    if (updatedLine)
      updatedLines.push(updatedLine);
    else
      updatedLines.push(line);
  }
  return updatedLines.join("\n");
};

// src/lib/data-conversion/x-to-html-comment/headings-to-html-comment.ts
var headingsToHtmlComment = (input) => {
  const tree = headingsToJson(correctHeadings(input));
  if (tree.length === 1 && tree[0].children.length === 0)
    return input;
  return jsonToHtmlComment(tree);
};

// src/lib/data-conversion/x-to-html-comment/paragraphs-to-html-comment.ts
var splitByParagraph = (text2) => {
  const codeBlockRegex = /```[\s\S]*?```/g;
  const codeBlocks = [];
  const textWithPlaceholders = text2.replace(codeBlockRegex, (match) => {
    codeBlocks.push(match);
    return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
  });
  const paragraphs = textWithPlaceholders.split(/\n\s*\n/).map((paragraph) => {
    return paragraph.replace(
      /__CODE_BLOCK_(\d+)__/g,
      (_, index) => codeBlocks[+index]
    );
  });
  return paragraphs;
};
var paragraphsToHtmlComment = (input) => {
  const paragraphs = splitByParagraph(input);
  if (paragraphs.length === 1)
    return input;
  const tree = paragraphs.map((p) => ({
    content: p,
    children: []
  }));
  return jsonToHtmlComment(tree);
};

// src/lib/data-conversion/x-to-html-comment/outline-to-html-comment.ts
var outlineToHtmlComment = (input) => {
  const tree = outlineToJson(input);
  if (tree.length === 1 && tree[0].children.length === 0)
    return input;
  return jsonToHtmlComment(tree);
};

// src/stores/document/reducers/split-node/helpers/split-text.ts
var splitText = (text2, mode) => {
  if (mode === "headings") {
    return headingsToHtmlComment(text2);
  } else if (mode === "blocks") {
    return paragraphsToHtmlComment(text2);
  } else {
    return outlineToHtmlComment(text2);
  }
};

// src/view/modals/split-node-modal/helpers/map-content.ts
var escapeHtmlComment = (text2) => {
  return text2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
};
var makeTabsVisible = (text2) => {
  return text2.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
};
var makeNewlinesVisible = (text2) => {
  return text2.replace(/\n/g, "<br>");
};
var mapContent = (text2, mode) => {
  let newContent = text2;
  if (mode) {
    try {
      newContent = splitText(text2, mode);
    } catch (e) {
      onPluginError(e, "command", { text: text2, mode });
    }
  }
  const differences = diffWords(text2, newContent);
  return differences.map((part) => {
    const style = part.added ? "color:green; background-color:lightgreen" : part.removed ? "color:red; background-color:#ffdddd" : "color: grey";
    const escapedComments = escapeHtmlComment(part.value);
    const visibleTabs = makeTabsVisible(escapedComments);
    const value = makeNewlinesVisible(visibleTabs);
    return `<span style="${style}">${value}</span>`;
  }).join("");
};

// src/lib/format-detection/has-n-paragraph.ts
var hasNParagraph = (text2, n = 2) => splitByParagraph(text2).length >= n;

// src/view/modals/split-node-modal/split-node-modal.ts
var SplitNodeModal = class extends import_obsidian25.Modal {
  constructor(props) {
    super(props.plugin.app);
    this.props = props;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.open = () => {
      this.setTitle("Choose how to split this section");
      this.initState();
      new modal_content_default({
        target: this.contentEl,
        props: {
          state: this.state,
          props: this.props
        }
      });
      const promise = new Promise((resolve) => {
        this.resolve = resolve;
      });
      super.open();
      return promise;
    };
    this.close = () => {
      this.resolve(void 0);
      super.close();
      for (const unsub of this.subscriptions) {
        unsub();
      }
    };
    this.initState = () => {
      const content = this.props.nodeContent;
      this.state = {
        content: writable(content),
        mode: writable(null),
        disabledModes: /* @__PURE__ */ new Set()
      };
      const hasHeadings = hasNHeadings(content);
      const _isOutline = isOutline(content);
      const hasParagraphs = hasNParagraph(content);
      if (!hasHeadings) {
        this.state.disabledModes.add("headings");
      }
      if (!_isOutline) {
        this.state.disabledModes.add("outline");
      }
      if (!hasParagraphs) {
        this.state.disabledModes.add("blocks");
      }
      if (hasHeadings) {
        this.state.mode.set("headings");
      } else if (_isOutline) {
        this.state.mode.set("outline");
      } else if (hasParagraphs) {
        this.state.mode.set("blocks");
      }
      const unsubFromMod = this.state.mode.subscribe((mode) => {
        if (mode)
          this.state.content.set(mapContent(content, mode));
      });
      this.state.content.set(mapContent(content, get_store_value(this.state.mode)));
      this.subscriptions.add(unsubFromMod);
    };
  }
};

// src/view/modals/split-node-modal/open-split-node-modal.ts
var openSplitNodeModal = async (view) => {
  const viewState = view.viewStore.getValue();
  const activeNode = viewState.document.activeNode;
  if (!activeNode)
    return;
  const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
  if (isEditing2) {
    saveNodeContent(view);
    setTimeout(() => {
      openSplitNodeModal(view);
    }, 100);
    return;
  }
  const documentState = view.documentStore.getValue();
  const nodeContent = documentState.document.content[activeNode].content;
  const modal = new SplitNodeModal({
    plugin: view.plugin,
    callbacks: {
      accept: () => {
        modal.close();
        const newContent = get_store_value(modal.state.content);
        const mode = get_store_value(modal.state.mode);
        if (mode && newContent !== nodeContent) {
          view.documentStore.dispatch({
            type: "document/split-node",
            payload: {
              target: activeNode,
              mode
            }
          });
        }
      },
      reject: () => {
        modal.close();
      }
    },
    nodeContent
  });
  await modal.open();
};

// src/view/actions/context-menu/card-context-menu/helpers/sort-child-nodes.ts
var sortChildNodes = (view, activeNode, order) => {
  view.documentStore.dispatch({
    type: "document/sort-direct-child-nodes",
    payload: {
      id: activeNode,
      order
    }
  });
};

// src/obsidian/events/workspace/effects/toggle-obsidian-view-type.ts
var toggleObsidianViewType = (plugin, leaf, type) => {
  setTimeout(() => {
    leaf.setViewState({
      type,
      popstate: true,
      state: leaf.view.getState()
    });
    plugin.app.workspace.setActiveLeaf(leaf);
  }, 0);
};

// src/stores/settings/actions/set-document-format.ts
var setDocumentFormat = (plugin, path, type) => {
  plugin.settings.dispatch({
    type: "settings/documents/set-document-format",
    payload: {
      path,
      format: type
    }
  });
};

// src/obsidian/events/workspace/effects/open-file-in-lineage.ts
var openFileInLineage = async (plugin, file, type, newLeaf) => {
  const leaf = await openFile(plugin, file, newLeaf);
  toggleObsidianViewType(plugin, leaf, "lineage");
  setDocumentFormat(plugin, file.path, type);
};

// src/obsidian/commands/helpers/extract-branch/helpers/get-file-name-of-extracted-branch/get-file-name-from-content.ts
var getFileNameFromContent = (text2) => {
  const lines = text2.split("\n").map((line) => line.trim().replace(/\s+/g, " ")).filter((line) => line);
  if (lines.length === 0)
    return;
  let result = void 0;
  const headingLine = lines.find((line) => /^(#+)\s(.+)/.test(line));
  if (headingLine) {
    const headingMatch = headingLine.match(/^(#+)\s(.+)/);
    result = headingMatch[2];
  } else if (lines[0].startsWith("- ")) {
    result = lines[0].replace(/^- /, "");
  } else {
    result = lines.join(" ");
  }
  return result.substring(0, 100).trim();
};

// src/obsidian/commands/helpers/extract-branch/helpers/get-file-name-of-extracted-branch/get-file-name-of-extracted-branch.ts
var getFileNameOfExtractedBranch = (nodeContent, currentFileName, sectionNumber) => {
  const name = getFileNameFromContent(nodeContent);
  if (name)
    return name;
  return `${currentFileName.trim()} - ${sectionNumber}`;
};

// src/obsidian/commands/helpers/extract-branch/extract-branch.ts
var extractBranch = async (view) => {
  try {
    invariant(view.file);
    invariant(view.file.parent);
    const viewState = view.viewStore.getValue();
    const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
    if (isEditing2) {
      saveNodeContent(view);
      setTimeout(() => {
        extractBranch(view);
      }, 100);
      return;
    }
    const documentState = view.documentStore.getValue();
    const branch = getBranch(
      documentState.document.columns,
      documentState.document.content,
      viewState.document.activeNode,
      "copy"
    );
    const format2 = getPersistedDocumentFormat(view);
    const text2 = format2 === "outline" ? branchToOutline([branch]) : format2 === "html-element" ? branchToHtmlElement([branch]) : branchToHtmlComment([branch]);
    const fileName = getFileNameOfExtractedBranch(
      branch.content[branch.nodeId].content,
      view.file.basename,
      documentState.sections.id_section[branch.nodeId]
    );
    const newFile = await createNewFile(
      view.plugin,
      view.file.parent,
      text2,
      fileName
    );
    await openFileInLineage(view.plugin, newFile, format2, "split");
    view.documentStore.dispatch({
      type: "document/extract-node",
      payload: {
        nodeId: branch.nodeId,
        documentName: newFile.basename
      }
    });
  } catch (e) {
    onPluginError(e, "command", { type: "extract-branch" });
  }
};

// src/view/actions/context-menu/card-context-menu/create-single-node-context-menu-items.ts
var createSingleNodeContextMenuItems = (view, { hasChildren, isPinned, activeNode }) => {
  const menuItems = [
    {
      title: lang.cm_split_node,
      icon: customIcons.split.name,
      action: () => {
        if (hasChildren) {
          new import_obsidian26.Notice(lang.error_cm_cant_split_node_that_has_children);
        } else {
          openSplitNodeModal(view);
        }
      }
    },
    {
      title: lang.cm_sort_child,
      icon: "sort-asc",
      disabled: !hasChildren,
      submenu: [
        {
          title: lang.cm_sort_child_nodes_asc,
          icon: "sort-asc",
          action: () => sortChildNodes(view, activeNode, "ascending")
        },
        {
          title: lang.cm_sort_child_nodes_desc,
          icon: "sort-desc",
          action: () => sortChildNodes(view, activeNode, "descending")
        }
      ]
    },
    { type: "separator" },
    {
      title: lang.cm_merge_above,
      icon: "merge",
      action: () => mergeNode(view, "up")
    },
    {
      title: lang.cm_merge_below,
      icon: "merge",
      action: () => mergeNode(view, "down")
    },
    { type: "separator" },
    {
      title: lang.cm_copy_link_to_block,
      icon: "links-coming-in",
      action: () => copyLinkToBlock(view, false)
    },
    { type: "separator" },
    !hasChildren ? {
      title: lang.cm_copy,
      icon: "documents",
      action: () => copyActiveNodesToClipboard(view, false)
    } : {
      title: lang.cm_copy,
      icon: "documents",
      submenu: [
        {
          title: lang.cm_copy_branch,
          icon: "lineage-cards",
          action: () => copyActiveBranchesToClipboard(view, true, false)
        },
        {
          title: lang.cm_copy_branch_wo_formatting,
          icon: "file-text",
          action: () => copyActiveBranchesToClipboard(view, false, false)
        },
        {
          title: lang.cm_copy_nodes_wo_subitems,
          icon: "file-text",
          action: () => copyActiveNodesToClipboard(view, false)
        }
      ]
    },
    {
      title: lang.cm_cut,
      icon: "scissors",
      action: () => cutNode(view)
    },
    {
      title: lang.cm_paste,
      icon: "paste",
      action: () => pasteNode(view)
    },
    { type: "separator" },
    {
      title: isPinned ? lang.cm_unpin_from_left_sidebar : lang.cm_pin_in_left_sidebar,
      icon: isPinned ? "pin-off" : "pin",
      action: () => {
        togglePinNode(view, activeNode, false, false);
      }
    },
    { type: "separator" },
    {
      title: hasChildren ? lang.cm_extract_branch : lang.cm_extract_section,
      icon: customIcons.cards.name,
      action: () => extractBranch(view)
    },
    !hasChildren ? {
      title: lang.cm_export_section,
      icon: "file-text",
      action: () => exportSelection(view, false)
    } : {
      title: lang.cm_export_selection,
      icon: "file-text",
      submenu: [
        {
          title: lang.cm_export_branch_with_subitems,
          icon: "file-text",
          action: () => exportSelection(view, true)
        },
        {
          title: lang.cm_export_branch_wo_subitems,
          icon: "file-text",
          action: () => exportSelection(view, false)
        }
      ]
    }
  ];
  return menuItems;
};

// src/view/actions/context-menu/card-context-menu/show-node-context-menu.ts
var getContextMenuContext = (view, isInSidebar, isInRecentCardsList) => {
  const viewState = view.viewStore.getValue();
  const multipleNodesAreSelected = !isInSidebar && viewState.document.selectedNodes.size > 1;
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const activeNode = viewState.document.activeNode;
  const isPinned = isInSidebar && !isInRecentCardsList || documentState.pinnedNodes.Ids.includes(activeNode);
  const hasChildren = documentState.meta.groupParentIds.has(activeNode);
  return {
    activeNode,
    isPinned,
    isInSidebar,
    isInRecentCardsList,
    multipleNodesAreSelected,
    hasChildren
  };
};
var showNodeContextMenu = (event, view) => {
  const target = event.target;
  const closestCardElement = target.closest(
    ".lineage-card"
  );
  if (!closestCardElement)
    return;
  if (textIsSelected())
    return;
  const isInSidebar = Boolean(target.closest(".sidebar"));
  const isInRecentCardsList = isInSidebar && Boolean(target.closest(".recent-cards-container"));
  const targetIsActive = closestCardElement.hasClass("active-node");
  if (!targetIsActive) {
    selectInactiveCard(
      view,
      closestCardElement,
      isInSidebar,
      isInRecentCardsList
    );
  }
  const context = getContextMenuContext(
    view,
    isInSidebar,
    isInRecentCardsList
  );
  let menuItems;
  if (context.isInSidebar) {
    menuItems = createSidebarContextMenuItems(view, context);
  } else if (context.multipleNodesAreSelected) {
    menuItems = createMultipleNodesContextMenu(view);
  } else {
    menuItems = createSingleNodeContextMenuItems(view, context);
  }
  renderContextMenu(event, menuItems);
};

// src/view/actions/context-menu/card-context-menu/should-show-node-context-menu.ts
var shouldShowNodeContextMenu = (e) => {
  const target = e.target;
  return !target.hasClass("drag-handle") && Boolean(target.closest(".lineage-card"));
};

// src/view/actions/context-menu/view-context-menu/should-show-view-context-menu.ts
var shouldShowViewContextMenu = (e) => {
  const target = e.target;
  return target.hasClass("column-buffer") || target.hasClass("column") || target.hasClass("group") || target.hasClass("columns") || target.hasClass("columns-container");
};

// src/lib/data-conversion/x-to-json/html-comment-to-json.ts
var getDepthLevel = (number) => {
  if (number.includes(".")) {
    return number.split(".").length;
  } else
    return /\d+/.test(number) ? 1 : 0;
};
var trimCurrentNode = (node) => {
  if (node) {
    node.content = node.content.trim();
  }
};
var htmlCommentToJson = (text2) => {
  const lines = text2.split("\n");
  const map = {};
  const tree = [];
  let currentNode = null;
  let currentParentNumber = "";
  for (const line of lines) {
    const sectionNumber = parseHtmlCommentMarker(line);
    if (sectionNumber) {
      const [parent, , full] = sectionNumber;
      const isASibling = parent === currentParentNumber;
      const newNode = {
        content: "",
        children: []
      };
      map[full] = newNode;
      if (isASibling) {
        if (currentNode)
          trimCurrentNode(currentNode);
        const parentNode = map[parent];
        if (parentNode) {
          parentNode.children.push(newNode);
        } else {
          tree.push(newNode);
        }
        currentNode = newNode;
      } else {
        const isChild = getDepthLevel(parent) > getDepthLevel(currentParentNumber);
        if (isChild) {
          if (!currentNode) {
            throw new Error(lang.error_parent_not_found(full));
          }
          trimCurrentNode(currentNode);
          currentNode.children.push(newNode);
          currentNode = newNode;
        } else {
          if (!parent) {
            if (currentNode)
              trimCurrentNode(currentNode);
            tree.push(newNode);
            currentNode = newNode;
          } else {
            const parentNode = map[parent];
            if (!parentNode) {
              throw new Error(lang.error_parent_not_found(full));
            }
            if (currentNode)
              trimCurrentNode(currentNode);
            parentNode.children.push(newNode);
            currentNode = newNode;
          }
        }
      }
      currentParentNumber = parent;
    } else {
      if (currentNode) {
        if (currentNode.content)
          currentNode.content += "\n";
        currentNode.content += line;
      } else if (line.trim()) {
        currentNode = {
          content: line,
          children: []
        };
        tree.push(currentNode);
      }
    }
  }
  return tree;
};

// src/lib/data-conversion/x-to-json/html-element-to-json.ts
var htmlElementToJson = (text2) => {
  const lines = text2.split("\n");
  const map = {};
  const tree = [];
  let currentNode = null;
  let currentParentNumber = "";
  for (const line of lines) {
    const sectionNumber = parseHtmlElementMarker(line);
    if (sectionNumber) {
      const [parent, , full] = sectionNumber;
      const isASibling = parent === currentParentNumber;
      const newNode = {
        content: line.replace(htmlElementRegex, ""),
        children: []
      };
      map[full] = newNode;
      if (isASibling) {
        if (currentNode)
          trimCurrentNode(currentNode);
        const parentNode = map[parent];
        if (parentNode) {
          parentNode.children.push(newNode);
        } else {
          tree.push(newNode);
        }
        currentNode = newNode;
      } else {
        const isChild = getDepthLevel(parent) > getDepthLevel(currentParentNumber);
        if (isChild) {
          if (!currentNode) {
            throw new Error(lang.error_parent_not_found(full));
          }
          trimCurrentNode(currentNode);
          currentNode.children.push(newNode);
          currentNode = newNode;
        } else {
          if (!parent) {
            if (currentNode)
              trimCurrentNode(currentNode);
            tree.push(newNode);
            currentNode = newNode;
          } else {
            const parentNode = map[parent];
            if (!parentNode) {
              throw new Error(lang.error_parent_not_found(full));
            }
            if (currentNode)
              trimCurrentNode(currentNode);
            parentNode.children.push(newNode);
            currentNode = newNode;
          }
        }
      }
      currentParentNumber = parent;
    } else {
      if (currentNode) {
        if (currentNode.content)
          currentNode.content += "\n";
        currentNode.content += line;
      } else if (line.trim()) {
        currentNode = {
          content: line,
          children: []
        };
        tree.push(currentNode);
      }
    }
  }
  return tree;
};

// src/obsidian/commands/helpers/export-document/map-document-to-text.ts
var mapDocumentToText = (fileData, format2) => {
  const { body, frontmatter } = extractFrontmatter(fileData);
  const tree = format2 === "outline" ? outlineToJson(body) : format2 === "html-element" ? htmlElementToJson(body) : htmlCommentToJson(body);
  return (frontmatter ? frontmatter + "\n" : "") + jsonToText(tree);
};

// src/obsidian/commands/helpers/export-document/export-document.ts
var exportDocument = async (view) => {
  try {
    const file = view.file;
    if (!file)
      return;
    if (!file.parent)
      return;
    const viewState = view.viewStore.getValue();
    const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
    if (isEditing2) {
      saveNodeContent(view);
      setTimeout(() => {
        exportDocument(view);
      }, 100);
      return;
    }
    const fileData = await view.plugin.app.vault.read(file);
    const format2 = getPersistedDocumentFormat(view);
    const output = mapDocumentToText(fileData, format2);
    const newFile = await createNewFile(
      view.plugin,
      file.parent,
      output,
      file.basename
    );
    if (newFile) {
      await openFile(view.plugin, newFile, "split");
    }
  } catch (e) {
    onPluginError(e, "command", { type: "export-document" });
  }
};

// src/obsidian/commands/helpers/export-document/eject-document.ts
var ejectDocument = async (view) => {
  try {
    const file = view.file;
    if (!file)
      return;
    if (!file.parent)
      return;
    const viewState = view.viewStore.getValue();
    const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
    if (isEditing2) {
      saveNodeContent(view);
      setTimeout(() => {
        ejectDocument(view);
      }, 100);
      return;
    }
    const fileData = await view.plugin.app.vault.read(file);
    const format2 = getPersistedDocumentFormat(view);
    const text2 = mapDocumentToText(fileData, format2);
    await view.plugin.app.vault.modify(file, text2);
    toggleObsidianViewType(view.plugin, view.leaf, "markdown");
    setViewType(view.plugin, file.path, "markdown");
  } catch (e) {
    onPluginError(e, "command", { type: "export-document" });
  }
};

// src/view/actions/context-menu/view-context-menu/show-view-context-menu.ts
var showViewContextMenu = (event, view) => {
  const file = view.file;
  if (!file)
    return;
  const format2 = getPersistedDocumentFormat(view);
  const isOutline2 = format2 === "outline";
  const isHtmlElement = format2 === "html-element";
  const isHtmlComments = format2 === "sections";
  const _hasHeading = hasNHeadings(view.data, 1);
  const menuItems = [
    {
      title: lang.cm_format_headings,
      icon: "heading-1",
      action: () => {
        saveNodeContent(view);
        view.documentStore.dispatch({
          type: "document/format-headings"
        });
      },
      disabled: !_hasHeading
    },
    { type: "separator" },
    {
      title: lang.cm_document_format,
      icon: "file-cog",
      submenu: [
        {
          title: lang.settings_format_html_elements,
          icon: "file-cog",
          action: () => {
            setDocumentFormat(
              view.plugin,
              file.path,
              "html-element"
            );
          },
          checked: isHtmlElement
        },
        {
          title: lang.settings_format_html_comments,
          icon: "file-cog",
          action: () => {
            setDocumentFormat(view.plugin, file.path, "sections");
          },
          checked: isHtmlComments
        },
        {
          title: lang.settings_format_outline,
          icon: "file-cog",
          action: () => {
            setDocumentFormat(view.plugin, file.path, "outline");
          },
          checked: isOutline2
        }
      ]
    },
    { type: "separator" },
    {
      title: lang.cm_export_document,
      icon: "file-text",
      action: () => {
        exportDocument(view);
      }
    },
    {
      title: lang.cm_eject_document,
      icon: "file-text",
      action: () => {
        ejectDocument(view);
      },
      dangerous: true
    }
  ];
  renderContextMenu(event, menuItems);
};

// src/view/actions/context-menu/show-context-menu.ts
var showContextMenu = (element2, view) => {
  const listener = (e) => {
    if (shouldShowNodeContextMenu(e)) {
      if (e.instanceOf(MouseEvent))
        showNodeContextMenu(e, view);
      else
        showNodeContextMenu(new MouseEvent("contextmenu", e), view);
    } else if (shouldShowViewContextMenu(e)) {
      if (e.instanceOf(MouseEvent))
        showViewContextMenu(e, view);
      else
        showViewContextMenu(new MouseEvent("contextmenu", e), view);
    }
  };
  element2.addEventListener("contextmenu", listener);
  let unsubFromLongPress = null;
  if (import_obsidian27.Platform.isMobile) {
    unsubFromLongPress = onLongPress(
      element2,
      listener,
      shouldShowNodeContextMenu
    );
  }
  return {
    destroy: () => {
      element2.removeEventListener("contextmenu", listener);
      if (unsubFromLongPress) {
        unsubFromLongPress();
      }
    }
  };
};

// src/view/components/container/dnd/dnd-edges.svelte
function add_css47(target) {
  append_styles(target, "svelte-gs5nl7", ".hide.svelte-gs5nl7{display:none}#dnd-edge-top.svelte-gs5nl7,#dnd-edge-bottom.svelte-gs5nl7{height:40px;position:absolute;left:0;right:0;z-index:100;background-color:var(--color-base-20);opacity:0.1}#dnd-edge-top.svelte-gs5nl7{top:0}#dnd-edge-bottom.svelte-gs5nl7{bottom:0}#dnd-edge-left.svelte-gs5nl7,#dnd-edge-right.svelte-gs5nl7{width:40px;position:absolute;top:40px;bottom:40px;z-index:100;background-color:var(--color-base-20);opacity:0.1}#dnd-edge-left.svelte-gs5nl7{left:0}#dnd-edge-right.svelte-gs5nl7{right:0}");
}
function create_fragment110(ctx) {
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let t2;
  let div3;
  let div3_class_value;
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      attr(div0, "id", "dnd-edge-top");
      attr(div0, "class", div0_class_value = null_to_empty(
        /*$dnd*/
        ctx[0].node ? "" : "hide"
      ) + " svelte-gs5nl7");
      attr(div1, "id", "dnd-edge-bottom");
      attr(div1, "class", div1_class_value = null_to_empty(
        /*$dnd*/
        ctx[0].node ? "" : "hide"
      ) + " svelte-gs5nl7");
      attr(div2, "id", "dnd-edge-left");
      attr(div2, "class", div2_class_value = null_to_empty(
        /*$dnd*/
        ctx[0].node ? "" : "hide"
      ) + " svelte-gs5nl7");
      attr(div3, "id", "dnd-edge-right");
      attr(div3, "class", div3_class_value = null_to_empty(
        /*$dnd*/
        ctx[0].node ? "" : "hide"
      ) + " svelte-gs5nl7");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$dnd*/
      1 && div0_class_value !== (div0_class_value = null_to_empty(
        /*$dnd*/
        ctx2[0].node ? "" : "hide"
      ) + " svelte-gs5nl7")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*$dnd*/
      1 && div1_class_value !== (div1_class_value = null_to_empty(
        /*$dnd*/
        ctx2[0].node ? "" : "hide"
      ) + " svelte-gs5nl7")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$dnd*/
      1 && div2_class_value !== (div2_class_value = null_to_empty(
        /*$dnd*/
        ctx2[0].node ? "" : "hide"
      ) + " svelte-gs5nl7")) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty & /*$dnd*/
      1 && div3_class_value !== (div3_class_value = null_to_empty(
        /*$dnd*/
        ctx2[0].node ? "" : "hide"
      ) + " svelte-gs5nl7")) {
        attr(div3, "class", div3_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t1);
        detach(div2);
        detach(t2);
        detach(div3);
      }
    }
  };
}
function instance108($$self, $$props, $$invalidate) {
  let $dnd;
  const view = getView();
  const dnd = dndStore(view);
  component_subscribe($$self, dnd, (value) => $$invalidate(0, $dnd = value));
  return [$dnd, dnd];
}
var Dnd_edges = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance108, create_fragment110, safe_not_equal, {}, add_css47);
  }
};
var dnd_edges_default = Dnd_edges;

// src/stores/settings/derived/style-rules.ts
var DocumentStyleRulesStore = (view) => derived2(view.plugin.settings, (state2) => {
  invariant(view.file?.path);
  const documentRules = state2.styleRules.documents[view.file.path];
  return documentRules ? documentRules.rules : [];
});
var GlobalStyleRulesStore = (view) => derived2(view.plugin.settings, (state2) => {
  return state2.styleRules.global.rules;
});
var ActiveStyleRulesTab = (view) => derived2(view.plugin.settings, (state2) => {
  return state2.styleRules.settings.activeTab;
});

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/components/rule-info.svelte
function add_css48(target) {
  append_styles(target, "svelte-1pay5a3", ".rule-info.svelte-1pay5a3{width:fit-content;padding-top:4px;padding-bottom:4px;padding-right:8px;border-right:1px solid var(--text-faint);display:flex;align-items:center;justify-content:center}");
}
function create_fragment111(ctx) {
  let div;
  let navigationbuttons;
  let current;
  navigationbuttons = new search_navigation_buttons_default({
    props: { results: (
      /*results*/
      ctx[0] || []
    ) }
  });
  return {
    c() {
      div = element("div");
      create_component(navigationbuttons.$$.fragment);
      attr(div, "class", "rule-info svelte-1pay5a3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(navigationbuttons, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigationbuttons_changes = {};
      if (dirty & /*results*/
      1)
        navigationbuttons_changes.results = /*results*/
        ctx2[0] || [];
      navigationbuttons.$set(navigationbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigationbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigationbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(navigationbuttons);
    }
  };
}
function instance109($$self, $$props, $$invalidate) {
  let { rule } = $$props;
  let { results } = $$props;
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(1, rule = $$props2.rule);
    if ("results" in $$props2)
      $$invalidate(0, results = $$props2.results);
  };
  return [results, rule];
}
var Rule_info = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance109, create_fragment111, safe_not_equal, { rule: 1, results: 0 }, add_css48);
  }
};
var rule_info_default = Rule_info;

// src/view/components/container/style-rules/helpers/constants.ts
var targets = [
  "self",
  "self-or-any-parent",
  "self-or-any-children",
  "self-or-direct-parent",
  "self-or-direct-children",
  "any-parent",
  "any-children",
  "direct-parent",
  "direct-children"
];
var stringOperators = [
  "contains",
  "not-contains",
  "equals",
  "not-equals",
  "empty",
  "not-empty",
  "starts-with",
  "not-starts-with",
  "ends-with",
  "not-ends-with",
  "matches-regex",
  "not-matches-regex"
];
var numericOperators = [
  "equals",
  "not-equals",
  "empty",
  "not-empty",
  "greater-than",
  "less-than",
  "between",
  "not-between"
];
var properties = [
  "content",
  "headings",
  "headings-word-count",
  "depth",
  "character-count",
  "word-count",
  "line-count",
  "direct-children-count",
  "total-children-count"
];
var styleVariants = [
  "background-color",
  "left-border"
];

// src/view/components/container/style-rules/helpers/rule-editor-event-handlers.ts
var ruleEditorEventHandlers = (view, ruleId) => {
  const documentPath = () => view.file?.path ?? "";
  const updateCondition = (updates) => {
    view.plugin.settings.dispatch({
      type: "settings/style-rules/update-condition",
      payload: {
        documentPath: documentPath(),
        ruleId,
        updates
      }
    });
  };
  const handleScopeChange = (e) => {
    const target = e.target;
    updateCondition({ scope: target.value });
  };
  const handlePropertyChange = (e) => {
    const target = e.target;
    updateCondition({
      property: target.value
    });
  };
  const handleOperatorChange = (e) => {
    const target = e.target;
    updateCondition({ operator: target.value });
  };
  const handleValueChange = (e) => {
    const target = e.target;
    updateCondition({ value: target.value });
  };
  const handleValueBChange = (e) => {
    const target = e.target;
    updateCondition({ valueB: parseFloat(target.value) });
  };
  return {
    handleScopeChange,
    handlePropertyChange,
    handleOperatorChange,
    handleValueChange,
    handleValueBChange
  };
};

// src/lang/style-rules-lang.ts
var styleRulesLang = {
  targets: {
    self: "Of section",
    "self-or-direct-parent": "Of section or direct parent",
    "self-or-any-parent": "Of section or any parent",
    "self-or-direct-children": "Of section or direct child",
    "self-or-any-children": "Of section or any child",
    "direct-parent": "Of direct parent",
    "any-parent": "Of any parent",
    "direct-children": "Of direct child",
    "any-children": "Of any child"
  },
  operators: {
    contains: "Contains",
    "not-contains": "Does not contain",
    equals: "Equals",
    "not-equals": "Does not equal",
    empty: "Is empty",
    "not-empty": "is not empty",
    "greater-than": "Is greater than",
    "less-than": "Is less than",
    between: "Is between",
    "not-between": "Is not between",
    "starts-with": "Starts with",
    "not-starts-with": "Does not start with",
    "ends-with": "Ends with",
    "not-ends-with": "Does not end with",
    "matches-regex": "Matches regex",
    "not-matches-regex": "Does not match regex"
  },
  properties: {
    depth: "Depth",
    "character-count": "Character count",
    "word-count": "Word count",
    "line-count": "Line count",
    "direct-children-count": "Direct children count",
    "total-children-count": "Total children count",
    content: "Content",
    headings: "Headings",
    "headings-word-count": "Headings word count"
  },
  styleVariants: {
    "left-border": "Left border",
    "background-color": "Background color"
  }
};

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/components/rule-editor.svelte
function add_css49(target) {
  append_styles(target, "svelte-1yba036", ".rule-editor.svelte-1yba036{display:flex;gap:8px;align-items:center;position:relative;width:90%;flex:1;flex-wrap:wrap}.select-elements.svelte-1yba036{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap;& select {\n            font-size: 12px;\n            width: 130px;\n        }}.input-elements.svelte-1yba036{width:130px;display:flex;gap:8px;align-items:center;justify-content:space-between;& input {\n            font-size: 12px;\n            width: 100%;\n        }}");
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context19(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${styleRulesLang.properties[
        /*property*/
        ctx[13]
      ]}`;
      option.__value = option_value_value = /*property*/
      ctx[13];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${styleRulesLang.targets[
        /*target*/
        ctx[10]
      ]}`;
      option.__value = option_value_value = /*target*/
      ctx[10];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_else_block13(ctx) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like(numericOperators);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_26(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(stringOperators);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block19(get_each_context19(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_13(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${styleRulesLang.operators[
        /*operator*/
        ctx[5]
      ]}`;
      option.__value = option_value_value = /*operator*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block19(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${styleRulesLang.operators[
        /*operator*/
        ctx[5]
      ]}`;
      option.__value = option_value_value = /*operator*/
      ctx[5];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_19(ctx) {
  let input;
  let input_type_value;
  let input_value_value;
  let input_placeholder_value;
  let input_style_value;
  let input_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", input_type_value = /*isStringCondition*/
      ctx[1] ? "text" : "number");
      input.value = input_value_value = /*rule*/
      ctx[0].condition.value;
      attr(input, "placeholder", input_placeholder_value = /*isStringCondition*/
      ctx[1] ? "Text" : "Number");
      attr(input, "style", input_style_value = /*isStringCondition*/
      ctx[1] ? "" : (
        /*operatorIsBetween*/
        ctx[2] ? "width: 50%" : ""
      ));
      attr(input, "aria-label", input_aria_label_value = /*operatorIsBetween*/
      ctx[2] ? "Value 1" : "Value");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*h*/
          ctx[3].handleValueChange
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isStringCondition*/
      2 && input_type_value !== (input_type_value = /*isStringCondition*/
      ctx2[1] ? "text" : "number")) {
        attr(input, "type", input_type_value);
      }
      if (dirty & /*rule*/
      1 && input_value_value !== (input_value_value = /*rule*/
      ctx2[0].condition.value) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty & /*isStringCondition*/
      2 && input_placeholder_value !== (input_placeholder_value = /*isStringCondition*/
      ctx2[1] ? "Text" : "Number")) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*isStringCondition, operatorIsBetween*/
      6 && input_style_value !== (input_style_value = /*isStringCondition*/
      ctx2[1] ? "" : (
        /*operatorIsBetween*/
        ctx2[2] ? "width: 50%" : ""
      ))) {
        attr(input, "style", input_style_value);
      }
      if (dirty & /*operatorIsBetween*/
      4 && input_aria_label_value !== (input_aria_label_value = /*operatorIsBetween*/
      ctx2[2] ? "Value 1" : "Value")) {
        attr(input, "aria-label", input_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block28(ctx) {
  let input;
  let input_value_value;
  let input_placeholder_value;
  let input_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
      input.value = input_value_value = "valueB" in /*rule*/
      ctx[0].condition ? (
        /*rule*/
        ctx[0].condition.valueB
      ) : 0;
      attr(input, "placeholder", input_placeholder_value = "Number");
      attr(input, "style", input_style_value = "width: 60px");
      attr(input, "aria-label", "Value 2");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*h*/
          ctx[3].handleValueBChange
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*rule*/
      1 && input_value_value !== (input_value_value = "valueB" in /*rule*/
      ctx2[0].condition ? (
        /*rule*/
        ctx2[0].condition.valueB
      ) : 0) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment112(ctx) {
  let div2;
  let div0;
  let select0;
  let select0_value_value;
  let t0;
  let select1;
  let select1_value_value;
  let t1;
  let select2;
  let select2_value_value;
  let t2;
  let div1;
  let show_if = !["empty", "not-empty"].includes(
    /*rule*/
    ctx[0].condition.operator
  );
  let t3;
  let mounted;
  let dispose;
  let each_value_3 = ensure_array_like(properties);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = ensure_array_like(targets);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function select_block_type(ctx2, dirty) {
    if (
      /*isStringCondition*/
      ctx2[1]
    )
      return create_if_block_26;
    return create_else_block13;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = show_if && create_if_block_19(ctx);
  let if_block2 = (
    /*operatorIsBetween*/
    ctx[2] && create_if_block28(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      select1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      select2 = element("select");
      if_block0.c();
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(select0, "aria-label", "Property");
      attr(select1, "aria-label", "Scope");
      attr(select2, "aria-label", "Operator");
      attr(div0, "class", "select-elements svelte-1yba036");
      attr(div1, "class", "input-elements svelte-1yba036");
      attr(div2, "class", "rule-editor svelte-1yba036");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, select0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*rule*/
        ctx[0].condition.property
      );
      append(div0, t0);
      append(div0, select1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select1, null);
        }
      }
      select_option(
        select1,
        /*rule*/
        ctx[0].condition.scope
      );
      append(div0, t1);
      append(div0, select2);
      if_block0.m(select2, null);
      select_option(
        select2,
        /*rule*/
        ctx[0].condition.operator
      );
      append(div2, t2);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*h*/
            ctx[3].handlePropertyChange
          ),
          listen(
            select1,
            "change",
            /*h*/
            ctx[3].handleScopeChange
          ),
          listen(
            select2,
            "change",
            /*h*/
            ctx[3].handleOperatorChange
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*rule*/
      1 && select0_value_value !== (select0_value_value = /*rule*/
      ctx2[0].condition.property)) {
        select_option(
          select0,
          /*rule*/
          ctx2[0].condition.property
        );
      }
      if (dirty & /*rule*/
      1 && select1_value_value !== (select1_value_value = /*rule*/
      ctx2[0].condition.scope)) {
        select_option(
          select1,
          /*rule*/
          ctx2[0].condition.scope
        );
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(select2, null);
        }
      }
      if (dirty & /*rule*/
      1 && select2_value_value !== (select2_value_value = /*rule*/
      ctx2[0].condition.operator)) {
        select_option(
          select2,
          /*rule*/
          ctx2[0].condition.operator
        );
      }
      if (dirty & /*rule*/
      1)
        show_if = !["empty", "not-empty"].includes(
          /*rule*/
          ctx2[0].condition.operator
        );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_19(ctx2);
          if_block1.c();
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*operatorIsBetween*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block28(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance110($$self, $$props, $$invalidate) {
  let operatorIsBetween;
  let isStringCondition;
  let { rule } = $$props;
  const view = getView();
  const h = ruleEditorEventHandlers(view, rule.id);
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*rule*/
    1) {
      $:
        $$invalidate(2, operatorIsBetween = rule.condition.operator === "between" || rule.condition.operator === "not-between");
    }
    if ($$self.$$.dirty & /*rule*/
    1) {
      $:
        $$invalidate(1, isStringCondition = rule.condition.property === "content" || rule.condition.property === "headings");
    }
  };
  return [rule, isStringCondition, operatorIsBetween, h];
}
var Rule_editor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance110, create_fragment112, safe_not_equal, { rule: 0 }, add_css49);
  }
};
var rule_editor_default = Rule_editor;

// src/view/components/container/style-rules/helpers/rule-style-editor-event-handlers.ts
var ruleStyleEditorEventHandlers = (view, ruleId) => {
  const documentPath = () => view.file?.path ?? "";
  const updateStyle = (id2, style) => {
    view.plugin.settings.dispatch({
      type: "settings/style-rules/update-style",
      payload: { documentPath: documentPath(), id: id2, style }
    });
  };
  const handleColorChange = (e) => {
    const target = e.target;
    updateStyle(ruleId, { color: target.value });
  };
  const handleStyleVariantChange = (e) => {
    const target = e.target;
    updateStyle(ruleId, {
      styleVariant: target.value
    });
  };
  return {
    handleColorChange,
    handleStyleVariantChange
  };
};

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/components/rule-style-editor.svelte
function add_css50(target) {
  append_styles(target, "svelte-13w1xs", ".rule-style-config.svelte-13w1xs{width:fit-content;padding:4px;padding-right:0px;border-left:1px solid var(--text-faint);display:flex;align-items:center;gap:8px;justify-content:center}.select-elements.svelte-13w1xs{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap;& select {\n            font-size: 12px;\n            width: 130px;\n        }}");
}
function get_each_context20(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block20(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${styleRulesLang.styleVariants[
        /*styleType*/
        ctx[3]
      ]}`;
      option.__value = option_value_value = /*styleType*/
      ctx[3];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_fragment113(ctx) {
  let div1;
  let input;
  let input_value_value;
  let t;
  let div0;
  let select;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(styleVariants);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block20(get_each_context20(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(input, "type", "color");
      input.value = input_value_value = /*rule*/
      ctx[0].style.color;
      attr(div0, "class", "select-elements svelte-13w1xs");
      attr(div1, "class", "rule-style-config svelte-13w1xs");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t);
      append(div1, div0);
      append(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*rule*/
        ctx[0].style.styleVariant
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*h*/
            ctx[1].handleColorChange
          ),
          listen(
            select,
            "change",
            /*h*/
            ctx[1].handleStyleVariantChange
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*rule*/
      1 && input_value_value !== (input_value_value = /*rule*/
      ctx2[0].style.color)) {
        input.value = input_value_value;
      }
      if (dirty & /*rule*/
      1 && select_value_value !== (select_value_value = /*rule*/
      ctx2[0].style.styleVariant)) {
        select_option(
          select,
          /*rule*/
          ctx2[0].style.styleVariant
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance111($$self, $$props, $$invalidate) {
  let { rule } = $$props;
  const view = getView();
  const h = ruleStyleEditorEventHandlers(view, rule.id);
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  return [rule, h];
}
var Rule_style_editor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance111, create_fragment113, safe_not_equal, { rule: 0 }, add_css50);
  }
};
var rule_style_editor_default = Rule_style_editor;

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/components/actions/rule-dnd.ts
var ruleDndAction = (element2, {
  setDraggedRule,
  setDropTarget,
  resetDragState,
  rule,
  view
}) => {
  const handleDragStart = (e) => {
    const target = e.currentTarget;
    const dragHandleRect = target.querySelector(".drag-handle")?.getBoundingClientRect();
    const isWithinDragHandle = dragHandleRect && e.clientX >= dragHandleRect.left && e.clientX <= dragHandleRect.right && e.clientY >= dragHandleRect.top && e.clientY <= dragHandleRect.bottom;
    if (!isWithinDragHandle) {
      e.preventDefault();
      return;
    }
    const rules = get_store_value(DocumentStyleRulesStore(view));
    if (rules.length === 1) {
      e.preventDefault();
      return;
    }
    if (!e.dataTransfer)
      return;
    e.dataTransfer.effectAllowed = "move";
    const data = { id: rule.id };
    e.dataTransfer.setData("text/plain", JSON.stringify(data));
    setTimeout(() => {
      setDraggedRule(rule);
    });
  };
  const handleDragOver = (e) => {
    e.preventDefault();
    const target = e.currentTarget;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const isAbove = y < rect.height / 2;
    setDropTarget(rule, isAbove ? "before" : "after");
  };
  const handleDrop = (e) => {
    e.preventDefault();
    const target = e.currentTarget;
    const data = JSON.parse(e.dataTransfer?.getData("text/plain") || "{}");
    if (!data.id)
      return;
    const rect = target.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const isAbove = y < rect.height / 2;
    view.plugin.settings.dispatch({
      type: "settings/style-rules/move",
      payload: {
        documentPath: view.file?.path,
        droppedId: data.id,
        targetId: rule.id,
        position: isAbove ? "before" : "after"
      }
    });
    setTimeout(() => {
      resetDragState();
    });
  };
  const handleDragEnd = (e) => {
    e.preventDefault();
    resetDragState();
  };
  element2.addEventListener("dragstart", handleDragStart);
  element2.addEventListener("dragover", handleDragOver);
  element2.addEventListener("drop", handleDrop);
  element2.addEventListener("dragend", handleDragEnd);
  return {
    destroy: () => {
      element2.removeEventListener("dragstart", handleDragStart);
      element2.removeEventListener("dragover", handleDragOver);
      element2.removeEventListener("drop", handleDrop);
      element2.removeEventListener("dragend", handleDragEnd);
    }
  };
};

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/components/rule-actions.svelte
var import_obsidian28 = require("obsidian");
function add_css51(target) {
  append_styles(target, "svelte-1gydyks", ".rule-actions.svelte-1gydyks{display:flex;align-items:center;padding-top:4px;padding-bottom:4px;padding-left:8px;border-left:1px solid var(--text-faint);justify-content:center}");
}
function create_fragment114(ctx) {
  let div1;
  let input;
  let input_checked_value;
  let t;
  let div0;
  let morevertical;
  let current;
  let mounted;
  let dispose;
  morevertical = new more_vertical_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      create_component(morevertical.$$.fragment);
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = /*rule*/
      ctx[0].enabled;
      attr(input, "aria-label", "Enable");
      attr(div0, "class", "clickable-icon");
      attr(div0, "aria-label", "Actions");
      attr(div1, "class", "rule-actions svelte-1gydyks");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t);
      append(div1, div0);
      mount_component(morevertical, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*toggleRule*/
            ctx[1]
          ),
          listen(
            div0,
            "click",
            /*showContextMenu*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*rule*/
      1 && input_checked_value !== (input_checked_value = /*rule*/
      ctx2[0].enabled)) {
        input.checked = input_checked_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(morevertical.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(morevertical.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(morevertical);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance112($$self, $$props, $$invalidate) {
  let { rule } = $$props;
  const view = getView();
  const toggleRule = (e) => {
    const target = e.target;
    view.plugin.settings.dispatch({
      type: target.checked ? "settings/style-rules/enable-rule" : "settings/style-rules/disable-rule",
      payload: {
        documentPath: view.file.path,
        id: rule.id
      }
    });
  };
  const deleteRule = () => {
    view.plugin.settings.dispatch({
      type: "settings/style-rules/delete",
      payload: {
        documentPath: view.file.path,
        id: rule.id
      }
    });
  };
  const moveRule = () => {
    const activeTab = get_store_value(ActiveStyleRulesTab(view));
    const activeTabIsGlobal = activeTab === "global-rules";
    view.plugin.settings.dispatch({
      type: "settings/style-rules/toggle-global",
      payload: {
        id: rule.id,
        documentPath: view.file.path
      }
    });
    view.plugin.settings.dispatch({
      type: "settings/style-rules/set-active-tab",
      payload: {
        tab: activeTabIsGlobal ? "document-rules" : "global-rules"
      }
    });
  };
  const duplicateRule = () => {
    view.plugin.settings.dispatch({
      type: "settings/style-rules/duplicate-rule",
      payload: {
        id: rule.id,
        documentPath: view.file.path
      }
    });
  };
  const showContextMenu2 = (e) => {
    const target = e.target;
    if (target.localName === "input")
      return;
    const menu = new import_obsidian28.Menu();
    const activeTab = get_store_value(ActiveStyleRulesTab(view));
    const activeTabIsGlobal = activeTab === "global-rules";
    menu.addItem((item) => {
      item.setTitle(activeTabIsGlobal ? lang.modals_rules_rule_cm_move_to_document : lang.modals_rules_rule_cm_move_to_global);
      item.setIcon(activeTabIsGlobal ? "file-text" : "globe");
      item.onClick(moveRule);
    });
    menu.addItem((item) => {
      item.setTitle("Duplicate");
      item.setIcon("copy");
      item.onClick(duplicateRule);
    });
    menu.addItem((item) => {
      item.setTitle("Delete");
      item.setIcon("trash");
      item.onClick(deleteRule);
      if ("dom" in item) {
        item.dom.addClass("is-warning");
      }
    });
    menu.showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  return [rule, toggleRule, showContextMenu2];
}
var Rule_actions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance112, create_fragment114, safe_not_equal, { rule: 0 }, add_css51);
  }
};
var rule_actions_default = Rule_actions;

// src/view/components/container/style-rules/components/style-rules-list/components/style-rule/style-rule.svelte
function add_css52(target) {
  append_styles(target, "svelte-13uscz", ".rule-container.svelte-13uscz{margin-top:10px;display:flex;border-radius:4px;overflow:hidden;background-color:var(--color-base-20);padding:12px;gap:8px;flex-wrap:wrap}.drag-handle.svelte-13uscz{cursor:grab;color:var(--text-muted);padding:4px;display:flex;align-items:center}.drag-handle.svelte-13uscz:hover{color:var(--text-normal)}.rule-container.svelte-13uscz:nth-child(-n + 1){margin-top:0}");
}
function create_fragment115(ctx) {
  let div1;
  let div0;
  let gripvertical;
  let div0_aria_label_value;
  let t0;
  let ruleinfo;
  let t1;
  let ruleeditor;
  let t2;
  let rulestyleeditor;
  let t3;
  let ruleactions;
  let ruleDndAction_action;
  let current;
  let mounted;
  let dispose;
  gripvertical = new grip_vertical_default({ props: { class: "svg-icon" } });
  ruleinfo = new rule_info_default({
    props: {
      rule: (
        /*rule*/
        ctx[3]
      ),
      results: (
        /*results*/
        ctx[4]
      )
    }
  });
  ruleeditor = new rule_editor_default({ props: { rule: (
    /*rule*/
    ctx[3]
  ) } });
  rulestyleeditor = new rule_style_editor_default({ props: { rule: (
    /*rule*/
    ctx[3]
  ) } });
  ruleactions = new rule_actions_default({ props: { rule: (
    /*rule*/
    ctx[3]
  ) } });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(gripvertical.$$.fragment);
      t0 = space();
      create_component(ruleinfo.$$.fragment);
      t1 = space();
      create_component(ruleeditor.$$.fragment);
      t2 = space();
      create_component(rulestyleeditor.$$.fragment);
      t3 = space();
      create_component(ruleactions.$$.fragment);
      attr(div0, "class", "drag-handle svelte-13uscz");
      attr(div0, "aria-label", div0_aria_label_value = lang.modals_rules_drag_handle);
      attr(div1, "class", "rule-container svelte-13uscz");
      attr(div1, "draggable", "true");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(gripvertical, div0, null);
      append(div1, t0);
      mount_component(ruleinfo, div1, null);
      append(div1, t1);
      mount_component(ruleeditor, div1, null);
      append(div1, t2);
      mount_component(rulestyleeditor, div1, null);
      append(div1, t3);
      mount_component(ruleactions, div1, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(ruleDndAction_action = ruleDndAction.call(null, div1, {
          setDraggedRule: (
            /*setDraggedRule*/
            ctx[0]
          ),
          setDropTarget: (
            /*setDropTarget*/
            ctx[1]
          ),
          resetDragState: (
            /*resetDragState*/
            ctx[2]
          ),
          rule: (
            /*rule*/
            ctx[3]
          ),
          view: (
            /*view*/
            ctx[5]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const ruleinfo_changes = {};
      if (dirty & /*rule*/
      8)
        ruleinfo_changes.rule = /*rule*/
        ctx2[3];
      if (dirty & /*results*/
      16)
        ruleinfo_changes.results = /*results*/
        ctx2[4];
      ruleinfo.$set(ruleinfo_changes);
      const ruleeditor_changes = {};
      if (dirty & /*rule*/
      8)
        ruleeditor_changes.rule = /*rule*/
        ctx2[3];
      ruleeditor.$set(ruleeditor_changes);
      const rulestyleeditor_changes = {};
      if (dirty & /*rule*/
      8)
        rulestyleeditor_changes.rule = /*rule*/
        ctx2[3];
      rulestyleeditor.$set(rulestyleeditor_changes);
      const ruleactions_changes = {};
      if (dirty & /*rule*/
      8)
        ruleactions_changes.rule = /*rule*/
        ctx2[3];
      ruleactions.$set(ruleactions_changes);
      if (ruleDndAction_action && is_function(ruleDndAction_action.update) && dirty & /*setDraggedRule, setDropTarget, resetDragState, rule*/
      15)
        ruleDndAction_action.update.call(null, {
          setDraggedRule: (
            /*setDraggedRule*/
            ctx2[0]
          ),
          setDropTarget: (
            /*setDropTarget*/
            ctx2[1]
          ),
          resetDragState: (
            /*resetDragState*/
            ctx2[2]
          ),
          rule: (
            /*rule*/
            ctx2[3]
          ),
          view: (
            /*view*/
            ctx2[5]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(gripvertical.$$.fragment, local);
      transition_in(ruleinfo.$$.fragment, local);
      transition_in(ruleeditor.$$.fragment, local);
      transition_in(rulestyleeditor.$$.fragment, local);
      transition_in(ruleactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gripvertical.$$.fragment, local);
      transition_out(ruleinfo.$$.fragment, local);
      transition_out(ruleeditor.$$.fragment, local);
      transition_out(rulestyleeditor.$$.fragment, local);
      transition_out(ruleactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(gripvertical);
      destroy_component(ruleinfo);
      destroy_component(ruleeditor);
      destroy_component(rulestyleeditor);
      destroy_component(ruleactions);
      mounted = false;
      dispose();
    }
  };
}
function instance113($$self, $$props, $$invalidate) {
  let { setDraggedRule } = $$props;
  let { setDropTarget } = $$props;
  let { resetDragState } = $$props;
  let { rule } = $$props;
  let { results } = $$props;
  const view = getView();
  $$self.$$set = ($$props2) => {
    if ("setDraggedRule" in $$props2)
      $$invalidate(0, setDraggedRule = $$props2.setDraggedRule);
    if ("setDropTarget" in $$props2)
      $$invalidate(1, setDropTarget = $$props2.setDropTarget);
    if ("resetDragState" in $$props2)
      $$invalidate(2, resetDragState = $$props2.resetDragState);
    if ("rule" in $$props2)
      $$invalidate(3, rule = $$props2.rule);
    if ("results" in $$props2)
      $$invalidate(4, results = $$props2.results);
  };
  return [setDraggedRule, setDropTarget, resetDragState, rule, results, view];
}
var Style_rule = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance113,
      create_fragment115,
      safe_not_equal,
      {
        setDraggedRule: 0,
        setDropTarget: 1,
        resetDragState: 2,
        rule: 3,
        results: 4
      },
      add_css52
    );
  }
};
var style_rule_default = Style_rule;

// src/view/components/container/style-rules/components/style-rules-list/components/drop-target.svelte
function add_css53(target) {
  append_styles(target, "svelte-1xjkxat", ".drop-target.svelte-1xjkxat{height:50px;background-color:var(--interactive-hover);border-radius:4px}");
}
function create_if_block_110(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "drop-target svelte-1xjkxat");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(div, "dragover", dragover_handler),
          listen(
            div,
            "drop",
            /*drop_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block29(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "drop-target svelte-1xjkxat");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(div, "dragover", dragover_handler_1),
          listen(
            div,
            "drop",
            /*drop_handler_1*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment116(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*dropPosition*/
    ctx[0] === "before" && create_if_block_110(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let if_block1 = (
    /*dropPosition*/
    ctx[0] === "after" && create_if_block29(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*dropPosition*/
        ctx2[0] === "before"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_110(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*dropPosition*/
        ctx2[0] === "after"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block29(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
var dragover_handler = (e) => e.preventDefault();
var dragover_handler_1 = (e) => e.preventDefault();
function instance114($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a;
  let { rule } = $$props;
  let { resetDragState } = $$props;
  let { dropPosition } = $$props;
  let { draggedRule } = $$props;
  const view = getView();
  const documentPath = (_a = view.file) === null || _a === void 0 ? void 0 : _a.path;
  const handleDrop = () => {
    if (draggedRule) {
      view.plugin.settings.dispatch({
        type: "settings/style-rules/move",
        payload: {
          documentPath,
          droppedId: draggedRule.id,
          targetId: rule.id,
          position: dropPosition
        }
      });
    }
    resetDragState();
  };
  const drop_handler = () => handleDrop();
  const drop_handler_1 = () => handleDrop();
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(2, rule = $$props2.rule);
    if ("resetDragState" in $$props2)
      $$invalidate(3, resetDragState = $$props2.resetDragState);
    if ("dropPosition" in $$props2)
      $$invalidate(0, dropPosition = $$props2.dropPosition);
    if ("draggedRule" in $$props2)
      $$invalidate(4, draggedRule = $$props2.draggedRule);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    dropPosition,
    handleDrop,
    rule,
    resetDragState,
    draggedRule,
    $$scope,
    slots,
    drop_handler,
    drop_handler_1
  ];
}
var Drop_target = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance114,
      create_fragment116,
      safe_not_equal,
      {
        rule: 2,
        resetDragState: 3,
        dropPosition: 0,
        draggedRule: 4
      },
      add_css53
    );
  }
};
var drop_target_default = Drop_target;

// src/view/components/container/style-rules/components/style-rules-list/components/empty-list.svelte
function add_css54(target) {
  append_styles(target, "svelte-1tkjjmq", ".pane-empty.svelte-1tkjjmq{height:100%;flex:1;display:flex;align-items:center;justify-content:center}");
}
function create_fragment117(ctx) {
  let div2;
  let div0;
  let stylerulecontainer;
  let t0;
  let div1;
  let current;
  stylerulecontainer = new style_rule_default({
    props: {
      rule: (
        /*rule*/
        ctx[0]
      ),
      setDraggedRule: (
        /*noop*/
        ctx[1]
      ),
      setDropTarget: (
        /*noop*/
        ctx[1]
      ),
      resetDragState: (
        /*noop*/
        ctx[1]
      ),
      results: []
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(stylerulecontainer.$$.fragment);
      t0 = space();
      div1 = element("div");
      div1.textContent = `${lang.modals_rules_no_rules}`;
      set_style(div0, "height", "1px");
      set_style(div0, "overflow", "hidden");
      set_style(div0, "visibility", "hidden");
      attr(div1, "class", "pane-empty svelte-1tkjjmq");
      set_style(div2, "height", "95%");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(stylerulecontainer, div0, null);
      append(div2, t0);
      append(div2, div1);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(stylerulecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stylerulecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(stylerulecontainer);
    }
  };
}
function instance115($$self) {
  const rule = {
    style: { color: "", styleVariant: "left-border" },
    enabled: false,
    condition: {
      value: 0,
      property: "character-count",
      enabled: false,
      operator: "greater-than",
      scope: "any-children",
      type: "condition"
    },
    id: "",
    name: "",
    priority: 0
  };
  const noop4 = () => {
  };
  return [rule, noop4];
}
var Empty_list = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance115, create_fragment117, safe_not_equal, {}, add_css54);
  }
};
var empty_list_default = Empty_list;

// src/view/components/container/style-rules/components/style-rules-list/style-rules-list.svelte
function add_css55(target) {
  append_styles(target, "svelte-1se33m3", ".rules-list.svelte-1se33m3{padding:10px;height:100%}.rules-list.dragging.svelte-1se33m3{background-color:var(--interactive-hover)}");
}
function get_each_context21(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_else_block14(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*rules*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*rule*/
    ctx2[9].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context21(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block21(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*rules, resetDragState, $dragState, setDraggedRule, setDropTarget, $allMatches*/
      231) {
        each_value = ensure_array_like(
          /*rules*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block21, each_1_anchor, get_each_context21);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_if_block30(ctx) {
  let emptylist;
  let current;
  emptylist = new empty_list_default({});
  return {
    c() {
      create_component(emptylist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emptylist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(emptylist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emptylist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emptylist, detaching);
    }
  };
}
function create_if_block_27(ctx) {
  let stylerulecontainer;
  let current;
  stylerulecontainer = new style_rule_default({
    props: {
      rule: (
        /*rule*/
        ctx[9]
      ),
      setDraggedRule: (
        /*setDraggedRule*/
        ctx[5]
      ),
      setDropTarget: (
        /*setDropTarget*/
        ctx[6]
      ),
      resetDragState: (
        /*resetDragState*/
        ctx[7]
      ),
      results: (
        /*$allMatches*/
        ctx[2].get(
          /*rule*/
          ctx[9].id
        )
      )
    }
  });
  return {
    c() {
      create_component(stylerulecontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stylerulecontainer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const stylerulecontainer_changes = {};
      if (dirty & /*rules*/
      1)
        stylerulecontainer_changes.rule = /*rule*/
        ctx2[9];
      if (dirty & /*$allMatches, rules*/
      5)
        stylerulecontainer_changes.results = /*$allMatches*/
        ctx2[2].get(
          /*rule*/
          ctx2[9].id
        );
      stylerulecontainer.$set(stylerulecontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(stylerulecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stylerulecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stylerulecontainer, detaching);
    }
  };
}
function create_if_block_111(ctx) {
  let droptarget;
  let current;
  droptarget = new drop_target_default({
    props: {
      rule: (
        /*rule*/
        ctx[9]
      ),
      resetDragState: (
        /*resetDragState*/
        ctx[7]
      ),
      dropPosition: (
        /*$dragState*/
        ctx[1].dropPosition
      ),
      draggedRule: (
        /*$dragState*/
        ctx[1].draggedRule
      ),
      $$slots: { default: [create_default_slot65] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(droptarget.$$.fragment);
    },
    m(target, anchor) {
      mount_component(droptarget, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const droptarget_changes = {};
      if (dirty & /*rules*/
      1)
        droptarget_changes.rule = /*rule*/
        ctx2[9];
      if (dirty & /*$dragState*/
      2)
        droptarget_changes.dropPosition = /*$dragState*/
        ctx2[1].dropPosition;
      if (dirty & /*$dragState*/
      2)
        droptarget_changes.draggedRule = /*$dragState*/
        ctx2[1].draggedRule;
      if (dirty & /*$$scope, rules, $allMatches*/
      4101) {
        droptarget_changes.$$scope = { dirty, ctx: ctx2 };
      }
      droptarget.$set(droptarget_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(droptarget.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(droptarget.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(droptarget, detaching);
    }
  };
}
function create_default_slot65(ctx) {
  let stylerulecontainer;
  let t;
  let current;
  stylerulecontainer = new style_rule_default({
    props: {
      rule: (
        /*rule*/
        ctx[9]
      ),
      setDraggedRule: (
        /*setDraggedRule*/
        ctx[5]
      ),
      setDropTarget: (
        /*setDropTarget*/
        ctx[6]
      ),
      resetDragState: (
        /*resetDragState*/
        ctx[7]
      ),
      results: (
        /*$allMatches*/
        ctx[2].get(
          /*rule*/
          ctx[9].id
        )
      )
    }
  });
  return {
    c() {
      create_component(stylerulecontainer.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(stylerulecontainer, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const stylerulecontainer_changes = {};
      if (dirty & /*rules*/
      1)
        stylerulecontainer_changes.rule = /*rule*/
        ctx2[9];
      if (dirty & /*$allMatches, rules*/
      5)
        stylerulecontainer_changes.results = /*$allMatches*/
        ctx2[2].get(
          /*rule*/
          ctx2[9].id
        );
      stylerulecontainer.$set(stylerulecontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(stylerulecontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stylerulecontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(stylerulecontainer, detaching);
    }
  };
}
function create_each_block21(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_111, create_if_block_27];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$dragState*/
      ctx2[1]?.dropTarget?.id === /*rule*/
      ctx2[9].id
    )
      return 0;
    if (
      /*$dragState*/
      ctx2[1]?.draggedRule !== /*rule*/
      ctx2[9]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment118(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block30, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rules*/
      ctx2[0].length === 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = null_to_empty("rules-list" + /*$dragState*/
      (ctx[1]?.draggedRule ? " dragging" : "")) + " svelte-1se33m3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "mouseleave",
          /*resetDragState*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*$dragState*/
      2 && div_class_value !== (div_class_value = null_to_empty("rules-list" + /*$dragState*/
      (ctx2[1]?.draggedRule ? " dragging" : "")) + " svelte-1se33m3")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance116($$self, $$props, $$invalidate) {
  let $dragState;
  let $allMatches;
  let { rules } = $$props;
  const view = getView();
  const allMatches = AllRuleMatchesStore(view);
  component_subscribe($$self, allMatches, (value) => $$invalidate(2, $allMatches = value));
  const dragState = writable(null);
  component_subscribe($$self, dragState, (value) => $$invalidate(1, $dragState = value));
  const setDraggedRule = (rule) => {
    dragState.update((dragState2) => {
      return {
        dropTarget: (dragState2 === null || dragState2 === void 0 ? void 0 : dragState2.dropTarget) || null,
        dropPosition: (dragState2 === null || dragState2 === void 0 ? void 0 : dragState2.dropPosition) || "before",
        draggedRule: rule
      };
    });
  };
  const setDropTarget = (rule, position) => {
    dragState.update((dragState2) => {
      return {
        draggedRule: (dragState2 === null || dragState2 === void 0 ? void 0 : dragState2.draggedRule) || null,
        dropTarget: rule,
        dropPosition: position
      };
    });
  };
  const resetDragState = () => {
    dragState.set(null);
  };
  $$self.$$set = ($$props2) => {
    if ("rules" in $$props2)
      $$invalidate(0, rules = $$props2.rules);
  };
  return [
    rules,
    $dragState,
    $allMatches,
    allMatches,
    dragState,
    setDraggedRule,
    setDropTarget,
    resetDragState
  ];
}
var Style_rules_list = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance116, create_fragment118, safe_not_equal, { rules: 0 }, add_css55);
  }
};
var style_rules_list_default = Style_rules_list;

// src/view/components/container/style-rules/components/style-rules-footer.svelte
function add_css56(target) {
  append_styles(target, "svelte-77s61g", ".modal-footer.svelte-77s61g{width:100%;padding-bottom:10px;display:flex;justify-content:end}.add-rule.svelte-77s61g{border:none;border-radius:4px;cursor:pointer;align-self:end;margin-right:10px;padding:8px}");
}
function create_fragment119(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = `${lang.modals_rules_add_rule}`;
      attr(button, "class", "add-rule svelte-77s61g");
      attr(div, "class", "modal-footer svelte-77s61g");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*addRule*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance117($$self) {
  const view = getView();
  const addRule = () => {
    var _a;
    const documentPath = (_a = view.file) === null || _a === void 0 ? void 0 : _a.path;
    view.plugin.settings.dispatch({
      type: "settings/style-rules/add",
      payload: { documentPath }
    });
  };
  return [addRule];
}
var Style_rules_footer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance117, create_fragment119, safe_not_equal, {}, add_css56);
  }
};
var style_rules_footer_default = Style_rules_footer;

// src/view/components/container/shared/draggable-modal/draggable-modal.svelte
function add_css57(target) {
  append_styles(target, "svelte-1l68k51", ".drag-handle.svelte-1l68k51.svelte-1l68k51{position:absolute;left:0;top:0;bottom:0;width:8px;cursor:grab;background-color:transparent;z-index:1}.lineage-modal.svelte-1l68k51:hover .drag-handle.svelte-1l68k51{background-size:2px 4px;background-image:linear-gradient(\n            0deg,\n            hsla(0, 0%, 60%, 0.35) 20%,\n            transparent 40%\n        )}.drag-handle.svelte-1l68k51.svelte-1l68k51:active{cursor:grabbing}");
}
function create_fragment120(ctx) {
  let div1;
  let div0;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "drag-handle svelte-1l68k51");
      attr(div1, "class", "lineage-modal svelte-1l68k51");
      set_style(div1, "transform", "translate(0px, 0px)");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[4](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "mousedown",
          /*startDrag*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance118($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let modal;
  let startX;
  let startY;
  let modalX = 0;
  let modalY = 0;
  let isDragging = false;
  const view = getView();
  const container = view.contentEl;
  const startDrag = (event) => {
    isDragging = true;
    startX = event.clientX;
    startY = event.clientY;
    const computedStyle = getComputedStyle(modal);
    const transform = computedStyle.transform;
    if (transform && transform !== "none") {
      const matrix = transform.match(/matrix.*\((.+)\)/);
      if (matrix) {
        const [x, y] = matrix[1].split(", ").slice(4, 6).map(Number);
        modalX = x || 0;
        modalY = y || 0;
      }
    }
    container.addEventListener("mousemove", onDrag);
    container.addEventListener("mouseup", stopDrag);
  };
  const onDrag = (event) => {
    if (!isDragging)
      return;
    modalX += event.clientX - startX;
    modalY += event.clientY - startY;
    startX = event.clientX;
    startY = event.clientY;
    $$invalidate(0, modal.style.transform = `translate(${modalX}px, ${modalY}px)`, modal);
  };
  const stopDrag = () => {
    isDragging = false;
    container.removeEventListener("mousemove", onDrag);
    container.removeEventListener("mouseup", stopDrag);
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(0, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [modal, startDrag, $$scope, slots, div1_binding];
}
var Draggable_modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance118, create_fragment120, safe_not_equal, {}, add_css57);
  }
};
var draggable_modal_default = Draggable_modal;

// src/view/components/container/style-rules/components/tab-header/components/clickable-icon.svelte
function add_css58(target) {
  append_styles(target, "svelte-y9i24n", ".lineage-view .clickable-icon.svelte-y9i24n{cursor:pointer}.clickable-icon--active.svelte-y9i24n{color:var(--icon-color-active);background-color:rgba(0, 0, 0, 0.3);background-blend-mode:multiply}");
}
function create_fragment121(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[1]
      );
      attr(button, "class", button_class_value = null_to_empty("clickable-icon nav-action-button " + /*isActive*/
      (ctx[2] ? "clickable-icon--active " : "")) + " svelte-y9i24n");
      set_style(button, "position", "relative");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onClick*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      2) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx[1]
        );
      }
      if (!current || dirty & /*isActive*/
      4 && button_class_value !== (button_class_value = null_to_empty("clickable-icon nav-action-button " + /*isActive*/
      (ctx[2] ? "clickable-icon--active " : "")) + " svelte-y9i24n")) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance119($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onClick } = $$props;
  let { label } = $$props;
  let { isActive = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onClick" in $$props2)
      $$invalidate(0, onClick = $$props2.onClick);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("isActive" in $$props2)
      $$invalidate(2, isActive = $$props2.isActive);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [onClick, label, isActive, $$scope, slots];
}
var Clickable_icon2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance119, create_fragment121, safe_not_equal, { onClick: 0, label: 1, isActive: 2 }, add_css58);
  }
};
var clickable_icon_default2 = Clickable_icon2;

// src/view/components/container/style-rules/components/tab-header/tab-header.svelte
function add_css59(target) {
  append_styles(target, "svelte-1e75r2m", ".style-rules-tabs-header.svelte-1e75r2m{display:flex;flex-direction:column;align-items:center;justify-content:start;width:100%;align-self:center;justify-self:center;box-sizing:border-box;height:auto;padding-top:10px}.tab-header-buttons.svelte-1e75r2m{display:flex;align-items:center;justify-content:center;gap:5px}");
}
function create_default_slot_16(ctx) {
  let globe;
  let current;
  globe = new globe_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(globe.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globe, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(globe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globe, detaching);
    }
  };
}
function create_default_slot66(ctx) {
  let filetext;
  let current;
  filetext = new file_text_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(filetext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filetext, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(filetext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filetext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filetext, detaching);
    }
  };
}
function create_fragment122(ctx) {
  let div1;
  let div0;
  let clickableicon0;
  let t;
  let clickableicon1;
  let current;
  clickableicon0 = new clickable_icon_default2({
    props: {
      isActive: (
        /*$activeTab*/
        ctx[0] === "global-rules"
      ),
      label: lang.modals_rules_tab_global_rules,
      onClick: (
        /*func*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  clickableicon1 = new clickable_icon_default2({
    props: {
      isActive: (
        /*$activeTab*/
        ctx[0] === "document-rules"
      ),
      label: lang.modals_rules_tab_document_rules,
      onClick: (
        /*func_1*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot66] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(clickableicon0.$$.fragment);
      t = space();
      create_component(clickableicon1.$$.fragment);
      attr(div0, "class", "tab-header-buttons svelte-1e75r2m");
      attr(div1, "class", "style-rules-tabs-header svelte-1e75r2m");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(clickableicon0, div0, null);
      append(div0, t);
      mount_component(clickableicon1, div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const clickableicon0_changes = {};
      if (dirty & /*$activeTab*/
      1)
        clickableicon0_changes.isActive = /*$activeTab*/
        ctx2[0] === "global-rules";
      if (dirty & /*$$scope*/
      64) {
        clickableicon0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      clickableicon0.$set(clickableicon0_changes);
      const clickableicon1_changes = {};
      if (dirty & /*$activeTab*/
      1)
        clickableicon1_changes.isActive = /*$activeTab*/
        ctx2[0] === "document-rules";
      if (dirty & /*$$scope*/
      64) {
        clickableicon1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      clickableicon1.$set(clickableicon1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(clickableicon0.$$.fragment, local);
      transition_in(clickableicon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clickableicon0.$$.fragment, local);
      transition_out(clickableicon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(clickableicon0);
      destroy_component(clickableicon1);
    }
  };
}
function instance120($$self, $$props, $$invalidate) {
  let $activeTab;
  const view = getView();
  const activeTab = ActiveStyleRulesTab(view);
  component_subscribe($$self, activeTab, (value) => $$invalidate(0, $activeTab = value));
  const setActiveTab = (tab) => {
    view.plugin.settings.dispatch({
      type: "settings/style-rules/set-active-tab",
      payload: { tab }
    });
  };
  const func2 = () => setActiveTab("global-rules");
  const func_1 = () => setActiveTab("document-rules");
  return [$activeTab, activeTab, setActiveTab, func2, func_1];
}
var Tab_header2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance120, create_fragment122, safe_not_equal, {}, add_css59);
  }
};
var tab_header_default2 = Tab_header2;

// src/view/components/container/style-rules/style-rules.svelte
function add_css60(target) {
  append_styles(target, "svelte-rft3in", ".modal-content.svelte-rft3in{max-width:100%;height:230px;overflow:auto}");
}
function create_else_block15(ctx) {
  let styleruleslist;
  let current;
  styleruleslist = new style_rules_list_default({
    props: { rules: (
      /*$globalRules*/
      ctx[2]
    ) }
  });
  return {
    c() {
      create_component(styleruleslist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(styleruleslist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const styleruleslist_changes = {};
      if (dirty & /*$globalRules*/
      4)
        styleruleslist_changes.rules = /*$globalRules*/
        ctx2[2];
      styleruleslist.$set(styleruleslist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(styleruleslist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(styleruleslist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(styleruleslist, detaching);
    }
  };
}
function create_if_block31(ctx) {
  let styleruleslist;
  let current;
  styleruleslist = new style_rules_list_default({
    props: { rules: (
      /*$documentRules*/
      ctx[1]
    ) }
  });
  return {
    c() {
      create_component(styleruleslist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(styleruleslist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const styleruleslist_changes = {};
      if (dirty & /*$documentRules*/
      2)
        styleruleslist_changes.rules = /*$documentRules*/
        ctx2[1];
      styleruleslist.$set(styleruleslist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(styleruleslist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(styleruleslist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(styleruleslist, detaching);
    }
  };
}
function create_default_slot67(ctx) {
  let tabheader;
  let t0;
  let div;
  let current_block_type_index;
  let if_block;
  let t1;
  let stylerulesfooter;
  let current;
  tabheader = new tab_header_default2({});
  const if_block_creators = [create_if_block31, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$activeTab*/
      ctx2[0] === "document-rules"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  stylerulesfooter = new style_rules_footer_default({});
  return {
    c() {
      create_component(tabheader.$$.fragment);
      t0 = space();
      div = element("div");
      if_block.c();
      t1 = space();
      create_component(stylerulesfooter.$$.fragment);
      attr(div, "class", "modal-content svelte-rft3in");
    },
    m(target, anchor) {
      mount_component(tabheader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t1, anchor);
      mount_component(stylerulesfooter, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabheader.$$.fragment, local);
      transition_in(if_block);
      transition_in(stylerulesfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tabheader.$$.fragment, local);
      transition_out(if_block);
      transition_out(stylerulesfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
        detach(t1);
      }
      destroy_component(tabheader, detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(stylerulesfooter, detaching);
    }
  };
}
function create_fragment123(ctx) {
  let draggablemodal;
  let current;
  draggablemodal = new draggable_modal_default({
    props: {
      $$slots: { default: [create_default_slot67] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(draggablemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draggablemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const draggablemodal_changes = {};
      if (dirty & /*$$scope, $documentRules, $activeTab, $globalRules*/
      135) {
        draggablemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      draggablemodal.$set(draggablemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(draggablemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draggablemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draggablemodal, detaching);
    }
  };
}
function instance121($$self, $$props, $$invalidate) {
  let $activeTab;
  let $documentRules;
  let $globalRules;
  const view = getView();
  const activeTab = ActiveStyleRulesTab(view);
  component_subscribe($$self, activeTab, (value) => $$invalidate(0, $activeTab = value));
  const documentRules = DocumentStyleRulesStore(view);
  component_subscribe($$self, documentRules, (value) => $$invalidate(1, $documentRules = value));
  const globalRules = GlobalStyleRulesStore(view);
  component_subscribe($$self, globalRules, (value) => $$invalidate(2, $globalRules = value));
  return [
    $activeTab,
    $documentRules,
    $globalRules,
    activeTab,
    documentRules,
    globalRules
  ];
}
var Style_rules = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance121, create_fragment123, safe_not_equal, {}, add_css60);
  }
};
var style_rules_default = Style_rules;

// src/view/components/container/main.svelte
function add_css61(target) {
  append_styles(target, "svelte-1g9h6to", ".lineage-main.svelte-1g9h6to{--z-index-breadcrumbs:10;display:flex;height:100%;flex:1 1 auto;width:0;position:relative}.lineage-view.svelte-1g9h6to{background-color:var(--background-container);display:flex;height:100%;width:100%}");
}
function create_if_block_33(ctx) {
  let stylerules;
  let current;
  stylerules = new style_rules_default({});
  return {
    c() {
      create_component(stylerules.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stylerules, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(stylerules.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stylerules.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stylerules, detaching);
    }
  };
}
function create_if_block_28(ctx) {
  let settings;
  let current;
  settings = new settings_default2({});
  return {
    c() {
      create_component(settings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settings, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settings, detaching);
    }
  };
}
function create_if_block_112(ctx) {
  let hotkeys;
  let current;
  hotkeys = new hotkeys_default({});
  return {
    c() {
      create_component(hotkeys.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeys, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkeys.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeys.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeys, detaching);
    }
  };
}
function create_if_block32(ctx) {
  let filehistory;
  let current;
  filehistory = new file_histoy_default({});
  return {
    c() {
      create_component(filehistory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filehistory, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(filehistory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filehistory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filehistory, detaching);
    }
  };
}
function create_fragment124(ctx) {
  let div1;
  let leftsidebar;
  let t0;
  let div0;
  let container;
  let t1;
  let toolbar;
  let t2;
  let breadcrumbs;
  let t3;
  let verticaltoolbar;
  let t4;
  let zoombuttons;
  let t5;
  let current_block_type_index;
  let if_block;
  let t6;
  let dndedges;
  let div0_class_value;
  let mouseWheelZoom_action;
  let clickAndDrag_action;
  let t7;
  let rightsidebar;
  let viewHotkeysAction_action;
  let showContextMenu_action;
  let current;
  let mounted;
  let dispose;
  leftsidebar = new left_sidebar_default({});
  container = new container_wrapper_default({});
  toolbar = new toolbar_default({});
  breadcrumbs = new breadcrumbs_default({});
  verticaltoolbar = new vertical_toolbar_default({});
  zoombuttons = new zoom_buttons_default({});
  const if_block_creators = [create_if_block32, create_if_block_112, create_if_block_28, create_if_block_33];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$controls*/
      ctx2[1].showHistorySidebar
    )
      return 0;
    if (
      /*$controls*/
      ctx2[1].showHelpSidebar
    )
      return 1;
    if (
      /*$controls*/
      ctx2[1].showSettingsSidebar
    )
      return 2;
    if (
      /*$controls*/
      ctx2[1].showStyleRulesModal
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  dndedges = new dnd_edges_default({});
  rightsidebar = new right_sidebar_default({});
  return {
    c() {
      div1 = element("div");
      create_component(leftsidebar.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(container.$$.fragment);
      t1 = space();
      create_component(toolbar.$$.fragment);
      t2 = space();
      create_component(breadcrumbs.$$.fragment);
      t3 = space();
      create_component(verticaltoolbar.$$.fragment);
      t4 = space();
      create_component(zoombuttons.$$.fragment);
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      create_component(dndedges.$$.fragment);
      t7 = space();
      create_component(rightsidebar.$$.fragment);
      attr(div0, "class", div0_class_value = null_to_empty(`lineage-main`) + " svelte-1g9h6to");
      attr(div1, "class", "lineage-view svelte-1g9h6to");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(leftsidebar, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(container, div0, null);
      append(div0, t1);
      mount_component(toolbar, div0, null);
      append(div0, t2);
      mount_component(breadcrumbs, div0, null);
      append(div0, t3);
      mount_component(verticaltoolbar, div0, null);
      append(div0, t4);
      mount_component(zoombuttons, div0, null);
      append(div0, t5);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append(div0, t6);
      mount_component(dndedges, div0, null);
      append(div1, t7);
      mount_component(rightsidebar, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(mouseWheelZoom_action = mouseWheelZoom.call(
            null,
            div0,
            /*view*/
            ctx[0]
          )),
          action_destroyer(clickAndDrag_action = clickAndDrag.call(
            null,
            div0,
            /*view*/
            ctx[0]
          )),
          action_destroyer(viewHotkeysAction_action = viewHotkeysAction.call(null, div1, { view: (
            /*view*/
            ctx[0]
          ) })),
          action_destroyer(showContextMenu_action = showContextMenu.call(
            null,
            div1,
            /*view*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
          }
          transition_in(if_block, 1);
          if_block.m(div0, t6);
        } else {
          if_block = null;
        }
      }
      if (mouseWheelZoom_action && is_function(mouseWheelZoom_action.update) && dirty & /*view*/
      1)
        mouseWheelZoom_action.update.call(
          null,
          /*view*/
          ctx2[0]
        );
      if (clickAndDrag_action && is_function(clickAndDrag_action.update) && dirty & /*view*/
      1)
        clickAndDrag_action.update.call(
          null,
          /*view*/
          ctx2[0]
        );
      if (viewHotkeysAction_action && is_function(viewHotkeysAction_action.update) && dirty & /*view*/
      1)
        viewHotkeysAction_action.update.call(null, { view: (
          /*view*/
          ctx2[0]
        ) });
      if (showContextMenu_action && is_function(showContextMenu_action.update) && dirty & /*view*/
      1)
        showContextMenu_action.update.call(
          null,
          /*view*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(leftsidebar.$$.fragment, local);
      transition_in(container.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(verticaltoolbar.$$.fragment, local);
      transition_in(zoombuttons.$$.fragment, local);
      transition_in(if_block);
      transition_in(dndedges.$$.fragment, local);
      transition_in(rightsidebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(leftsidebar.$$.fragment, local);
      transition_out(container.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(verticaltoolbar.$$.fragment, local);
      transition_out(zoombuttons.$$.fragment, local);
      transition_out(if_block);
      transition_out(dndedges.$$.fragment, local);
      transition_out(rightsidebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(leftsidebar);
      destroy_component(container);
      destroy_component(toolbar);
      destroy_component(breadcrumbs);
      destroy_component(verticaltoolbar);
      destroy_component(zoombuttons);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      destroy_component(dndedges);
      destroy_component(rightsidebar);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance122($$self, $$props, $$invalidate) {
  let $controls;
  let { plugin } = $$props;
  let { view } = $$props;
  setContext("plugin", plugin);
  setContext("view", view);
  const controls = uiControlsStore(view);
  component_subscribe($$self, controls, (value) => $$invalidate(1, $controls = value));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  return [view, $controls, controls, plugin];
}
var Main = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance122, create_fragment124, safe_not_equal, { plugin: 3, view: 0 }, add_css61);
  }
};
var main_default = Main;

// src/lib/tree-utils/sort/sort-groups.ts
var sortGroups = (parents, children2) => {
  const parentsIndices = Object.fromEntries(
    parents.map((x) => x.nodes).flat().map((x, i) => [x, i])
  );
  return children2.sort((a, b) => {
    return parentsIndices[a.parentId] - parentsIndices[b.parentId];
  });
};

// src/lib/tree-utils/insert/insert-child.ts
var insertChild = (document2, nodeIdOfParent, newNodeId, insertChildAtTheStart) => {
  const parentColumnIndex = findNodeColumn(document2.columns, nodeIdOfParent);
  if (parentColumnIndex === -1) {
    throw new Error("could not find parent column");
  }
  const childColumnIndex = parentColumnIndex + 1;
  const childColumn = document2.columns[childColumnIndex];
  if (childColumn) {
    const childGroup = childColumn.groups.find(
      (g) => g.parentId === nodeIdOfParent
    );
    if (childGroup) {
      if (insertChildAtTheStart) {
        childGroup.nodes = [newNodeId, ...childGroup.nodes];
      } else {
        childGroup.nodes = [...childGroup.nodes, newNodeId];
      }
    } else {
      childColumn.groups.push({
        nodes: [newNodeId],
        parentId: nodeIdOfParent
      });
      childColumn.groups = [...childColumn.groups];
    }
    childColumn.groups = sortGroups(
      document2.columns[parentColumnIndex].groups,
      childColumn.groups
    );
  } else {
    document2.columns.push({
      id: id.column(),
      groups: [
        {
          nodes: [newNodeId],
          parentId: nodeIdOfParent
        }
      ]
    });
    document2.columns = [...document2.columns];
  }
};

// src/lib/tree-utils/find/find-group-by-node-id.ts
var findGroupByNodeId = (columns, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (const _nodeId2 of group.nodes) {
        if (_nodeId2 === nodeId)
          return group;
      }
    }
  }
};
var findGroupByParentId = (columns, parentId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === parentId) {
        return { group, column };
      }
    }
  }
};

// src/lib/tree-utils/find/find-node-column-and-parent.ts
var findNodeColumnAndParent = (columns, nodeId) => {
  for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      for (const node of group.nodes) {
        if (node === nodeId) {
          return [i, group.parentId];
        }
      }
    }
  }
  return null;
};

// src/lib/tree-utils/insert/insert-node-after-parent.ts
var insertNodeAfterParent = (document2, nodeId, newNodeId) => {
  const column = findNodeColumnAndParent(document2.columns, nodeId);
  if (!column)
    throw new Error("could not find parent column");
  if (column[0] === 0) {
    throw new SilentError(
      "can't create parent sibling for first column nodes"
    );
  }
  const parentId = column[1];
  const parentGroup = findGroupByNodeId(document2.columns, parentId);
  if (!parentGroup)
    throw new Error("could not find group of parent node");
  parentGroup.nodes = parentGroup.nodes.reduce((nodes, nodeId2) => {
    nodes.push(nodeId2);
    if (nodeId2 === parentId) {
      nodes.push(newNodeId);
    }
    return nodes;
  }, []);
};

// src/stores/document/reducers/insert-node/insert-node.ts
var insertNode = (document2, position, activeNodeId, content, newNodeId = id.node()) => {
  invariant(activeNodeId);
  if (position === "right") {
    insertChild(document2, activeNodeId, newNodeId, !!content);
  } else if (position === "right-last") {
    insertChild(document2, activeNodeId, newNodeId, false);
  } else if (position === "left") {
    insertNodeAfterParent(document2, activeNodeId, newNodeId);
  } else {
    const columnIndex = findNodeColumn(document2.columns, activeNodeId);
    const column = document2.columns[columnIndex];
    invariant(column);
    const group = findGroupByNodeId([column], activeNodeId);
    invariant(group, "could not find group of " + activeNodeId);
    const groupIndex = group.nodes.findIndex((c) => c === activeNodeId);
    const insertionIndex = position === "up" ? groupIndex : groupIndex + 1;
    group.nodes.splice(insertionIndex, 0, newNodeId);
    group.nodes = [...group.nodes];
  }
  document2.content[newNodeId] = {
    content: content || ""
  };
  return newNodeId;
};

// src/lib/tree-utils/find/find-child-group.ts
var findChildGroup = (columns, node) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === node) {
        return group;
      }
    }
  }
};

// src/lib/tree-utils/move/move-node-as-child.ts
var moveNodeAsChild = (document2, node, targetNode, moveToTheStart) => {
  const targetGroup = findChildGroup(document2.columns, targetNode);
  if (targetGroup) {
    if (moveToTheStart) {
      targetGroup.nodes = [node, ...targetGroup.nodes];
    } else {
      targetGroup.nodes = [...targetGroup.nodes, node];
    }
  } else {
    const currentColumnIndex = findNodeColumn(document2.columns, targetNode);
    let targetColumn;
    targetColumn = document2.columns[currentColumnIndex + 1];
    if (!targetColumn) {
      const newColumn = createColumn();
      document2.columns.push(newColumn);
      document2.columns = [...document2.columns];
      targetColumn = newColumn;
    }
    const newGroup = createGroup(targetNode);
    newGroup.nodes.push(node);
    targetColumn.groups.push(newGroup);
    targetColumn.groups = [...targetColumn.groups];
  }
};

// src/lib/tree-utils/move/move-node-as-sibling.ts
var moveNodeAsSibling = (columns, direction, node, targetNode, adjacentGroup) => {
  const targetGroup = findGroupByNodeId(columns, targetNode);
  if (targetGroup) {
    let insertionIndex;
    if (adjacentGroup && adjacentGroup.parentId !== targetGroup.parentId) {
      if (direction === "down") {
        targetGroup.nodes.splice(0, 0, node);
        targetGroup.nodes = [...targetGroup.nodes];
      } else if (direction === "up") {
        targetGroup.nodes.push(node);
        targetGroup.nodes = [...targetGroup.nodes];
      }
    } else {
      direction = direction === "left" ? "down" : direction;
      const index = targetGroup.nodes.findIndex((n) => n === targetNode);
      insertionIndex = direction === "up" ? index : index + 1;
      targetGroup.nodes.splice(insertionIndex, 0, node);
      targetGroup.nodes = [...targetGroup.nodes];
    }
  }
};

// src/lib/tree-utils/move/move-child-groups-next-to-their-parent.ts
var moveChildGroupsNextToTheirParent = (document2, parentNode) => {
  const sortedChildGroups = getSortedChildGroups(
    document2.columns,
    parentNode,
    true
  );
  const parentColumnIndex = findNodeColumn(document2.columns, parentNode);
  for (let i = 0; i < sortedChildGroups.length; i++) {
    const groups = sortedChildGroups[i];
    for (const group of groups) {
      const targetColumnIndex = parentColumnIndex + 1 + i;
      if (!document2.columns[targetColumnIndex]) {
        document2.columns.push({
          id: id.column(),
          groups: []
        });
        document2.columns = [...document2.columns];
      }
      document2.columns[targetColumnIndex].groups.push(group);
      document2.columns[targetColumnIndex].groups = [
        ...document2.columns[targetColumnIndex].groups
      ];
    }
  }
};

// src/lib/tree-utils/move/change-node-position.ts
var changeNodePosition = (document2, node, targetNode, direction, type, moveChildToTheStart) => {
  const group = findGroupByNodeId(document2.columns, node);
  invariant(group);
  deleteNodeById(document2.columns, null, node);
  if (direction === "right") {
    moveNodeAsChild(document2, node, targetNode, moveChildToTheStart);
  } else {
    moveNodeAsSibling(
      document2.columns,
      direction,
      node,
      targetNode,
      type === "move" && direction !== "left" ? group : void 0
    );
  }
  moveChildGroupsNextToTheirParent(document2, node);
};

// src/lib/tree-utils/sort/clean-and-sort-columns.ts
var cleanAndSortColumns = (document2) => {
  const emptyColumns = /* @__PURE__ */ new Set();
  for (let i = 1; i < document2.columns.length; i++) {
    const column = document2.columns[i];
    column.groups = column.groups.filter((g) => g.nodes.length > 0);
    if (column.groups.length === 0) {
      emptyColumns.add(column.id);
    }
  }
  for (const emptyColumn of emptyColumns) {
    const i = document2.columns.findIndex((c) => c.id === emptyColumn);
    if (i > 0) {
      document2.columns.splice(i, 1);
      document2.columns = [...document2.columns];
    }
  }
  for (let i = 1; i < document2.columns.length; i++) {
    const column = document2.columns[i];
    if (column.groups.length) {
      const previousColumn = document2.columns[i - 1];
      if (column.groups.length > 0) {
        column.groups = sortGroups(
          previousColumn.groups,
          column.groups
        );
      }
    }
  }
};

// src/stores/document/reducers/drop-node/drop-node.ts
var dropNode = (document2, action) => {
  const droppedNode = action.payload.droppedNodeId;
  const targetNode = action.payload.targetNodeId;
  invariant(droppedNode);
  invariant(targetNode);
  changeNodePosition(
    document2,
    droppedNode,
    targetNode,
    action.payload.position,
    "drop",
    false
  );
  cleanAndSortColumns(document2);
};

// src/lib/data-conversion/json-to-x/json-to-columns.ts
var groupsCache = {};
var findGroup2 = (column, parentId) => {
  if (!groupsCache[parentId]) {
    groupsCache[parentId] = column.groups.find(
      (g) => g.parentId === parentId
    );
  }
  return groupsCache[parentId];
};
var jsonToColumns = (tree, parentId = id.rootNode(), columns = [], content = {}, level2 = 0) => {
  for (const treeNode of tree) {
    const node = id.node();
    content[node] = {
      content: treeNode.content
    };
    if (!columns[level2]) {
      columns.push(createColumn());
    }
    const column = columns[level2];
    let group;
    group = findGroup2(column, parentId);
    if (!group) {
      group = createGroup(parentId);
      column.groups.push(group);
    }
    group.nodes.push(node);
    if (treeNode.children.length > 0) {
      jsonToColumns(treeNode.children, node, columns, content, level2 + 1);
    }
  }
  return { content, columns };
};

// src/lib/tree-utils/insert/insert-first-node.ts
var insertFirstNode = (columns, content) => {
  const rootId = id.rootNode();
  const createdNode = id.node();
  if (columns.length === 0) {
    content[createdNode] = { content: "" };
    columns.push({
      id: id.column(),
      groups: [
        {
          parentId: rootId,
          nodes: [createdNode]
        }
      ]
    });
  } else if (columns.length === 1 && columns[0].groups.length === 1 && columns[0].groups[0].nodes.length === 0) {
    content[createdNode] = { content: "" };
    columns[0].groups[0].nodes = [createdNode];
  } else
    throw new Error("document is not empty");
  return createdNode;
};

// src/stores/document/reducers/load-document-from-file/load-document-from-file.ts
var loadDocumentFromFile = (state2, action) => {
  const tree = action.payload.format === "outline" ? outlineToJson(action.payload.document.data) : action.payload.format === "html-element" ? htmlElementToJson(action.payload.document.data) : htmlCommentToJson(action.payload.document.data);
  const document2 = jsonToColumns(tree);
  state2.document.columns = document2.columns;
  state2.document.content = document2.content;
  const emptyTree = tree.length === 0;
  if (emptyTree) {
    insertFirstNode(state2.document.columns, state2.document.content);
  }
  if (action.type === "document/file/load-from-disk")
    state2.file.frontmatter = action.payload.document.frontmatter;
  const activeNode = state2.document.columns[0].groups[0].nodes[0];
  invariant(activeNode);
  return activeNode;
};

// src/stores/document/reducers/content/set-node-content.ts
var setNodeContent = (content, action) => {
  const nodeContent = content[action.payload.nodeId];
  const contentString = nodeContent?.content || "";
  if (contentString === action.payload.content)
    return false;
  const nodeId = action.payload.nodeId;
  if (!nodeContent)
    content[nodeId] = { content: action.payload.content };
  else
    nodeContent.content = action.payload.content;
  return true;
};

// src/lib/tree-utils/delete/delete-groups-by-parent-id.ts
var deleteGroupsByParentId = (columns, content, parentIds) => {
  for (const column of columns) {
    const groups = [];
    for (const group of column.groups) {
      if (parentIds.has(group.parentId)) {
        for (const node of group.nodes) {
          delete content[node];
        }
      } else {
        groups.push(group);
      }
    }
    column.groups = groups;
  }
};

// src/lib/tree-utils/delete/delete-child-nodes.ts
var deleteChildNodes = (document2, node) => {
  const childGroups = traverseDown(document2.columns, node, false);
  if (childGroups.length > 0)
    deleteGroupsByParentId(
      document2.columns,
      document2.content,
      new Set(childGroups)
    );
};

// src/lib/tree-utils/assert/is-last-root-node.ts
var isLastRootNode = (columns, node) => {
  const column = columns[0];
  if (node && column.groups.length === 1) {
    const group = column.groups[0];
    if (group.nodes.length === 1 && group.nodes[0] === node)
      return true;
  }
  return false;
};

// src/lib/tree-utils/find/find-next-node-after-deletion.ts
var findNextNodeAfterDeletion = (columns, node) => {
  let nextNode = null;
  const group = findGroupByNodeId(columns, node);
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (group) {
    const nodeIndex = group.nodes.findIndex((n) => n === node);
    if (nodeIndex === 0)
      nextNode = group.nodes[1];
    else if (nodeIndex > 0)
      nextNode = group.nodes[nodeIndex - 1];
    else
      nextNode = group.nodes[group.nodes.length - 1];
  }
  if (!nextNode) {
    if (group && columnIndex > 0)
      nextNode = group?.parentId;
    else
      nextNode = column.groups[0].nodes[0];
  }
  return nextNode;
};

// src/stores/document/reducers/delete-node/delete-node.ts
var deleteNode2 = (document2, nodeId, selectedNodes) => {
  invariant(nodeId);
  const isSelection = selectedNodes && selectedNodes.size > 0;
  const nodes = isSelection ? [...selectedNodes] : [nodeId];
  let nextNode = void 0;
  for (let i = 0; i < nodes.length; i++) {
    const nodeId2 = nodes[i];
    if (i === nodes.length - 1 && !isLastRootNode(document2.columns, nodeId2)) {
      nextNode = findNextNodeAfterDeletion(document2.columns, nodeId2);
    }
    deleteChildNodes(document2, nodeId2);
    deleteNodeById(document2.columns, document2.content, nodeId2);
    cleanAndSortColumns(document2);
  }
  if (!nextNode) {
    nextNode = insertFirstNode(document2.columns, document2.content);
  }
  invariant(nextNode);
  return nextNode;
};

// src/lib/tree-utils/find/find-sibling-node-in-group.ts
var findSiblingNodeInGroup = (columns, node, direction) => {
  const group = findGroupByNodeId(columns, node);
  invariant(group);
  const nodeIndex = group.nodes.findIndex((n) => n === node);
  return group.nodes[nodeIndex + (direction === "up" ? -1 : 1)];
};

// src/lib/tree-utils/find/find-sibling-node.ts
var findSiblingNode = (columns, node, direction) => {
  return findSiblingNodeInGroup(
    columns,
    node,
    direction === "right" ? "up" : direction
  );
};

// src/lib/tree-utils/find/find-adjacent-node.ts
var findAdjacentNode = (columns, nodeToMove, direction) => {
  let targetNode = null;
  if (direction === "left") {
    const group = findGroupByNodeId(columns, nodeToMove);
    if (group && !group.parentId.startsWith("r"))
      targetNode = group.parentId;
  } else {
    targetNode = findSiblingNode(columns, nodeToMove, direction);
  }
  if (!targetNode && direction === "right") {
    const columnIndex = findNodeColumn(columns, nodeToMove);
    const isFirstNodeOfColumn = columns[columnIndex].groups[0]?.nodes[0] === nodeToMove;
    if (isFirstNodeOfColumn) {
      targetNode = findSiblingNode(columns, nodeToMove, "down");
    }
  }
  return targetNode;
};

// src/lib/tree-utils/find/find-adjacent-node-of-selection.ts
var findAdjacentNodeOfSelection = (document2, activeNodeId, selectedNodes, direction) => {
  const searchColumns = clone(document2.columns);
  if (selectedNodes && selectedNodes.size > 1) {
    const column = searchColumns[findNodeColumn(searchColumns, activeNodeId)];
    invariant(column);
    for (const group of column.groups) {
      group.nodes = group.nodes.filter(
        (n) => n === activeNodeId || !selectedNodes?.has(n)
      );
    }
  }
  return findAdjacentNode(searchColumns, activeNodeId, direction);
};

// src/lib/tree-utils/find/find-adjacent-parent.ts
var findAdjacentParent = (columns, nodeToMove, direction) => {
  const [columnIndex, parentId] = findNodeColumnAndParent(
    columns,
    nodeToMove
  );
  if (columnIndex > 0) {
    return findSiblingNode(columns, parentId, direction);
  }
  return null;
};

// src/stores/document/reducers/move-node/move-node.ts
var moveNode2 = (document2, action) => {
  const selectedNodes = action.payload.selectedNodes;
  const isSelection = selectedNodes && selectedNodes.size > 1;
  const nodes = isSelection ? [...selectedNodes] : [action.payload.activeNodeId];
  let direction = action.payload.direction;
  const shouldReverseOrder = isSelection && (direction === "down" || direction === "left");
  if (shouldReverseOrder)
    nodes.reverse();
  invariant(action.payload.activeNodeId);
  let targetNode = isSelection ? findAdjacentNodeOfSelection(
    document2,
    action.payload.activeNodeId,
    selectedNodes,
    direction
  ) : findAdjacentNode(
    document2.columns,
    action.payload.activeNodeId,
    direction
  );
  let moveNodeToTheStart = false;
  if (!targetNode && (direction === "down" || direction === "up")) {
    targetNode = findAdjacentParent(
      document2.columns,
      action.payload.activeNodeId,
      direction
    );
    moveNodeToTheStart = direction === "down";
    direction = "right";
  }
  if (!targetNode)
    throw new SilentError("could not find adjacent node");
  for (const nodeToMove of nodes) {
    changeNodePosition(
      document2,
      nodeToMove,
      targetNode,
      direction,
      "move",
      moveNodeToTheStart
    );
    cleanAndSortColumns(document2);
  }
};

// src/lib/tree-utils/find/find-sibling-node-in-column.ts
var findSiblingNodeInColumn = (columns, node, direction) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  const flatColumn = column.groups.map((g) => g.nodes).flat();
  const nodeIndex = flatColumn.findIndex((n) => n === node);
  return flatColumn[nodeIndex + (direction === "up" ? -1 : 1)];
};

// src/lib/tree-utils/move/move-orphan-groups-to-a-new-parent.ts
var moveOrphanGroupsToANewParent = (document2, currentParentNode, newParentNode, direction) => {
  const groupOfMergedNode = findGroupByParentId(
    document2.columns,
    currentParentNode
  );
  if (!groupOfMergedNode)
    return;
  groupOfMergedNode.column.groups = groupOfMergedNode.column.groups.filter(
    (g) => g.parentId !== groupOfMergedNode.group.parentId
  );
  const parentColumnIndex = findNodeColumn(document2.columns, newParentNode);
  const targetColumnIndex = parentColumnIndex + 1;
  const existingGroupOfNewParent = findGroupByParentId(
    document2.columns,
    newParentNode
  );
  if (existingGroupOfNewParent) {
    if (direction === "up")
      existingGroupOfNewParent.group.nodes = [
        ...existingGroupOfNewParent.group.nodes,
        ...groupOfMergedNode.group.nodes
      ];
    else {
      existingGroupOfNewParent.group.nodes = [
        ...groupOfMergedNode.group.nodes,
        ...existingGroupOfNewParent.group.nodes
      ];
    }
  } else {
    if (!document2.columns[targetColumnIndex]) {
      document2.columns.push({
        id: id.column(),
        groups: []
      });
      document2.columns = [...document2.columns];
    }
    groupOfMergedNode.group.parentId = newParentNode;
    document2.columns[targetColumnIndex].groups.push(
      groupOfMergedNode.group
    );
    document2.columns[targetColumnIndex].groups = [
      ...document2.columns[targetColumnIndex].groups
    ];
  }
};

// src/stores/document/reducers/merge-node/merge-node.ts
var mergeNode2 = (document2, action) => {
  const mergedNode = action.payload.activeNodeId;
  const adjacentNode = findSiblingNodeInColumn(
    document2.columns,
    mergedNode,
    action.payload.direction
  );
  invariant(mergedNode, "merged node is undefined");
  if (!adjacentNode)
    throw new SilentError("could not find adjacent node");
  const mergedNodeContent = document2.content[mergedNode] || { content: "" };
  const adjacentNodeContent = document2.content[adjacentNode] || {
    content: ""
  };
  let newContent = "";
  if (action.payload.direction === "up") {
    newContent = (adjacentNodeContent.content + "\n" + mergedNodeContent.content).trim();
  } else if (action.payload.direction === "down") {
    newContent = (mergedNodeContent.content + "\n" + adjacentNodeContent.content).trim();
  }
  if (newContent) {
    const adjacentNodeContentObject = document2.content[adjacentNode];
    if (adjacentNodeContentObject) {
      adjacentNodeContentObject.content = newContent;
    } else {
      document2.content[adjacentNode] = { content: newContent };
    }
  }
  moveOrphanGroupsToANewParent(
    document2,
    mergedNode,
    adjacentNode,
    action.payload.direction
  );
  deleteNodeById(document2.columns, document2.content, mergedNode);
  cleanAndSortColumns(document2);
  return adjacentNode;
};

// src/stores/document/reducers/history/helpers/update-navigation-state.ts
var updateNavigationState = (document2) => {
  const activeIndex = document2.state.activeIndex;
  document2.state.canGoBack = activeIndex > 0;
  document2.state.canGoForward = activeIndex < document2.items.length - 1;
};

// src/stores/document/reducers/history/helpers/create-snapshot.ts
var createSnapshot = (document2, context) => {
  return {
    data: {
      columns: JSON.stringify(document2.columns),
      content: JSON.stringify(document2.content)
    },
    context,
    created: Date.now(),
    id: id.snapshot()
  };
};

// src/stores/document/reducers/history/helpers/remove-old-history-items.ts
var removeOldHistoryItems = (history, MAX_ITEMS) => {
  if (history.items.length >= MAX_ITEMS) {
    const numSnapshotsToRemove = history.items.length - MAX_ITEMS + 1;
    history.items.splice(0, numSnapshotsToRemove);
    const activeItem = history.items[history.state.activeIndex];
    history.state.activeIndex = history.items.findIndex(
      (item) => item === activeItem
    );
  }
};

// src/stores/document/reducers/history/helpers/remove-obsolete-history-items.ts
var removeObsoleteHistoryItems = (history) => {
  if (history.items.length > 0 && history.state.activeIndex !== history.items.length - 1) {
    history.items.splice(history.state.activeIndex + 1);
  }
};

// src/stores/document/reducers/history/add-snapshot.ts
var addSnapshot = (document2, history, context) => {
  const items = history.items;
  const activeIndex = history.state.activeIndex;
  const activeSnapshot = items[activeIndex];
  removeObsoleteHistoryItems(history);
  removeOldHistoryItems(history, 200);
  if (activeSnapshot && context.action.type === "document/file/load-from-disk") {
    const snapshotContent = JSON.stringify(
      Object.values(JSON.parse(activeSnapshot.data.content))
    );
    const documentContent = JSON.stringify(Object.values(document2.content));
    if (snapshotContent === documentContent) {
      history.items.splice(history.state.activeIndex, 1);
    }
  }
  const snapshot = createSnapshot(document2, context);
  items.push(snapshot);
  history.state.activeIndex = items.length - 1;
  history.context.activeSection = context.newActiveSection;
  updateNavigationState(history);
};

// src/stores/document/reducers/history/helpers/find-snapshot-index.ts
var findSnapshotIndex = (snapshots, id2) => {
  if (!id2)
    return -1;
  return snapshots.findIndex((snapshot) => snapshot.id === id2);
};

// src/stores/document/reducers/history/helpers/load-document-from-snapshot.ts
var loadDocumentFromSnapshot = (document2, snapshot, history) => {
  history.context.activeSection = snapshot.context.newActiveSection;
  document2.content = JSON.parse(snapshot.data.content);
  document2.columns = JSON.parse(snapshot.data.columns);
};

// src/stores/document/reducers/history/select-snapshot.ts
var selectSnapshot = (document2, history, action) => {
  const index = findSnapshotIndex(history.items, action.payload.snapshotId);
  if (index !== -1) {
    history.state.activeIndex = index;
    updateNavigationState(history);
    const snapshot = history.items[index];
    loadDocumentFromSnapshot(document2, snapshot, history);
  }
};

// src/stores/document/reducers/history/undo-action.ts
var undoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const newIndex = currentIndex - 1;
  const snapshot = history.items[newIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = newIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/view/helpers/get-document-event-type.ts
var eventTypesDictionary = {
  "document/update-node-content": { content: true },
  "document/format-headings": { content: true },
  "document/add-node": { createOrDelete: true },
  "document/delete-node": { createOrDelete: true },
  "document/merge-node": { createOrDelete: true },
  "document/file/load-from-disk": { createOrDelete: true },
  "document/extract-node": { createOrDelete: true },
  "document/split-node": { createOrDelete: true },
  "document/drop-node": { dropOrMove: true },
  "document/move-node": { dropOrMove: true },
  "document/sort-direct-child-nodes": { dropOrMove: true },
  "document/history/select-next-snapshot": { changeHistory: true },
  "document/history/select-previous-snapshot": { changeHistory: true },
  "document/history/select-snapshot": { changeHistory: true },
  "document/paste-node": { clipboard: true },
  "document/cut-node": { clipboard: true }
};
var documentEventTypes = new Map(Object.entries(eventTypesDictionary));
var none = {};
var getDocumentEventType = (type) => {
  return documentEventTypes.get(type) || none;
};

// src/stores/document/reducers/history/redo-action.ts
var redoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const nexIndex = currentIndex + 1;
  const snapshot = history.items[nexIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = nexIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/document/reducers/content/format-content/helpers/format-headings.ts
var formatHeadings = (content, treeIndexDict) => {
  for (const nodeId in content) {
    const currentContent = content[nodeId]?.content;
    if (!currentContent)
      continue;
    const sectionNumber = treeIndexDict[nodeId];
    if (!sectionNumber)
      continue;
    const depth = sectionNumber.split(".").length;
    const symbol = `${"#".repeat(Math.min(depth, 6))} `;
    const lines = currentContent.split("\n");
    const updatedLines = lines.map((line) => {
      const match = /^#+ /.exec(line);
      if (match) {
        return line.replace(match[0], symbol);
      }
      return line;
    });
    content[nodeId] = {
      content: updatedLines.join("\n")
    };
  }
};

// src/stores/document/reducers/content/format-content/format-headings.ts
var formatHeadings2 = (content, sections) => {
  formatHeadings(content, sections.id_section);
};

// src/stores/document/reducers/clipboard/paste-node/helpers/past-child-groups.ts
var pastChildGroups = (document2, branch) => {
  const parentColumnIndex = findNodeColumn(document2.columns, branch.nodeId);
  if (parentColumnIndex === -1)
    throw new Error("could not find cut node");
  for (let i = 0; i < branch.sortedChildGroups.length; i++) {
    const groups = branch.sortedChildGroups[i];
    for (const group of groups) {
      const targetColumnIndex = parentColumnIndex + 1 + i;
      if (!document2.columns[targetColumnIndex]) {
        document2.columns.push({
          id: id.column(),
          groups: []
        });
        document2.columns = [...document2.columns];
      }
      for (const node of group.nodes) {
        if (node in branch.content) {
          document2.content[node] = branch.content[node];
        }
      }
      document2.columns[targetColumnIndex].groups.push(group);
      document2.columns[targetColumnIndex].groups = [
        ...document2.columns[targetColumnIndex].groups
      ];
    }
  }
};

// src/lib/format-detection/has-n-html-comment-marker.ts
var hasNHtmlCommentMarker = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (parseHtmlCommentMarker(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/has-n-bullet-list-items.ts
var hasNBulletListItems = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (/^(\t*)- (.+)/.test(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/has-n-html-element-markers.ts
var hasNHtmlElementMarker = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (parseHtmlElementMarker(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/detect-document-format.ts
var detectDocumentFormat = (text2, strict = true) => {
  const { body } = extractFrontmatter(text2);
  if (hasNHtmlCommentMarker(body, 1))
    return "sections";
  if (hasNHtmlElementMarker(body, 1))
    return "html-element";
  if (isOutline(body))
    return "outline";
  if (!strict) {
    if (hasNBulletListItems(text2, 1))
      return "outline";
  }
};

// src/stores/document/reducers/clipboard/paste-node/helpers/text-to-branches.ts
var textToBranches = (text2) => {
  const detectedFormat = detectDocumentFormat(text2, false);
  const tree = text2.trim().length > 0 ? detectedFormat === "outline" ? outlineToJson(text2) : detectedFormat === "html-element" ? htmlElementToJson(text2) : htmlCommentToJson(text2) : [{ children: [], content: "" }];
  const document2 = jsonToColumns(tree);
  const branches = [];
  for (const nodeId of document2.columns[0].groups[0].nodes) {
    const branch = getBranch(
      document2.columns,
      document2.content,
      nodeId,
      "copy"
    );
    branches.push(branch);
  }
  return branches;
};

// src/stores/document/reducers/clipboard/paste-node/paste-node.ts
var pasteNode2 = (document2, action) => {
  const branches = textToBranches(action.payload.text);
  const nextNode = branches[branches.length - 1].nodeId;
  const targetNode = action.payload.targetNodeId;
  const position = action.payload.position || "down";
  for (const branch of branches.reverse()) {
    insertNode(
      document2,
      position === "right" ? "right-last" : position,
      targetNode,
      branch.content[branch.nodeId]?.content,
      branch.nodeId
    );
    pastChildGroups(document2, branch);
  }
  cleanAndSortColumns(document2);
  invariant(nextNode);
  return {
    nextNode,
    rootNodes: branches.map((b) => b.nodeId).reverse()
  };
};

// src/stores/view/subscriptions/helpers/calculate-tree-index.ts
var calculateColumnTreeIndexes = (columns) => {
  const sections = { id_section: {}, section_id: {} };
  if (columns.length === 0)
    return sections;
  for (let nI = 0; nI < columns[0].groups[0].nodes.length; nI++) {
    const node = columns[0].groups[0].nodes[nI];
    const section = String(nI + 1);
    sections.id_section[node] = section;
    sections.section_id[section] = node;
  }
  for (let cI = 1; cI < columns.length; cI++) {
    const column = columns[cI];
    for (let gI = 0; gI < column.groups.length; gI++) {
      const group = column.groups[gI];
      for (let nI = 0; nI < group.nodes.length; nI++) {
        const node = group.nodes[nI];
        const section = sections.id_section[group.parentId] + "." + (nI + 1);
        sections.id_section[node] = section;
        sections.section_id[section] = node;
      }
    }
  }
  return sections;
};

// src/stores/document/reducers/state/update-sections-dictionary.ts
var updateSectionsDictionary = (state2) => {
  state2.sections = calculateColumnTreeIndexes(state2.document.columns);
};

// src/stores/view/subscriptions/helpers/get-id-of-section.ts
var getIdOfSection = (sections, section) => {
  const id2 = sections.section_id[section];
  invariant(id2);
  return id2;
};

// src/stores/document/reducers/extract-node/remove-extracted-branch.ts
var removeExtractedBranch = (document2, action) => {
  invariant(action.payload.nodeId);
  invariant(action.payload.documentName);
  deleteChildNodes(document2, action.payload.nodeId);
  cleanAndSortColumns(document2);
};

// src/stores/view/subscriptions/helpers/get-section-of-id.ts
var getSectionOfId = (sections, nodeId) => {
  const section = sections.id_section[nodeId];
  invariant(section);
  return section;
};

// src/stores/document/reducers/split-node/split-node.ts
var splitNode = (document2, action) => {
  const targetNode = action.payload.target;
  const content = document2.content[targetNode];
  if (!content?.content)
    throw new SilentError("empty node");
  const sections = splitText(content?.content, action.payload.mode);
  if (sections === content.content)
    throw new Error(lang.error_cm_cant_split_node_identical);
  const childGroup = findChildGroup(document2.columns, targetNode);
  if (childGroup)
    throw new Error(lang.error_cm_cant_split_node_that_has_children);
  const result = pasteNode2(document2, {
    payload: {
      position: "down",
      targetNodeId: targetNode,
      text: sections
    }
  });
  deleteNode2(document2, targetNode);
  return result.nextNode;
};

// src/stores/document/reducers/pinned-nodes/pin-node.ts
var pinNode = (sections, pinnedNodes, id2) => {
  pinnedNodes.Ids.push(id2);
  pinnedNodes.Ids = sortNodeIdsBySectionNumber(sections, pinnedNodes.Ids);
};

// src/stores/document/reducers/pinned-nodes/unpin-node.ts
var unpinNode = (pinnedNodes, id2) => {
  pinnedNodes.Ids = pinnedNodes.Ids.filter((_id) => _id !== id2);
};

// src/stores/document/reducers/pinned-nodes/remove-stale-pinned-nodes.ts
var removeStalePinnedNodes = (pinnedNodes, sections) => {
  pinnedNodes.Ids = pinnedNodes.Ids.filter((id2) => sections.id_section[id2]);
  pinnedNodes.Ids = sortNodeIdsBySectionNumber(sections, pinnedNodes.Ids);
};

// src/stores/document/reducers/pinned-nodes/load-pinned-nodes.ts
var loadPinnedNodes = (pinnedNodes, sections, pinnedSections) => {
  pinnedNodes.Ids = pinnedSections.map((section) => sections.section_id[section]).filter((x) => x);
};

// src/stores/document/reducers/meta/refresh-group-parent-ids.ts
var refreshGroupParentIds = (columns, meta) => {
  const groupParentIds = /* @__PURE__ */ new Set();
  for (const column of columns) {
    for (const group of column.groups) {
      groupParentIds.add(group.parentId);
    }
  }
  meta.groupParentIds = groupParentIds;
};

// src/stores/document/reducers/load-document-from-file/load-document-from-json.ts
var loadDocumentFromJSON = (state2, document2) => {
  state2.document.columns = document2.columns;
  state2.document.content = document2.content;
  const activeNode = state2.document.columns[0].groups[0].nodes[0];
  invariant(activeNode);
  return activeNode;
};

// src/stores/document/reducers/sort/sort-direct-child-nodes.ts
var sortDirectChildNodes = (document2, payload) => {
  const group = findGroupByParentId(document2.columns, payload.id);
  invariant(group);
  const copy = [...group.group.nodes];
  const sorted = payload.order === "ascending" ? copy.sort((a, b) => {
    const content_a = document2.content[a].content;
    const content_b = document2.content[b].content;
    return content_a.localeCompare(content_b, void 0, {
      numeric: true
    });
  }) : copy.sort((a, b) => {
    const content_a = document2.content[a].content;
    const content_b = document2.content[b].content;
    return content_b.localeCompare(content_a, void 0, {
      numeric: true
    });
  });
  group.group.nodes = sorted;
  cleanAndSortColumns(document2);
};

// src/stores/document/document-reducer.ts
var updateDocumentState2 = (state2, action) => {
  let newActiveNodeId = null;
  let affectedNodeId = null;
  let affectedNodeContent = null;
  let affectedNodes = void 0;
  if (action.type === "document/update-node-content") {
    const update2 = setNodeContent(state2.document.content, action);
    if (!update2)
      return NO_UPDATE;
    newActiveNodeId = action.payload.nodeId;
  } else if (action.type === "document/add-node") {
    newActiveNodeId = insertNode(
      state2.document,
      action.payload.position,
      action.payload.activeNodeId,
      action.payload.content
    );
  } else if (action.type === "document/delete-node") {
    affectedNodeContent = state2.document.content[action.payload.activeNodeId];
    newActiveNodeId = deleteNode2(
      state2.document,
      action.payload.activeNodeId,
      action.payload.selectedNodes
    );
    affectedNodeId = action.payload.activeNodeId;
  } else if (action.type === "document/extract-node") {
    affectedNodeContent = state2.document.content[action.payload.nodeId];
    const update2 = setNodeContent(state2.document.content, {
      payload: {
        nodeId: action.payload.nodeId,
        content: `[[${action.payload.documentName}]]`
      }
    });
    if (!update2)
      return NO_UPDATE;
    removeExtractedBranch(state2.document, action);
    newActiveNodeId = action.payload.nodeId;
  } else if (action.type === "document/split-node") {
    affectedNodeId = action.payload.target;
    affectedNodeContent = state2.document.content[affectedNodeId];
    newActiveNodeId = splitNode(state2.document, action);
  } else if (action.type === "document/drop-node") {
    dropNode(state2.document, action);
    newActiveNodeId = action.payload.droppedNodeId;
  } else if (action.type === "document/move-node") {
    moveNode2(state2.document, action);
    newActiveNodeId = action.payload.activeNodeId;
    affectedNodeId = newActiveNodeId;
  } else if (action.type === "document/merge-node") {
    affectedNodeContent = state2.document.content[action.payload.activeNodeId];
    newActiveNodeId = mergeNode2(state2.document, action);
    affectedNodeId = action.payload.activeNodeId;
  } else if (action.type === "document/sort-direct-child-nodes") {
    sortDirectChildNodes(state2.document, action.payload);
    newActiveNodeId = action.payload.id;
    affectedNodeId = newActiveNodeId;
  } else if (action.type === "document/file/load-from-disk") {
    if (action.payload.__test_document__) {
      newActiveNodeId = loadDocumentFromJSON(
        state2,
        action.payload.__test_document__
      );
    } else {
      newActiveNodeId = loadDocumentFromFile(state2, action);
    }
  } else if (action.type === "document/history/select-snapshot") {
    selectSnapshot(state2.document, state2.history, action);
    state2.history = { ...state2.history };
  } else if (action.type === "document/history/select-previous-snapshot") {
    undoAction(state2.document, state2.history);
    state2.history = { ...state2.history };
  } else if (action.type === "document/history/select-next-snapshot") {
    redoAction(state2.document, state2.history);
    state2.history = { ...state2.history };
  } else if (action.type === "document/format-headings") {
    formatHeadings2(state2.document.content, state2.sections);
    newActiveNodeId = getIdOfSection(
      state2.sections,
      state2.history.context.activeSection
    );
  } else if (action.type === "document/paste-node") {
    const result = pasteNode2(state2.document, action);
    newActiveNodeId = result.nextNode;
    affectedNodes = result.rootNodes;
  } else if (action.type === "document/cut-node") {
    affectedNodeContent = state2.document.content[action.payload.nodeId];
    newActiveNodeId = deleteNode2(
      state2.document,
      action.payload.nodeId,
      action.payload.selectedNodes
    );
    affectedNodeId = action.payload.nodeId;
  } else if (action.type === "document/file/update-frontmatter") {
    state2.file.frontmatter = action.payload.frontmatter;
    return;
  } else if (action.type === "document/pinned-nodes/pin") {
    pinNode(state2.sections, state2.pinnedNodes, action.payload.id);
    return;
  } else if (action.type === "document/pinned-nodes/unpin") {
    unpinNode(state2.pinnedNodes, action.payload.id);
    return;
  } else if (action.type === "document/pinned-nodes/remove-stale-nodes") {
    removeStalePinnedNodes(state2.pinnedNodes, state2.sections);
    return;
  } else if (action.type === "document/pinned-nodes/load-from-settings") {
    loadPinnedNodes(
      state2.pinnedNodes,
      state2.sections,
      action.payload.sections
    );
    return;
  } else if (action.type === "document/meta/refresh-group-parent-ids") {
    refreshGroupParentIds(state2.document.columns, state2.meta);
    return;
  }
  const e = getDocumentEventType(action.type);
  let affectedSection = null;
  if (affectedNodeId) {
    affectedSection = getSectionOfId(state2.sections, affectedNodeId);
  }
  if (e.dropOrMove || e.createOrDelete || e.changeHistory || e.clipboard) {
    updateSectionsDictionary(state2);
  }
  if (action.type === "document/file/load-from-disk") {
    const activeSection = action.payload.activeSection;
    if (activeSection) {
      const id2 = state2.sections.section_id[activeSection];
      if (id2) {
        newActiveNodeId = id2;
      }
    }
  }
  const contentShapeCreation = e.content || e.dropOrMove || e.createOrDelete;
  if (newActiveNodeId && (contentShapeCreation || e.clipboard)) {
    const newActiveSection = getSectionOfId(
      state2.sections,
      newActiveNodeId
    );
    affectedNodeId = affectedNodeId || newActiveNodeId;
    affectedNodeContent = affectedNodeContent || state2.document.content[affectedNodeId];
    const context = {
      numberOfSections: Object.keys(state2.document.content).length,
      affectedSection: affectedSection || newActiveSection,
      newActiveSection,
      action,
      contentOfAffectedSection: affectedNodeContent?.content?.substring(0, 300) || "",
      numberOfCharacters: Object.values(state2.document.content).map((x) => x.content.length).reduce((acc, v) => acc + v),
      affectedSections: affectedNodes ? affectedNodes.map((id2) => state2.sections.id_section[id2]) : void 0
    };
    addSnapshot(state2.document, state2.history, context);
    state2.history = { ...state2.history };
  }
};
var documentReducer = (store, action) => {
  const result = updateDocumentState2(store, action);
  if (result === NO_UPDATE)
    return NO_UPDATE;
  return store;
};

// src/stores/document/default-document-state.ts
var defaultDocumentState = () => ({
  document: {
    columns: [],
    content: {}
  },
  sections: {
    id_section: {},
    section_id: {}
  },
  file: {
    frontmatter: ""
  },
  history: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: {
      activeSection: ""
    }
  },
  pinnedNodes: {
    Ids: []
  },
  meta: {
    groupParentIds: /* @__PURE__ */ new Set()
  }
});

// src/stores/view/default-view-state.ts
var defaultViewState = () => ({
  search: {
    query: "",
    results: /* @__PURE__ */ new Map(),
    searching: false,
    showInput: false,
    fuzzySearch: false,
    showAllNodes: true
  },
  ui: {
    controls: {
      showHistorySidebar: false,
      showHelpSidebar: false,
      showSettingsSidebar: false,
      showStyleRulesModal: false
    }
  },
  document: {
    editing: {
      activeNodeId: "",
      isInSidebar: false
    },
    activeBranch: {
      group: "",
      childGroups: /* @__PURE__ */ new Set(),
      sortedParentNodes: [],
      column: "",
      node: ""
    },
    dnd: {
      node: "",
      childGroups: /* @__PURE__ */ new Set()
    },
    activeNode: "",
    activeNodesOfColumn: {},
    selectedNodes: /* @__PURE__ */ new Set(),
    pendingConfirmation: {
      disableEdit: null,
      deleteNode: /* @__PURE__ */ new Set()
    }
  },
  navigationHistory: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: void 0
  },
  pinnedNodes: {
    activeNode: ""
  },
  recentNodes: {
    activeNode: ""
  },
  styleRules: {
    nodeStyles: /* @__PURE__ */ new Map(),
    allMatches: /* @__PURE__ */ new Map()
  },
  keyboard: {
    shift: false
  },
  hotkeys: {
    searchTerm: "",
    conflictingHotkeys: /* @__PURE__ */ new Map()
  },
  outline: {
    collapsedParents: /* @__PURE__ */ new Set(),
    hiddenNodes: /* @__PURE__ */ new Set()
  }
});

// src/stores/view/reducers/search/set-search-query.ts
var setSearchQuery = (state2, query) => {
  state2.search.query = query;
  if (!query)
    state2.search.results = /* @__PURE__ */ new Map();
  state2.search.searching = query.length > 0;
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/search/set-search-results.ts
var setSearchResults = (state2, results) => {
  state2.search.results = new Map(results);
  state2.search.searching = false;
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/search/toggle-search-input.ts
var toggleSearchInput = (state2) => {
  state2.search.showInput = !state2.search.showInput;
  if (!state2.search.showInput) {
    setSearchQuery(state2, "");
  }
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/document/reset-pending-confirmation.ts
var resetPendingConfirmation = (state2) => {
  state2.pendingConfirmation = {
    disableEdit: null,
    deleteNode: /* @__PURE__ */ new Set()
  };
};

// src/stores/view/reducers/document/enable-edit-mode.ts
var enableEditMode = (state2, nodeId, isInSidebar = false) => {
  if (state2.editing.activeNodeId) {
    if (state2.editing.activeNodeId === nodeId) {
      throw new Error(
        `This section is being edited in the ${state2.editing.isInSidebar ? "sidebar" : "main view"}`
      );
    }
  }
  state2.editing = {
    activeNodeId: nodeId,
    isInSidebar
  };
  resetPendingConfirmation(state2);
};

// src/stores/view/reducers/document/disable-edit-mode.ts
var disableEditMode = (state2) => {
  state2.editing = {
    activeNodeId: "",
    isInSidebar: false
  };
  resetPendingConfirmation(state2);
};

// src/stores/view/reducers/document/on-drag-start.ts
var onDragStart = (state2, action) => {
  const node = action.payload.nodeId;
  if (node) {
    state2.dnd = {
      node: action.payload.nodeId,
      childGroups: new Set(action.payload.childGroups)
    };
  }
};

// src/stores/view/reducers/document/on-drag-end.ts
var onDragEnd = (state2) => {
  state2.dnd = {
    node: "",
    childGroups: /* @__PURE__ */ new Set()
  };
};

// src/lib/tree-utils/get/traverse-up.ts
var traverseUp = (columns, nodeId) => {
  const parentIds = [];
  const columnAndParent = findNodeColumnAndParent(columns, nodeId);
  if (!columnAndParent)
    return parentIds;
  let currentParentId = columnAndParent[1];
  const nodeColumnIndex = columnAndParent[0];
  for (let i = nodeColumnIndex - 1; i >= 0; i--) {
    if (!currentParentId)
      break;
    parentIds.push(currentParentId);
    let nextParentId;
    for (const group of columns[i].groups) {
      for (const node of group.nodes) {
        if (node === currentParentId) {
          nextParentId = group.parentId;
          break;
        }
      }
      if (nextParentId)
        break;
    }
    currentParentId = nextParentId;
  }
  return parentIds;
};

// src/stores/view/reducers/document/helpers/remove-stale-active-nodes.ts
var removeStaleActiveNodes = (columns, activeNodes) => {
  const result = {};
  const columnMap = /* @__PURE__ */ new Map();
  const groupMap = /* @__PURE__ */ new Map();
  const nodeMap = /* @__PURE__ */ new Map();
  for (const column of columns) {
    const groupSet = /* @__PURE__ */ new Set();
    columnMap.set(column.id, column);
    for (const group of column.groups) {
      groupSet.add(group.parentId);
      nodeMap.set(group.parentId, new Set(group.nodes));
    }
    groupMap.set(column.id, groupSet);
  }
  for (const [columnId, groupEntries] of Object.entries(activeNodes)) {
    if (!columnMap.has(columnId))
      continue;
    const validGroups = groupMap.get(columnId);
    const cleanedGroups = {};
    for (const [groupId, nodeId] of Object.entries(groupEntries)) {
      if (!validGroups.has(groupId))
        continue;
      const validNodes = nodeMap.get(groupId);
      if (!validNodes?.has(nodeId))
        continue;
      cleanedGroups[groupId] = nodeId;
    }
    if (Object.keys(cleanedGroups).length > 0) {
      result[columnId] = cleanedGroups;
    }
  }
  return result;
};

// src/stores/view/reducers/document/helpers/compare-active-branch.ts
var compareActiveBranch = (a, b) => {
  if (a === b)
    return true;
  if (a.group !== b.group || a.column !== b.column || a.node !== b.node) {
    return false;
  }
  if (a.sortedParentNodes.length !== b.sortedParentNodes.length) {
    return false;
  }
  if (a.childGroups.size !== b.childGroups.size) {
    return false;
  }
  for (let i = 0; i < a.sortedParentNodes.length; i++) {
    if (a.sortedParentNodes[i] !== b.sortedParentNodes[i]) {
      return false;
    }
  }
  for (const item of a.childGroups) {
    if (!b.childGroups.has(item)) {
      return false;
    }
  }
  return true;
};

// src/stores/view/reducers/document/helpers/update-active-branch.ts
var updateActiveBranch = (state2, columns, isDocumentAction) => {
  if (!state2.activeNode)
    return;
  const sortedParents = traverseUp(columns, state2.activeNode).reverse();
  const childGroups = traverseDown(columns, state2.activeNode, true);
  const group = findGroupByNodeId(columns, state2.activeNode);
  if (!group)
    throw new Error("could not find group for node " + state2.activeNode);
  const columnId = columns[findNodeColumn(columns, state2.activeNode)].id;
  const newActiveBranch = {
    childGroups: new Set(childGroups),
    sortedParentNodes: sortedParents,
    group: group.parentId,
    column: columnId,
    node: state2.activeNode
  };
  const same = compareActiveBranch(state2.activeBranch, newActiveBranch);
  if (!same) {
    state2.activeBranch = newActiveBranch;
  }
  if (!state2.activeNodesOfColumn[columnId])
    state2.activeNodesOfColumn[columnId] = {};
  state2.activeNodesOfColumn[columnId][group.parentId] = state2.activeNode;
  if (isDocumentAction) {
    state2.activeNodesOfColumn = removeStaleActiveNodes(
      columns,
      state2.activeNodesOfColumn
    );
  }
};

// src/stores/view/reducers/ui/helpers/add-navigation-history-item.ts
var addNavigationHistoryItem = (state2, nodeId) => {
  if (!nodeId)
    return;
  removeObsoleteHistoryItems(state2.navigationHistory);
  removeOldHistoryItems(state2.navigationHistory, 100);
  const activeItem = state2.navigationHistory.items[state2.navigationHistory.items.length - 1];
  if (activeItem !== nodeId) {
    state2.navigationHistory.items.push(nodeId);
  }
  state2.navigationHistory.state.activeIndex = state2.navigationHistory.items.length - 1;
  updateNavigationState(state2.navigationHistory);
  state2.navigationHistory = {
    ...state2.navigationHistory
  };
};

// src/stores/view/reducers/document/helpers/update-active-node.ts
var updateActiveNode = (documentState, nodeId, state2) => {
  documentState.activeNode = nodeId;
  if (state2)
    addNavigationHistoryItem(state2, documentState.activeNode);
  const activeNodeId = documentState.editing.activeNodeId;
  if (activeNodeId !== nodeId || documentState.editing.isInSidebar)
    disableEditMode(documentState);
  resetPendingConfirmation(documentState);
};

// src/lib/tree-utils/find/find-next-active-node-on-keyboard-navigation.ts
var filterHiddenGroups = (columns, collapsedParents) => {
  return columns.map((c) => {
    return {
      groups: c.groups.filter((g) => {
        return !collapsedParents.has(g.parentId);
      }),
      id: c.id
    };
  });
};
var findNextActiveNodeOnKeyboardNavigation = (columns, node, direction, activeNodeOfGroup, collapsedParents, isSelecting = false) => {
  if (!node)
    return;
  let nextNode = null;
  if (collapsedParents) {
    columns = filterHiddenGroups(columns, collapsedParents);
  }
  if (direction === "left") {
    const group = findGroupByNodeId(columns, node);
    if (group && !group.parentId.startsWith("r"))
      nextNode = group.parentId;
  } else if (direction === "right") {
    const group = findChildGroup(columns, node);
    if (group) {
      const columnIndex = findNodeColumn(columns, node);
      const nextColumn = columns[columnIndex + 1];
      if (!nextColumn)
        return;
      const activeNode = activeNodeOfGroup[nextColumn.id]?.[group.parentId];
      if (activeNode)
        nextNode = activeNode;
      else
        nextNode = group.nodes[0];
    }
  } else {
    const columnIndex = findNodeColumn(columns, node);
    const column = columns[columnIndex];
    if (!column)
      return;
    const outlineMode = Boolean(collapsedParents);
    const groupOfActiveNode = findGroupByNodeId(columns, node);
    const allNodes = outlineMode ? groupOfActiveNode.nodes : column.groups.map((g) => g.nodes).flat();
    const nodeIndex = allNodes.findIndex((n) => n === node);
    const parentId = columnIndex > 0 ? groupOfActiveNode.parentId : null;
    if (outlineMode) {
      if (direction === "up") {
        if (nodeIndex > 0) {
          nextNode = allNodes[nodeIndex - 1];
        } else if (nodeIndex === 0 && !isSelecting) {
          return parentId;
        }
      } else if (direction === "down") {
        if (nodeIndex < allNodes.length - 1) {
          nextNode = allNodes[nodeIndex + 1];
        } else if (nodeIndex === allNodes.length - 1 && parentId && !isSelecting) {
          const groupOfParentNode = findGroupByNodeId(
            columns,
            parentId
          );
          if (groupOfParentNode) {
            const parentIndex = groupOfParentNode.nodes.findIndex(
              (n) => n === parentId
            );
            nextNode = groupOfParentNode.nodes[parentIndex + 1];
          }
        }
      }
    } else {
      if (direction === "up") {
        if (nodeIndex > 0) {
          nextNode = allNodes[nodeIndex - 1];
        }
      } else if (direction === "down") {
        if (nodeIndex < allNodes.length - 1) {
          nextNode = allNodes[nodeIndex + 1];
        }
      }
    }
  }
  return nextNode;
};

// src/stores/view/reducers/document/helpers/update-selected-nodes.ts
var updateSelectedNodes = (column, selectedNodes, previousActiveNode, newActiveNode) => {
  const allNodeIds = column.groups.flatMap((group) => group.nodes);
  const previousActiveNodeIndex = allNodeIds.indexOf(previousActiveNode);
  if (previousActiveNodeIndex === -1)
    return;
  const currentSelectionIsEmpty = selectedNodes.size === 0;
  const lowestSelectedNodeIndex = currentSelectionIsEmpty ? previousActiveNodeIndex : allNodeIds.findIndex((nodeId) => selectedNodes.has(nodeId));
  const highestSelectedNodeIndex = currentSelectionIsEmpty ? previousActiveNodeIndex : allNodeIds.findLastIndex((nodeId) => selectedNodes.has(nodeId));
  const newActiveNodeIndex = allNodeIds.indexOf(newActiveNode);
  if (newActiveNodeIndex === -1)
    return;
  let mode = null;
  if (newActiveNodeIndex - previousActiveNodeIndex > 1) {
    mode = "jump_down" /* jump_down */;
  } else if (previousActiveNodeIndex - newActiveNodeIndex > 1) {
    mode = "jump_up" /* jump_up */;
  } else if (previousActiveNodeIndex === lowestSelectedNodeIndex)
    mode = "step_from_top" /* step_from_top */;
  else if (previousActiveNodeIndex === highestSelectedNodeIndex)
    mode = "step_from_bottom" /* step_from_bottom */;
  const goingUp = previousActiveNodeIndex > newActiveNodeIndex;
  selectedNodes.clear();
  if (!mode)
    return;
  let startIndex = 0, endIndex = 0;
  if (currentSelectionIsEmpty) {
    if (goingUp) {
      startIndex = newActiveNodeIndex;
      endIndex = previousActiveNodeIndex;
    } else {
      startIndex = previousActiveNodeIndex;
      endIndex = newActiveNodeIndex;
    }
  } else if (mode === "jump_down" /* jump_down */) {
    startIndex = previousActiveNodeIndex;
    endIndex = newActiveNodeIndex;
  } else if (mode === "jump_up" /* jump_up */) {
    startIndex = newActiveNodeIndex;
    endIndex = previousActiveNodeIndex;
  } else if (mode === "step_from_top" /* step_from_top */) {
    startIndex = newActiveNodeIndex;
    endIndex = highestSelectedNodeIndex;
  } else if (mode === "step_from_bottom" /* step_from_bottom */) {
    startIndex = lowestSelectedNodeIndex;
    endIndex = newActiveNodeIndex;
  }
  if (startIndex === endIndex)
    return;
  for (let i = startIndex; i <= endIndex; i++) {
    selectedNodes.add(allNodeIds[i]);
  }
};

// src/stores/view/reducers/document/helpers/reset-selection-state.ts
var resetSelectionState = (documentState) => {
  documentState.selectedNodes = /* @__PURE__ */ new Set();
};

// src/stores/view/reducers/document/helpers/update-selection-state.ts
var updateSelectionState = (columns, documentState, nextNode, isVertical, shiftKey) => {
  if (shiftKey && isVertical) {
    const columnIndex = findNodeColumn(columns, nextNode);
    const column = columns[columnIndex];
    invariant(column);
    updateSelectedNodes(
      column,
      documentState.selectedNodes,
      documentState.activeNode,
      nextNode
    );
    documentState.selectedNodes = new Set(documentState.selectedNodes);
  } else {
    resetSelectionState(documentState);
  }
};

// src/stores/view/reducers/document/navigate-using-keyboard.ts
var navigateUsingKeyboard = (documentState, state2, action, columns) => {
  const nextNode = findNextActiveNodeOnKeyboardNavigation(
    columns,
    documentState.activeNode,
    action.payload.direction,
    documentState.activeNodesOfColumn,
    action.context.outlineMode ? state2.outline.collapsedParents : null,
    action.context.shiftKey
  );
  if (nextNode) {
    updateSelectionState(
      columns,
      documentState,
      nextNode,
      action.payload.direction === "up" || action.payload.direction === "down",
      Boolean(action.context.shiftKey)
    );
    updateActiveNode(documentState, nextNode, state2);
  }
};

// src/stores/view/reducers/ui/navigate-active-node-history.ts
var navigateActiveNodeHistory = (documentState, state2, forward = false) => {
  const activeIndex = state2.navigationHistory.state.activeIndex;
  const newIndex = forward ? activeIndex + 1 : activeIndex - 1;
  const newItem = state2.navigationHistory.items[newIndex];
  if (newItem) {
    state2.navigationHistory.state.activeIndex = newIndex;
    updateNavigationState(state2.navigationHistory);
    state2.navigationHistory = { ...state2.navigationHistory };
    updateActiveNode(documentState, newItem, null);
    state2.recentNodes.activeNode = newItem;
    resetSelectionState(documentState);
  }
};

// src/lib/tree-utils/find/find-node-to-jump-to.ts
var findNodeToJumpTo = (columns, node, target) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (target === "start-of-column") {
    return column.groups[0].nodes[0];
  } else if (target === "end-of-column") {
    const nodeGroup = column.groups[column.groups.length - 1];
    return nodeGroup.nodes[nodeGroup.nodes.length - 1];
  } else {
    const group = column.groups.find((g) => g.nodes.includes(node));
    if (group) {
      if (target === "start-of-group")
        return group.nodes[0];
      else if (target === "end-of-group") {
        return group.nodes[group.nodes.length - 1];
      }
    }
  }
};

// src/stores/view/reducers/document/jump-to-node.ts
var jumpToNode = (documentViewState, state2, action, columns) => {
  const nextNode = findNodeToJumpTo(
    columns,
    documentViewState.activeNode,
    action.payload.target
  );
  if (nextNode) {
    updateSelectionState(
      columns,
      documentViewState,
      nextNode,
      true,
      Boolean(action.context?.shiftKey)
    );
    updateActiveNode(documentViewState, nextNode, state2);
  }
};

// src/stores/view/reducers/ui/helpers/remove-deleted-navigation-items.ts
var removeDeletedNavigationItems = (state2, content) => {
  const items = [];
  let previous = null;
  for (const item of state2.navigationHistory.items) {
    if (content.hasOwnProperty(item) && item !== previous) {
      items.push(item);
      previous = item;
    }
  }
  state2.navigationHistory.items = items;
  state2.navigationHistory.state.activeIndex = state2.navigationHistory.items.length - 1;
  updateNavigationState(state2.navigationHistory);
  state2.navigationHistory = {
    ...state2.navigationHistory
  };
};

// src/stores/view/reducers/search/toggle-fuzzy-search.ts
var toggleFuzzySearch = (state2) => {
  state2.search.fuzzySearch = !state2.search.fuzzySearch;
  state2.search = { ...state2.search };
};

// src/lib/tree-utils/find/find-next-node.ts
var findNextNode = (sections, node, direction, hiddenNodes) => {
  let sortedSections = sortSections(Object.keys(sections.section_id));
  if (hiddenNodes) {
    sortedSections = sortedSections.filter(
      (section) => !hiddenNodes.has(sections.section_id[section])
    );
  }
  const currentSection = sections.id_section[node];
  const currentSectionIndex = sortedSections.findIndex(
    (section) => currentSection === section
  );
  if (currentSectionIndex === -1)
    return node;
  const nextSectionIndex = currentSectionIndex + (direction === "back" ? -1 : 1);
  const nextSection = sortedSections[nextSectionIndex];
  return sections.section_id[nextSection] || node;
};

// src/stores/view/reducers/ui/navigate-active-node.ts
var navigateActiveNode = (documentState, state2, action) => {
  const nextNode = findNextNode(
    action.payload.sections,
    documentState.activeNode,
    action.payload.direction,
    action.context.outlineMode ? state2.outline.hiddenNodes : null
  );
  if (nextNode && nextNode !== documentState.activeNode) {
    updateActiveNode(documentState, nextNode, state2);
    resetSelectionState(documentState);
  }
};

// src/stores/view/reducers/pinned-cards/set-active-pinned-node.ts
var setActivePinnedNode = (documentState, state2, id2) => {
  state2.activeNode = id2;
  const activePinnedNodeIsBeingEdited = documentState.editing.activeNodeId === id2;
  const editedNodeIsInSidebar = documentState.editing.isInSidebar;
  if (!(activePinnedNodeIsBeingEdited && editedNodeIsInSidebar)) {
    disableEditMode(documentState);
  }
};

// src/stores/view/reducers/recent-nodes/set-active-recent-node.ts
var setActiveRecentNode = (documentState, state2, id2) => {
  state2.activeNode = id2;
  const activeNodeIsBeingEdited = documentState.editing.activeNodeId === id2;
  const editedNodeIsInSidebar = documentState.editing.isInSidebar;
  if (!(activeNodeIsBeingEdited && editedNodeIsInSidebar)) {
    disableEditMode(documentState);
  }
};

// src/stores/view/reducers/search/toggle-show-all-nodes.ts
var toggleShowAllNodes = (state2) => {
  state2.search.showAllNodes = !state2.search.showAllNodes;
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/outline/helpers/collapse-node.ts
var collapseNode = (state2, columns, id2) => {
  const children2 = getAllChildren(columns, id2);
  state2.outline.collapsedParents.add(id2);
  for (const child of children2) {
    state2.outline.hiddenNodes.add(child);
  }
};

// src/stores/view/reducers/outline/helpers/expand-node.ts
var expandNode = (state2, columns, id2) => {
  state2.outline.collapsedParents.delete(id2);
  const children2 = getAllChildren(columns, id2);
  if (children2.length > 0) {
    for (const child of children2) {
      state2.outline.hiddenNodes.delete(child);
    }
    const childrenSet = new Set(children2);
    const collapsedParents = Array.from(
      state2.outline.collapsedParents
    ).filter((id3) => childrenSet.has(id3));
    for (const collapsedParent of collapsedParents) {
      const children3 = getAllChildren(columns, collapsedParent);
      for (const child of children3) {
        state2.outline.hiddenNodes.add(child);
      }
    }
  }
};

// src/stores/view/reducers/outline/toggle-collapse-node.ts
var toggleCollapseNode = (state2, columns, id2) => {
  const isCollapsed = state2.outline.collapsedParents.has(id2);
  if (isCollapsed) {
    expandNode(state2, columns, id2);
  } else {
    collapseNode(state2, columns, id2);
  }
  state2.outline = { ...state2.outline };
};

// src/stores/view/reducers/outline/expand-parents-of-active-node.ts
var expandParentsOfActiveNode = (state2, columns) => {
  const parents = state2.document.activeBranch.sortedParentNodes;
  let update2 = false;
  for (const parent of parents) {
    if (state2.outline.collapsedParents.has(parent)) {
      expandNode(state2, columns, parent);
      update2 = true;
    }
  }
  if (update2) {
    state2.outline = { ...state2.outline };
  }
};

// src/stores/view/reducers/outline/refresh-collapsed-nodes.ts
var refreshCollapsedNodes = (state2, columns) => {
  const collapsedParents = Array.from(state2.outline.collapsedParents);
  state2.outline.collapsedParents.clear();
  state2.outline.hiddenNodes.clear();
  for (const id2 of collapsedParents) {
    expandNode(state2, columns, id2);
    collapseNode(state2, columns, id2);
  }
  expandParentsOfActiveNode(state2, columns);
  state2.outline = { ...state2.outline };
};

// src/stores/view/reducers/outline/toggle-collapse-all-nodes.ts
var toggleCollapseAllNodes = (state2, columns) => {
  const column = columns[0];
  if (!column)
    return;
  const rootNode = column.groups[0].parentId;
  const parents = traverseDown(columns, rootNode, true).filter(
    (id2) => id2 !== rootNode
  );
  const hasCollapsedNodes = state2.outline.hiddenNodes.size > 0;
  state2.outline.collapsedParents.clear();
  state2.outline.hiddenNodes.clear();
  if (hasCollapsedNodes) {
    for (const id2 of parents) {
      expandNode(state2, columns, id2);
    }
  } else {
    for (const id2 of parents) {
      collapseNode(state2, columns, id2);
    }
  }
  state2.outline = { ...state2.outline };
};

// src/stores/view/reducers/selection/select-all-nodes.ts
var compareSetToArray = (set, array) => {
  return set.size === array.length && array.every((node) => set.has(node));
};
var selectAllNodes = (state2, columns) => {
  const firstColumnNodes = columns[0].groups[0].nodes;
  const rootColumnIsSelected = compareSetToArray(
    state2.selectedNodes,
    firstColumnNodes
  );
  if (rootColumnIsSelected) {
    return;
  }
  const column = columns[findNodeColumn(columns, state2.activeNode)];
  invariant(column);
  const nodeColumnNodes = column.groups.flatMap((g) => g.nodes);
  const columnIsSelected = compareSetToArray(
    state2.selectedNodes,
    nodeColumnNodes
  );
  if (columnIsSelected) {
    state2.selectedNodes = new Set(firstColumnNodes);
    state2.activeNode = state2.activeBranch.sortedParentNodes[0];
    return;
  }
  const nodeGroup = findGroupByNodeId(columns, state2.activeNode);
  invariant(nodeGroup);
  const groupIsSelected = compareSetToArray(
    state2.selectedNodes,
    nodeGroup.nodes
  );
  if (groupIsSelected) {
    state2.selectedNodes = new Set(nodeColumnNodes);
    return;
  }
  state2.selectedNodes = new Set(nodeGroup.nodes);
};

// src/stores/view/view-reducer.ts
var updateDocumentState3 = (state2, action, context) => {
  const activeNode = state2.document.activeNode;
  if (action.type === "view/set-active-node/mouse" || action.type === "view/set-active-node/mouse-silent" || action.type === "view/set-active-node/document" || action.type === "view/set-active-node/search") {
    updateActiveNode(state2.document, action.payload.id, state2);
    if (!state2.document.selectedNodes.has(state2.document.activeNode))
      resetSelectionState(state2.document);
  } else if (action.type === "view/set-active-node/keyboard") {
    navigateUsingKeyboard(state2.document, state2, action, context.columns);
  } else if (action.type === "view/search/set-query") {
    setSearchQuery(state2, action.payload.query);
  } else if (action.type === "view/search/set-results") {
    setSearchResults(state2, action.payload.results);
  } else if (action.type === "view/search/toggle-input") {
    toggleSearchInput(state2);
  } else if (action.type === "view/snapshots/toggle-modal") {
    const showHistorySidebar = state2.ui.controls.showHistorySidebar;
    state2.ui.controls = {
      showHistorySidebar: !showHistorySidebar,
      showHelpSidebar: false,
      showSettingsSidebar: false,
      showStyleRulesModal: false
    };
  } else if (action.type === "view/hotkeys/toggle-modal") {
    const showHelpSidebar = state2.ui.controls.showHelpSidebar;
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: !showHelpSidebar,
      showSettingsSidebar: false,
      showStyleRulesModal: false
    };
  } else if (action.type === "view/settings/toggle-modal") {
    const showSettingsSidebar = state2.ui.controls.showSettingsSidebar;
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: false,
      showSettingsSidebar: !showSettingsSidebar,
      showStyleRulesModal: false
    };
  } else if (action.type === "view/close-modals") {
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: action.payload?.closeAllModals ? false : state2.ui.controls.showHelpSidebar,
      showSettingsSidebar: false,
      showStyleRulesModal: false
    };
  } else if (action.type === "view/editor/enable-main-editor") {
    if (state2.document.activeNode !== action.payload.nodeId) {
      updateActiveNode(state2.document, action.payload.nodeId, state2);
    }
    enableEditMode(state2.document, action.payload.nodeId);
  } else if (action.type === "view/editor/enable-sidebar-editor") {
    if (action.context.activeSidebarTab === "pinned-cards") {
      if (state2.pinnedNodes.activeNode !== action.payload.id) {
        setActivePinnedNode(
          state2.document,
          state2.pinnedNodes,
          action.payload.id
        );
      }
    } else if (action.context.activeSidebarTab === "recent-cards") {
      if (state2.recentNodes.activeNode !== action.payload.id) {
        setActiveRecentNode(
          state2.document,
          state2.recentNodes,
          action.payload.id
        );
      }
    }
    enableEditMode(state2.document, action.payload.id, true);
  } else if (action.type === "view/editor/disable/reset-confirmation") {
    resetPendingConfirmation(state2.document);
  } else if (action.type === "view/delete-node/reset-confirmation") {
    resetPendingConfirmation(state2.document);
  } else if (action.type === "view/delete-node/confirm") {
    state2.document.pendingConfirmation = {
      ...state2.document.pendingConfirmation,
      deleteNode: action.payload.includeSelection && state2.document.selectedNodes.size > 1 ? new Set(state2.document.selectedNodes) : /* @__PURE__ */ new Set([action.payload.id])
    };
  } else if (action.type === "view/editor/disable/confirm") {
    state2.document.pendingConfirmation = {
      ...state2.document.pendingConfirmation,
      disableEdit: action.payload.id
    };
  } else if (action.type === "view/editor/disable-main-editor" || action.type === "view/editor/disable-sidebar-editor") {
    disableEditMode(state2.document);
  } else if (action.type === "view/dnd/set-drag-started") {
    onDragStart(state2.document, action);
  } else if (action.type === "view/dnd/set-drag-ended") {
    onDragEnd(state2.document);
  } else if (action.type === "view/update-active-branch?source=document") {
    updateActiveBranch(state2.document, context.columns, true);
  } else if (action.type === "view/set-active-node/history/select-next") {
    navigateActiveNodeHistory(state2.document, state2, true);
  } else if (action.type === "view/set-active-node/history/select-previous") {
    navigateActiveNodeHistory(state2.document, state2);
  } else if (action.type === "view/set-active-node/keyboard-jump") {
    jumpToNode(state2.document, state2, action, context.columns);
  } else if (action.type === "view/active-node-history/delete-obsolete") {
    removeDeletedNavigationItems(state2, action.payload.content);
  } else if (action.type === "view/search/toggle-fuzzy-mode") {
    toggleFuzzySearch(state2);
  } else if (action.type === "view/selection/clear-selection") {
    resetSelectionState(state2.document);
  } else if (action.type === "view/selection/select-all") {
    selectAllNodes(state2.document, context.columns);
  } else if (action.type === "view/set-active-node/sequential/select-next") {
    navigateActiveNode(state2.document, state2, action);
  } else if (action.type === "view/pinned-nodes/set-active-node") {
    setActivePinnedNode(
      state2.document,
      state2.pinnedNodes,
      action.payload.id
    );
  } else if (action.type === "view/recent-nodes/set-active-node") {
    setActiveRecentNode(
      state2.document,
      state2.recentNodes,
      action.payload.id
    );
  } else if (action.type === "search/view/toggle-show-all-nodes") {
    toggleShowAllNodes(state2);
  } else if (action.type === "view/style-rules/toggle-modal") {
    const showStyleRulesModal = state2.ui.controls.showStyleRulesModal;
    state2.ui.controls = {
      showHistorySidebar: false,
      showStyleRulesModal: !showStyleRulesModal,
      showSettingsSidebar: false,
      showHelpSidebar: false
    };
  } else if (action.type === "view/style-rules/update-results") {
    if (!action.payload.results) {
      state2.styleRules.nodeStyles = /* @__PURE__ */ new Map();
      state2.styleRules.allMatches = /* @__PURE__ */ new Map();
    } else {
      state2.styleRules.nodeStyles = action.payload.results.nodeStyles;
      state2.styleRules.allMatches = action.payload.results.allMatches;
    }
  } else if (action.type === "view/keyboard/shift/up") {
    state2.keyboard.shift = false;
    state2.keyboard = { ...state2.keyboard };
  } else if (action.type === "view/keyboard/shift/down") {
    state2.keyboard.shift = true;
    state2.keyboard = { ...state2.keyboard };
  } else if (action.type === "view/hotkeys/set-search-term") {
    state2.hotkeys.searchTerm = action.payload.searchTerm.toLowerCase();
  } else if (action.type === "view/hotkeys/update-conflicts") {
    state2.hotkeys.conflictingHotkeys = action.payload.conflicts;
  } else if (action.type === "view/outline/toggle-collapse-node") {
    toggleCollapseNode(state2, context.columns, action.payload.id);
  } else if (action.type === "view/outline/refresh-collapsed-nodes") {
    refreshCollapsedNodes(state2, context.columns);
  } else if (action.type === "view/outline/toggle-collapse-all") {
    toggleCollapseAllNodes(state2, context.columns);
  } else if (action.type === "view/selection/set-selection") {
    state2.document.selectedNodes = new Set(action.payload.ids);
  } else if (action.type === "view/outline/load-persisted-collapsed-parents") {
    for (const id2 of action.payload.collapsedIds) {
      collapseNode(state2, context.columns, id2);
    }
    expandParentsOfActiveNode(state2, context.columns);
    state2.outline = { ...state2.outline };
  }
  if (activeNode !== state2.document.activeNode) {
    updateActiveBranch(state2.document, context.columns, false);
    expandParentsOfActiveNode(state2, context.columns);
  }
};
var viewReducer = (store, action, context) => {
  updateDocumentState3(store, action, context);
  return store;
};

// src/stores/view/subscriptions/helpers/is-empty-document.ts
var isEmptyDocument = (content) => {
  const values = Object.values(content);
  return values.length === 1 && values[0].content === "";
};

// src/stores/view/subscriptions/actions/enable-edit-mode.ts
var enableEditMode2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "view/editor/enable-main-editor",
    payload: {
      nodeId: getIdOfSection(
        documentState.sections,
        documentState.history.context.activeSection
      )
    }
  });
};

// src/stores/view/subscriptions/effects/css-variables/apply-font-size.ts
var applyFontSize = (view, fontSize) => {
  if (fontSize)
    view.containerEl.style.setProperty("--font-text-size", `${fontSize}px`);
  else
    view.containerEl.style.removeProperty("--font-text-size");
};

// src/stores/view/subscriptions/effects/css-variables/helpers/css-variables.ts
var cssVariables = {
  colors: {
    activeBranchBg: "--background-active-parent",
    activeBranchColor: "--color-active-parent",
    containerBg: "--background-container"
  },
  cardWidth: "--node-width",
  cardIndentationWidth: "--node-indentation-width",
  nodeGap: "--node-gap-setting",
  minCardHeight: "--min-node-height",
  zoomLevel: "--zoom-level",
  viewWidth: "--view-width",
  viewHeight: "--view-height",
  inactiveCardOpacity: "--inactive-card-opacity"
};

// src/stores/view/subscriptions/effects/css-variables/apply-css-color.ts
var applyCssColor = (view, name) => {
  const target = view.contentEl;
  const settings = view.plugin.settings.getValue();
  const color = settings.view.theme[name];
  if (color) {
    target.style.setProperty(cssVariables.colors[name], color);
  } else {
    target.style.removeProperty(cssVariables.colors[name]);
  }
};

// src/stores/view/subscriptions/effects/css-variables/apply-card-width.ts
var BORDER_WIDTH = 5;
var applyCardWidth = (view, width) => {
  invariant(width);
  view.containerEl.style.setProperty(
    cssVariables.cardWidth,
    `${width - BORDER_WIDTH}px`
  );
};

// src/stores/view/subscriptions/effects/css-variables/apply-zoom-level.ts
var applyZoomLevel = (view, value) => {
  if (typeof value !== "number")
    return;
  view.containerEl.style.setProperty(cssVariables.zoomLevel, `${value}`);
};

// src/stores/view/subscriptions/helpers/maybe-get-id-of-section.ts
var maybeGetIdOfSection = (sections, section) => {
  return sections.section_id[section] || null;
};

// src/stores/view/subscriptions/actions/view/set-initial-active-node.ts
var setInitialActiveNode = (view) => {
  let id2 = null;
  const viewStore = view.viewStore;
  const documentState = view.documentStore.getValue();
  const settings = view.plugin.settings.getValue();
  const path = view.file.path;
  const persistedSection = settings.documents[path]?.activeSection;
  if (persistedSection) {
    id2 = maybeGetIdOfSection(documentState.sections, persistedSection);
  }
  const mostRecentActiveSection = documentState.history.context.activeSection;
  if (!id2 && mostRecentActiveSection) {
    id2 = maybeGetIdOfSection(
      documentState.sections,
      mostRecentActiveSection
    );
  }
  if (!id2)
    return;
  viewStore.setContext(documentState.document);
  viewStore.dispatch({
    type: "view/set-active-node/document",
    payload: {
      id: id2
    }
  });
};

// src/stores/view/subscriptions/effects/mark-unresolved-links/helpers/filter-non-existent-links.ts
var filterNonExistentLinks = (plugin, links, filePath) => {
  return links.map((link) => link.link.split("#")[0]).filter(
    (link) => !plugin.app.metadataCache.getFirstLinkpathDest(link, filePath)
  );
};

// src/stores/view/subscriptions/effects/mark-unresolved-links/helpers/get-non-existent-links.ts
var getNonExistentLinks = (plugin, file) => {
  const cache = plugin.app.metadataCache.getFileCache(file);
  if (!cache?.links) {
    return /* @__PURE__ */ new Set();
  }
  const nonExistentLinks = filterNonExistentLinks(
    plugin,
    cache.links,
    file.path
  );
  return new Set(nonExistentLinks);
};

// src/stores/view/subscriptions/effects/mark-unresolved-links/helpers/get-file-link-elements.ts
var getFileLinkElements = (view) => {
  return Array.from(
    view.contentEl.querySelectorAll(".internal-link")
  );
};

// src/stores/view/subscriptions/effects/mark-unresolved-links/mark-unresolved-links.ts
var markUnresolvedLinks = (view) => {
  const file = view.file;
  if (!file)
    return;
  const nonExistentLinks = getNonExistentLinks(view.plugin, file);
  const links = getFileLinkElements(view);
  for (const link of links) {
    const isUnresolved = link.dataset.href && nonExistentLinks.has(link.dataset.href.split("#")[0]);
    const hasUnresolvedClass = link.hasClass("is-unresolved" /* unresolved */);
    if (isUnresolved) {
      if (!hasUnresolvedClass) {
        link.addClass("is-unresolved" /* unresolved */);
      }
    } else if (hasUnresolvedClass) {
      link.removeClass("is-unresolved" /* unresolved */);
    }
  }
};

// src/stores/view/subscriptions/event-listeners/attach-hover-preview-listener.ts
var getLink = (el) => {
  return el.getAttr("data-href") || el.getAttr("href");
};
var attachHoverPreviewListener = (view) => {
  view.plugin.registerDomEvent(view.contentEl, "mouseover", (evt) => {
    if (!(isMacLike ? evt.metaKey : evt.ctrlKey))
      return;
    const targetEl = evt.target;
    if (targetEl.tagName !== "A")
      return;
    if (!targetEl.hasClass("internal-link"))
      return;
    const href = getLink(targetEl);
    if (!href)
      return;
    view.plugin.app.workspace.trigger("hover-link", {
      event: evt,
      source: "preview",
      hoverParent: view,
      targetEl,
      linktext: href,
      sourcePath: view.file.path
    });
  });
};

// src/stores/view/subscriptions/event-listeners/attach-wheel-scroll-listener.ts
var attachWheelScrollListener = (view) => {
  view.plugin.registerDomEvent(view.contentEl, "wheel", (evt) => {
    if (!evt.altKey)
      return;
    if (evt.deltaY === 0)
      return;
    const target = evt.target;
    const targetIsACard = target.hasClass("lng-prev") || target.closest(".lng-prev");
    if (!targetIsACard)
      return;
    const column = target.closest(".column");
    if (!column)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    requestAnimationFrame(() => {
      column.scrollBy({
        top: evt.deltaY * 2.5,
        behavior: "smooth"
      });
    });
  });
};

// src/stores/view/subscriptions/effects/css-variables/apply-cards-gap.ts
var applyCardsGap = (view, value) => {
  if (typeof value !== "number")
    return;
  view.containerEl.style.setProperty(cssVariables.nodeGap, `${value}px`);
};

// src/stores/view/subscriptions/actions/set-active-pinned-node.ts
var setActivePinnedNode2 = (view, id2) => {
  view.viewStore.dispatch({
    type: "view/pinned-nodes/set-active-node",
    payload: { id: id2 }
  });
};

// src/stores/view/subscriptions/actions/load-pinned-nodes-to-document.ts
var loadPinnedNodesToDocument = (view) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const settingsStore = view.plugin.settings;
  const settingsState = settingsStore.getValue();
  const persistedDocuments = settingsState.documents;
  const persistedDocument = persistedDocuments[view.file.path];
  if (!persistedDocument?.pinnedSections)
    return;
  if (persistedDocument.pinnedSections.sections.length === 0) {
    const activeLeftSideTab = settingsState.view.leftSidebarActiveTab;
    const showLeftSidebarStore = settingsState.view.showLeftSidebar;
    if (showLeftSidebarStore && activeLeftSideTab === "pinned-cards") {
      settingsStore.dispatch({ type: "view/left-sidebar/toggle" });
    }
    return;
  }
  if (documentState.pinnedNodes.Ids.length === 0) {
    documentStore.dispatch({
      type: "document/pinned-nodes/load-from-settings",
      payload: {
        sections: persistedDocument.pinnedSections.sections
      }
    });
  }
  const activeSection = persistedDocument.pinnedSections.activeSection;
  if (activeSection) {
    const id2 = documentState.sections.section_id[activeSection];
    if (id2) {
      setActivePinnedNode2(view, id2);
    }
  }
};

// src/stores/view/subscriptions/attach-close-modals-listener.ts
var attachCloseModalsListener = (view) => {
  const listener = (e) => {
    const target = e.target;
    const isInsideModal = target.closest(".lineage-modal");
    const isInsideControlsBar = !isInsideModal && target.closest(".controls-container");
    if (e.button === 0 && !(isInsideModal || isInsideControlsBar)) {
      view.viewStore.dispatch({ type: "view/close-modals" });
      view.contentEl.removeEventListener("click", listener);
    }
  };
  const controls = uiControlsStore(view);
  const unsub = controls.subscribe((controls2) => {
    if (
      /*controls.showHelpSidebar ||*/
      controls2.showHistorySidebar || controls2.showSettingsSidebar
    ) {
      setTimeout(() => {
        view.contentEl.addEventListener("click", listener);
      }, 0);
    }
  });
  return () => {
    view.contentEl.removeEventListener("click", listener);
    unsub();
  };
};

// src/stores/view/subscriptions/effects/css-variables/apply-card-indentation-width.ts
var applyCardIndentationWidth = (view, width) => {
  if (typeof width !== "number")
    return;
  view.containerEl.style.setProperty(
    cssVariables.cardIndentationWidth,
    `${width}px`
  );
};

// src/stores/view/subscriptions/effects/checkbox-listener/helpers/update-checkbox/find-task-line-index.ts
var findTaskLineIndex = (lines, taskIndex) => {
  let currentTaskIndex = -1;
  return lines.findIndex((line) => {
    if (line.match(/^\s*[-*+]\s*\[[ x]\]/i)) {
      currentTaskIndex++;
      return currentTaskIndex === taskIndex;
    }
    return false;
  });
};

// src/stores/view/subscriptions/effects/checkbox-listener/helpers/update-checkbox/update-task-line.ts
var updateTaskLine = (line, checked) => {
  return line.replace(
    /^([-*+]\s*\[)[ x](\].*)$/i,
    `$1${checked ? "x" : " "}$2`
  );
};

// src/stores/view/subscriptions/effects/checkbox-listener/helpers/update-checkbox/update-checkbox.ts
var updateCheckbox = (taskIndex, content, checked) => {
  const lines = content.split("\n");
  const taskLineIndex = findTaskLineIndex(lines, taskIndex);
  if (taskLineIndex === -1) {
    return;
  }
  const task = lines[taskLineIndex];
  lines[taskLineIndex] = updateTaskLine(task, checked);
  return {
    task: task.replace(/^\s*([-*+]\s*\[)[ x](\]) /i, ""),
    content: lines.join("\n")
  };
};

// src/stores/view/subscriptions/effects/checkbox-listener/attach-checkbox-listener.ts
var handleCheckboxChange = (event, view) => {
  const checkbox = event.target;
  if (!checkbox?.classList.contains("task-list-item-checkbox")) {
    return;
  }
  const listItem = checkbox.closest(".task-list-item");
  const card = checkbox.closest(".lineage-card");
  if (!listItem || !card) {
    return;
  }
  const documentState = view.documentStore.getValue();
  const cardId = card.id;
  const existingContent = documentState.document.content[cardId];
  if (!cardId || !existingContent) {
    return;
  }
  const allItems = Array.from(
    card.querySelectorAll(".lng-prev .task-list-item")
  );
  const taskIndex = allItems.indexOf(listItem);
  const content = updateCheckbox(
    taskIndex,
    existingContent.content,
    checkbox.checked
  );
  if (content) {
    view.documentStore.dispatch({
      type: "document/update-node-content",
      payload: { nodeId: cardId, content: content.content },
      context: { isInSidebar: !!card.closest(".sidebar") }
    });
  }
};
var attachCheckboxListener = (view) => {
  const container = view.contentEl;
  invariant(container);
  const listener = (event) => {
    handleCheckboxChange(event, view);
  };
  container.addEventListener("change", listener);
  return () => {
    container.removeEventListener("change", listener);
  };
};

// src/stores/view/subscriptions/effects/css-variables/apply-view-size.ts
var PADDING_H = 8 * 4 + 34 * 2;
var PADDING_V = 8 * 2;
var applyViewSize = (view) => {
  const viewElement = view.contentEl.querySelector(
    ".lineage-main"
  );
  if (!viewElement)
    return;
  const rect = viewElement.getBoundingClientRect();
  view.containerEl.style.setProperty(
    cssVariables.viewWidth,
    `${rect.width - PADDING_H}px`
  );
  view.containerEl.style.setProperty(
    cssVariables.viewHeight,
    `${rect.height - PADDING_V}px`
  );
};

// src/stores/view/subscriptions/effects/view-size/watch-view-size.ts
var watchViewSize = (view) => {
  const element2 = view.contentEl.querySelector(".lineage-main");
  invariant(element2);
  const observer = new ResizeObserver(() => {
    applyViewSize(view);
  });
  observer.observe(element2);
  return () => {
    observer.disconnect();
  };
};

// src/stores/view/subscriptions/effects/css-variables/apply-inactive-node-opacity.ts
var applyInactiveNodeOpacity = (view, value) => {
  if (typeof value !== "number")
    return;
  view.containerEl.style.setProperty(
    cssVariables.inactiveCardOpacity,
    `${value / 100}`
  );
};

// src/stores/view/subscriptions/actions/view/load-collapsed-sections-from-settings.ts
var loadCollapsedSectionsFromSettings = (view) => {
  const settings = view.plugin.settings.getValue();
  const path = view.file.path;
  const collapsedSections = settings.documents[path]?.outline?.collapsedSections;
  if (!collapsedSections)
    return;
  const viewStore = view.viewStore;
  const documentState = view.documentStore.getValue();
  const collapsedIds = collapsedSections.map((section) => {
    return documentState.sections.section_id[section];
  }).filter((x) => x);
  if (collapsedIds.length > 0) {
    viewStore.dispatch({
      type: "view/outline/load-persisted-collapsed-parents",
      payload: {
        collapsedIds
      }
    });
  }
};

// src/helpers/round-up.ts
var roundUp = (value, precision) => {
  precision = Math.pow(10, precision);
  return Math.ceil(value * precision) / precision;
};

// src/stores/view/subscriptions/effects/css-variables/apply-headings-font-size.ts
var variables = [
  "--h2-size",
  "--h3-size",
  "--h4-size",
  "--h5-size",
  "--h6-size"
];
var BASE_MULTIPLIER = 1.125;
var MIN_HEADING_SIZE = 1;
var adjustMultiplier = (h1_em) => {
  const subtracted = (DEFAULT_H1_FONT_SIZE_EM - h1_em) * 0.2;
  return h1_em < DEFAULT_H1_FONT_SIZE_EM ? BASE_MULTIPLIER - Math.min(subtracted, 0.125) : BASE_MULTIPLIER;
};
var calculateFontSize = (h1_em, multiplier, level2) => {
  return Math.max(
    roundUp(h1_em * Math.pow(1 / multiplier, level2), 3),
    MIN_HEADING_SIZE
  );
};
var applyHeadingsFontSize = (view, h1_em) => {
  const el = view.containerEl;
  if (h1_em === DEFAULT_H1_FONT_SIZE_EM) {
    el.style.removeProperty("--h1-size");
    for (const key of variables) {
      el.style.removeProperty(key);
    }
  } else {
    el.style.setProperty("--h1-size", `${h1_em}em`);
    const adjustedMultiplier = adjustMultiplier(h1_em);
    for (let i = 0; i < variables.length; i++) {
      const key = variables[i];
      const value = calculateFontSize(h1_em, adjustedMultiplier, i + 1);
      el.style.setProperty(key, `${value}em`);
    }
  }
};

// src/stores/view/subscriptions/on-view-mount.ts
var applySettingsToView = (view) => {
  const state2 = view.plugin.settings.getValue();
  applyFontSize(view, state2.view.fontSize);
  applyHeadingsFontSize(view, state2.view.h1FontSize_em);
  applyInactiveNodeOpacity(view, state2.view.theme.inactiveNodeOpacity);
  applyCssColor(view, "containerBg");
  applyCssColor(view, "activeBranchBg");
  applyCssColor(view, "activeBranchColor");
  applyCardWidth(view, state2.view.cardWidth);
  applyCardIndentationWidth(view, state2.view.nodeIndentationWidth);
  applyCardsGap(view, state2.view.cardsGap);
  if (!view.container)
    return;
  applyZoomLevel(view, state2.view.zoomLevel);
  attachCheckboxListener(view);
};
var onViewMount = (view) => {
  const subscriptions = /* @__PURE__ */ new Set();
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  if (!view.file)
    return subscriptions;
  setInitialActiveNode(view);
  loadCollapsedSectionsFromSettings(view);
  if (view.isActive && isEmptyDocument(documentState.document.content)) {
    enableEditMode2(viewStore, documentState);
  }
  view.plugin.statusBar.updateAll(view);
  if (view.isActive)
    focusContainer(view);
  loadPinnedNodesToDocument(view);
  markUnresolvedLinks(view);
  applySettingsToView(view);
  attachHoverPreviewListener(view);
  attachWheelScrollListener(view);
  documentStore.dispatch({ type: "document/meta/refresh-group-parent-ids" });
  attachCloseModalsListener(view);
  view.rulesProcessor.onRulesUpdate();
  view.zoomFactor = view.plugin.settings.getValue().view.zoomLevel;
  subscriptions.add(watchViewSize(view));
  return subscriptions;
};

// src/stores/view/helpers/get-view-event-type.ts
var eventTypesDictionary2 = {
  "view/set-active-node/history/select-previous": {
    activeNodeHistory: true
  },
  "view/set-active-node/history/select-next": { activeNodeHistory: true },
  "view/set-active-node/sequential/select-next": {
    activeNodeHistory: true
  },
  "view/search/set-query": { search: true },
  "view/search/set-results": { search: true },
  "view/search/toggle-input": { search: true },
  "view/set-active-node/document": { activeNode: true },
  "view/set-active-node/mouse": { activeNode: true },
  "view/set-active-node/mouse-silent": { activeNode: true },
  "view/set-active-node/search": { activeNode: true },
  "view/set-active-node/keyboard": { activeNode: true },
  "view/set-active-node/keyboard-jump": { activeNode: true },
  "view/selection/select-all": { activeNode: true },
  "view/editor/enable-main-editor": { mainEditor: true },
  "view/editor/disable-main-editor": { mainEditor: true },
  "view/editor/enable-sidebar-editor": { sidebarEditor: true },
  "view/editor/disable-sidebar-editor": { sidebarEditor: true }
};
var viewEventTypes = new Map(Object.entries(eventTypesDictionary2));
var none2 = {};
var getViewEventType = (type) => {
  return viewEventTypes.get(type) || none2;
};

// src/stores/view/subscriptions/actions/update-search-results.ts
var updateActiveNodeAfterSearch = (view, results) => {
  const activeNode = view.viewStore.getValue().document.activeNode;
  const shouldUpdateActiveNode = results.length > 0 && !results.find((r) => r === activeNode);
  if (shouldUpdateActiveNode) {
    view.viewStore.dispatch({
      type: "view/set-active-node/search",
      payload: {
        id: results[0]
      }
    });
  }
};
var updateSearchResults = (view) => {
  const viewState = view.viewStore.getValue();
  const query = viewState.search.query;
  if (!query)
    return;
  const results = view.documentSearch.search(query);
  view.viewStore.dispatch({
    type: "view/search/set-results",
    payload: {
      results
    }
  });
  const newSearchResults = Array.from(results.keys()).sort().join("");
  const previousSearchResults = Array.from(viewState.search.results.keys()).sort().join("");
  if (previousSearchResults !== newSearchResults) {
    updateActiveNodeAfterSearch(view, Array.from(results.keys()));
  }
};

// src/stores/view/subscriptions/actions/persist-active-node-in-plugin-settings.ts
var state = {};
var persistActiveNodeInPluginSettings = (view) => {
  if (!view.file)
    return;
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const sectionNumber = getSectionOfId(
    documentState.sections,
    viewState.document.activeNode
  );
  const path = view.file?.path;
  if (state[path] === sectionNumber)
    return;
  state[path] = sectionNumber;
  view.plugin.settings.dispatch({
    type: "settings/document/persist-active-section",
    payload: {
      sectionNumber,
      path
    }
  });
};

// src/stores/view/subscriptions/actions/persist-active-pinned-node.ts
var persistActivePinnedNode = (view) => {
  const documentState = view.documentStore.getValue();
  const sections = documentState.sections;
  const viewState = view.viewStore.getValue();
  const section = sections.id_section[viewState.pinnedNodes.activeNode];
  view.plugin.settings.dispatch({
    type: "settings/pinned-nodes/persist-active-node",
    payload: {
      filePath: view.file.path,
      section
    }
  });
};

// src/stores/view/subscriptions/effects/show-search-results-in-minimap.ts
var showSearchResultsInMinimap = (view) => {
  const viewStore = view.viewStore;
  const viewState = viewStore.getValue();
  const settingsStore = view.plugin.settings;
  const settingsState = settingsStore.getValue();
  if (viewState.search.showInput) {
    if (!settingsState.view.showMinimap) {
      if (viewState.search.results.size > 0) {
        settingsStore.dispatch({
          type: "settings/view/toggle-minimap"
        });
        view.documentSearch.searchTriggeredMinimap = true;
      }
    }
  } else if (view.documentSearch.searchTriggeredMinimap) {
    if (settingsState.view.showMinimap) {
      settingsStore.dispatch({ type: "settings/view/toggle-minimap" });
    }
    view.documentSearch.searchTriggeredMinimap = false;
  }
};

// src/obsidian/helpers/get-used-hotkeys.ts
var getUsedHotkeys = (plugin) => {
  const app = plugin.app;
  const conflicting = /* @__PURE__ */ new Map();
  const allCommands = {
    ...app.commands.commands,
    ...app.commands.editorCommands
  };
  const customHotkeys = Object.fromEntries(
    Object.entries(app.hotkeyManager.customKeys).map(
      ([name, hotkeys]) => [
        name,
        { hotkeys, name: allCommands[name]?.name || name }
      ]
    )
  );
  const commands = {
    ...allCommands,
    ...customHotkeys
  };
  for (const command of Object.values(commands)) {
    if (command.hotkeys?.length) {
      for (const hotkey of command.hotkeys) {
        const hotkey_string = hotkeyToString(hotkey);
        conflicting.set(hotkey_string, command.name);
      }
    }
  }
  return conflicting;
};

// src/stores/view/subscriptions/actions/settings/persist-collapsed-sections.ts
var persistCollapsedSections = (view) => {
  const viewState = view.viewStore.getValue();
  const documentState = view.documentStore.getValue();
  const collapsedParents = Array.from(viewState.outline.collapsedParents);
  const collapsedSections = collapsedParents.map((id2) => {
    return documentState.sections.id_section[id2];
  }).filter((x) => x);
  view.plugin.settings.dispatch({
    type: "settings/document/persist-collapsed-sections",
    payload: {
      path: view.file.path,
      sections: collapsedSections
    }
  });
};

// src/stores/view/subscriptions/on-view-state-update.ts
var onViewStateUpdate = (view, action, localState) => {
  const viewStore = view.viewStore;
  const viewState = viewStore.getValue();
  const container = view.container;
  const type = action.type;
  const e = getViewEventType(type);
  const activeNodeChange = e.activeNode || e.activeNodeHistory;
  const activeNodeHasChanged = localState.previousActiveNode !== viewState.document.activeNode;
  if (activeNodeHasChanged) {
    localState.previousActiveNode = viewState.document.activeNode;
  }
  if (activeNodeChange && activeNodeHasChanged) {
    persistActiveNodeInPluginSettings(view);
    view.plugin.statusBar.updateProgressIndicatorAndChildCount(view);
  }
  if (activeNodeChange) {
    if (view.minimapStore) {
      view.minimapStore.dispatch({
        type: "minimap/set-active-node",
        payload: {
          id: viewState.document.activeNode
        }
      });
    }
  }
  if (action.type === "view/search/set-query") {
    updateSearchResults(view);
  }
  if (e.search || e.mainEditor || action.type === "view/update-active-branch?source=document" || activeNodeChange && activeNodeHasChanged) {
    view.alignBranch.align(action);
  }
  if (!container || !view.isViewOfFile)
    return;
  if (type === "view/search/toggle-fuzzy-mode") {
    view.documentSearch.resetIndex();
  }
  if (action.type === "view/editor/disable-main-editor" || action.type === "view/editor/disable-sidebar-editor" || action.type === "view/set-active-node/history/select-next" || action.type === "view/set-active-node/history/select-previous") {
    focusContainer(view);
  }
  if (action.type === "view/search/toggle-input") {
    if (!viewState.search.showInput) {
      focusContainer(view);
    }
  }
  if (action.type === "view/search/set-results" || action.type === "view/search/toggle-input" || action.type === "view/search/set-query") {
    showSearchResultsInMinimap(view);
  }
  if (type === "view/pinned-nodes/set-active-node") {
    persistActivePinnedNode(view);
  }
  if (action.type === "view/hotkeys/toggle-modal") {
    if (viewState.ui.controls.showHelpSidebar) {
      view.viewStore.dispatch({
        type: "view/hotkeys/update-conflicts",
        payload: {
          conflicts: getUsedHotkeys(view.plugin)
        }
      });
    }
  }
  if (action.type === "view/outline/toggle-collapse-all" || action.type === "view/outline/toggle-collapse-node" || action.type === "view/outline/refresh-collapsed-nodes") {
    persistCollapsedSections(view);
  }
};

// src/stores/view/subscriptions/actions/set-active-node.ts
var setActiveNode = (view, action) => {
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const activeNodeOfView = viewState.document.activeNode;
  const id_section = documentState.sections.id_section;
  const section_id = documentState.sections.section_id;
  const activeSectionOfView = id_section[activeNodeOfView];
  const activeNodeExists = !!activeSectionOfView;
  let newActiveSection = documentState.history.context.activeSection;
  let shouldSetActiveNode = true;
  if (activeNodeExists) {
    if (action.type === "document/history/select-previous-snapshot") {
      const state2 = documentState.history.state;
      const previousSnapshot = documentState.history.items[state2.activeIndex + 1];
      const affectedSection = previousSnapshot.context.affectedSection;
      if (section_id[affectedSection]) {
        newActiveSection = affectedSection;
      }
    } else if (view.isViewOfFile && (action.type === "document/drop-node" || action.type === "document/move-node")) {
      shouldSetActiveNode = false;
    } else if (!view.isActive) {
      shouldSetActiveNode = false;
    }
  }
  if (shouldSetActiveNode) {
    view.viewStore.dispatch({
      type: "view/set-active-node/document",
      payload: {
        id: getIdOfSection(documentState.sections, newActiveSection)
      }
    });
  }
};

// src/stores/view/subscriptions/actions/remove-obsolete-navigation-items.ts
var removeObsoleteNavigationItems = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "view/active-node-history/delete-obsolete",
    payload: {
      content: documentState.document.content
    }
  });
};

// src/stores/view/subscriptions/actions/persist-pinned-nodes.ts
var persistPinnedNodes = (view) => {
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const pinnedNodes = documentState.pinnedNodes;
  const sections = documentState.sections;
  const pinnedSections = pinnedNodes.Ids.map((id2) => sections.id_section[id2]);
  const section = sections.id_section[viewState.pinnedNodes.activeNode];
  view.plugin.settings.dispatch({
    type: "settings/pinned-nodes/persist",
    payload: {
      sections: pinnedSections,
      filePath: view.file.path,
      section
    }
  });
};

// src/stores/view/subscriptions/actions/update-stale-active-pinned-node.ts
var updateStaleActivePinnedNode = (view) => {
  const viewStore = view.viewStore;
  const pinnedNodes = view.documentStore.getValue().pinnedNodes.Ids;
  if (pinnedNodes.length > 0) {
    const activePinnedNode = viewStore.getValue().pinnedNodes.activeNode;
    if (!activePinnedNode || !pinnedNodes.includes(activePinnedNode)) {
      setActivePinnedNode2(view, pinnedNodes[pinnedNodes.length - 1]);
    }
  }
};

// src/stores/view/subscriptions/actions/clear-selected-nodes.ts
var clearSelectedNodes = (view) => {
  view.viewStore.dispatch({ type: "view/selection/clear-selection" });
};

// src/stores/view/subscriptions/actions/update-selected-nodes.ts
var updateSelectedNodes2 = (view, action, changeHistory) => {
  const documentState = view.documentStore.getValue();
  let clear = true;
  if (action.type === "document/paste-node" || changeHistory) {
    const history = documentState.history;
    const snapshot = history.items[history.state.activeIndex];
    if (snapshot.context.affectedSections) {
      clear = false;
      const ids = snapshot.context.affectedSections.map(
        (section) => getIdOfSection(documentState.sections, section)
      );
      view.viewStore.dispatch({
        type: "view/selection/set-selection",
        payload: {
          ids
        }
      });
    }
  }
  if (clear) {
    clearSelectedNodes(view);
  }
};

// src/stores/view/subscriptions/on-document-state-update.ts
var onDocumentStateUpdate = (view, action) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  const container = view.container;
  viewStore.setContext(documentState.document);
  const type = action.type;
  const e = getDocumentEventType(type);
  if (type === "document/file/load-from-disk") {
    view.inlineEditor.unloadNode();
  }
  const structuralChange = e.createOrDelete || e.dropOrMove || e.changeHistory || e.clipboard;
  if (structuralChange) {
    setActiveNode(view, action);
    viewStore.dispatch({
      type: "view/update-active-branch?source=document",
      context: {
        documentAction: action
      }
    });
    viewStore.dispatch({
      type: "view/outline/refresh-collapsed-nodes"
    });
    documentStore.dispatch({
      type: "document/pinned-nodes/remove-stale-nodes"
    });
    documentStore.dispatch({
      type: "document/meta/refresh-group-parent-ids"
    });
  }
  if (structuralChange && type !== "document/move-node") {
    updateSelectedNodes2(view, action, e.changeHistory);
  }
  if (type === "document/add-node" && view.isActive) {
    enableEditMode2(viewStore, documentState);
  }
  if (type === "document/delete-node" || type === "document/cut-node" || e.changeHistory || type === "document/extract-node" || type === "document/file/load-from-disk" || type === "document/split-node") {
    removeObsoleteNavigationItems(viewStore, documentState);
  }
  if (e.content) {
    view.alignBranch.align(action);
  }
  if (structuralChange || e.content) {
    view.rulesProcessor.onDocumentUpdate(action);
  }
  if (!container || !view.isViewOfFile)
    return;
  if (e.content || structuralChange) {
    view.saveDocument();
  }
  if (e.content || structuralChange) {
    if (view.minimapStore) {
      view.minimapEffects.drawDocument(view);
    }
    view.documentSearch.resetIndex();
    const query = viewStore.getValue().search.query;
    if (query) {
      view.viewStore.dispatch({
        type: "view/search/set-query",
        payload: {
          query
        }
      });
    }
  }
  if (structuralChange) {
    view.plugin.statusBar.updateAll(view);
  }
  if (e.content || structuralChange) {
    if (view.isActive)
      focusContainer(view);
  }
  const pinnedNodesUpdate = type === "document/pinned-nodes/remove-stale-nodes" || type === "document/pinned-nodes/pin" || type === "document/pinned-nodes/unpin";
  if (pinnedNodesUpdate) {
    persistPinnedNodes(view);
  }
  if (pinnedNodesUpdate || type === "document/pinned-nodes/load-from-settings") {
    if (type === "document/pinned-nodes/pin") {
      setActivePinnedNode2(view, action.payload.id);
    } else {
      updateStaleActivePinnedNode(view);
    }
  }
};

// src/stores/view/subscriptions/on-plugin-settings-update.ts
var onPluginSettingsUpdate = (view, state2, action) => {
  if (!view.container)
    return;
  const type = action.type;
  if (type === "settings/view/theme/set-font-size") {
    applyFontSize(view, state2.view.fontSize);
  } else if (type === "settings/view/theme/set-h1-font-size") {
    applyHeadingsFontSize(view, state2.view.h1FontSize_em);
  } else if (type === "settings/view/theme/set-container-bg-color") {
    applyCssColor(view, "containerBg");
  } else if (type === "settings/view/theme/set-active-branch-bg-color") {
    applyCssColor(view, "activeBranchBg");
  } else if (type === "settings/view/layout/set-card-width") {
    applyCardWidth(view, state2.view.cardWidth);
  } else if (type === "settings/view/layout/set-cards-gap") {
    applyCardsGap(view, state2.view.cardsGap);
  } else if (action.type === "settings/view/set-zoom-level") {
    applyZoomLevel(view, state2.view.zoomLevel);
    view.zoomFactor = state2.view.zoomLevel;
  } else if (action.type === "settings/documents/set-document-format") {
    view.saveDocument();
  } else if (type === "settings/view/set-node-indentation-width") {
    applyCardIndentationWidth(view, state2.view.nodeIndentationWidth);
  } else if (type === "settings/view/theme/set-inactive-node-opacity") {
    applyInactiveNodeOpacity(view, state2.view.theme.inactiveNodeOpacity);
  } else if (type === "settings/view/theme/set-active-branch-color") {
    applyCssColor(view, "activeBranchColor");
  } else if (type === "settings/hotkeys/reset-all" || type === "settings/hotkeys/apply-preset" || type === "settings/hotkeys/reset-custom-hotkey" || type === "settings/hotkeys/set-custom-hotkey" || type === "settings/hotkeys/set-blank") {
    view.viewStore.dispatch({
      type: "view/hotkeys/update-conflicts",
      payload: {
        conflicts: getUsedHotkeys(view.plugin)
      }
    });
  } else if (type === "settings/view/modes/toggle-outline-mode") {
    if (state2.view.outlineMode) {
      view.viewStore.dispatch({
        type: "view/outline/refresh-collapsed-nodes"
      });
    }
  }
  const shouldAlign = type === "view/left-sidebar/toggle" || type === "view/left-sidebar/set-width" || type === "settings/view/set-zoom-level" || type === "settings/view/layout/set-card-width" || type === "settings/view/layout/set-limit-card-height" || type === "settings/view/toggle-minimap" || type === "settings/view/toggle-horizontal-scrolling-mode" || type === "settings/view/toggle-vertical-scrolling-mode" || type === "settings/view/layout/set-cards-gap" || type === "view/modes/gap-between-cards/toggle" || type === "settings/view/set-node-indentation-width";
  if (shouldAlign) {
    view.alignBranch.align(action);
  }
  if (view.isActive && type === "settings/view/set-zoom-level") {
    focusContainer(view);
  }
  const shouldUpdateStyleRules = type === "settings/style-rules/add" || type === "settings/style-rules/update" || type === "settings/style-rules/delete" || type === "settings/style-rules/update-condition" || type === "settings/style-rules/enable-rule" || type === "settings/style-rules/disable-rule" || type === "settings/style-rules/move" || type === "settings/style-rules/update-style" || type === "settings/style-rules/toggle-global";
  if (shouldUpdateStyleRules) {
    view.rulesProcessor.onRulesUpdate();
  }
};

// src/stores/view/subscriptions/on-plugin-state-update.ts
var onPluginStateUpdate = (view, action) => {
  if (!view.container)
    return;
  if (action.type === "plugin/echo/workspace/active-leaf-change") {
    if (view.viewStore.getValue().document.editing.activeNodeId) {
      saveNodeContent(view);
    }
  }
  if (action.type === "plugin/documents/update-active-view-of-document" || action.type === "plugin/echo/workspace/resize") {
    if (view.isActive) {
      focusContainer(view);
      view.plugin.statusBar.updateAll(view);
    }
    view.alignBranch.align(action);
  }
};

// src/stores/view/subscriptions/on-metadata-cache.ts
var import_obsidian29 = require("obsidian");
var metadataCallback = (view, updatedFile) => {
  const viewFile = view.file;
  if (!viewFile)
    return;
  if (updatedFile === viewFile) {
    markUnresolvedLinks(view);
  }
};
var vaultCallback = (view, affectedFile) => {
  if (!(affectedFile instanceof import_obsidian29.TFile))
    return;
  const viewFile = view.file;
  if (!viewFile)
    return;
  const viewFileLinks = view.plugin.app.metadataCache.getFileCache(viewFile)?.links;
  if (!viewFileLinks)
    return;
  let affectedFileIsALink = false;
  for (const link of viewFileLinks) {
    const linkBasename = link.link.split("#")[0];
    if (affectedFile.basename === linkBasename) {
      affectedFileIsALink = true;
      break;
    }
  }
  if (affectedFileIsALink) {
    markUnresolvedLinks(view);
  }
};
var onMetadataCache = (view) => {
  const app = view.plugin.app;
  const metadataRef = app.metadataCache.on(
    "changed",
    (file) => metadataCallback(view, file)
  );
  const createRef = app.vault.on(
    "create",
    (file) => vaultCallback(view, file)
  );
  const deleteRef = app.vault.on(
    "delete",
    (file) => vaultCallback(view, file)
  );
  return () => {
    app.metadataCache.offref(metadataRef);
    app.vault.offref(createRef);
    app.vault.offref(deleteRef);
  };
};

// src/stores/view/subscriptions/view-subscriptions.ts
var viewSubscriptions = (view) => {
  const unsubFromDocument = view.documentStore.subscribe(
    (documentState, action) => {
      if (!action)
        return;
      onDocumentStateUpdate(view, action);
    }
  );
  const localState = {
    previousActiveNode: ""
  };
  let onMountSubscriptions = /* @__PURE__ */ new Set();
  const unsubFromView = view.viewStore.subscribe(
    (viewState, action, initialRun) => {
      if (initialRun) {
        onMountSubscriptions = onViewMount(view);
      } else if (action) {
        onViewStateUpdate(view, action, localState);
      }
    }
  );
  const unsubFromDocuments = view.plugin.store.subscribe((_, action) => {
    if (!action)
      return;
    onPluginStateUpdate(view, action);
  });
  const unsubFromSettings = view.plugin.settings.subscribe(
    (state2, action) => {
      if (!action)
        return;
      onPluginSettingsUpdate(view, state2, action);
    }
  );
  const unsubFromCache = onMetadataCache(view);
  return () => {
    unsubFromDocument();
    unsubFromCache();
    unsubFromView();
    unsubFromSettings();
    unsubFromDocuments();
    view.rulesProcessor.onViewUnmount();
    for (const unsub of onMountSubscriptions) {
      unsub();
    }
  };
};

// src/obsidian/helpers/inline-editor/inline-editor.ts
var import_obsidian32 = require("obsidian");

// src/obsidian/helpers/inline-editor/helpers/vim-enter-insert-mode.ts
var vimEnterInsertMode = (plugin, view) => {
  const config = plugin.app.vault.config;
  if (config?.vimMode) {
    try {
      activeWindow.CodeMirrorAdapter?.Vim.enterInsertMode(
        // @ts-ignore
        view.editMode?.editor?.cm?.cm
      );
    } catch {
      logger.warn("could not enter insert mode");
    }
  }
};

// src/obsidian/helpers/inline-editor/helpers/fix-vim-cursor-when-zooming.ts
var fixVimCursorWhenZooming = (view) => {
  if (view.zoomFactor === 1)
    return null;
  const config = view.plugin.app.vault.config;
  if (!config?.vimMode)
    return null;
  const inlineEditor = view.inlineEditor.target;
  if (!inlineEditor)
    return null;
  const previousValues = { top: -1, lineHeight: -1, left: -1 };
  let animationFrame;
  const adjustCursorPosition = () => {
    const cursor2 = inlineEditor.querySelector(
      ".cm-cursor-primary"
    );
    if (!cursor2) {
      animationFrame = requestAnimationFrame(adjustCursorPosition);
      return;
    }
    const top = parseFloat(cursor2.style.top);
    const left = parseFloat(cursor2.style.left);
    const lineHeight = parseFloat(cursor2.style.lineHeight);
    if (top !== previousValues.top) {
      cursor2.style.top = `${(top + 1) / view.zoomFactor}px`;
      previousValues.top = parseFloat(cursor2.style.top);
    }
    if (left !== previousValues.left) {
      cursor2.style.left = `${left / view.zoomFactor}px`;
      previousValues.left = parseFloat(cursor2.style.left);
    }
    if (lineHeight !== previousValues.lineHeight) {
      cursor2.style.lineHeight = `${lineHeight / view.zoomFactor}px`;
      previousValues.lineHeight = parseFloat(cursor2.style.lineHeight);
    }
    animationFrame = requestAnimationFrame(adjustCursorPosition);
  };
  animationFrame = requestAnimationFrame(adjustCursorPosition);
  return () => {
    cancelAnimationFrame(animationFrame);
  };
};

// src/obsidian/helpers/inline-editor/helpers/lock-file.ts
var import_obsidian30 = require("obsidian");
var noop2 = async () => {
};
var lockFile = (view) => {
  view.plugin.app.workspace.iterateAllLeaves((e) => {
    const leafView = e.view;
    if (leafView instanceof import_obsidian30.MarkdownView) {
      if (leafView.file === view.file) {
        leafView.__setViewData__ = leafView.setViewData;
        leafView.setViewData = noop2;
      }
    }
  });
};

// src/obsidian/helpers/inline-editor/helpers/unlock-file.ts
var import_obsidian31 = require("obsidian");
var unlockFile = (view) => {
  view.plugin.app.workspace.iterateAllLeaves((e) => {
    const leafView = e.view;
    if (leafView instanceof import_obsidian31.MarkdownView) {
      if (leafView.file === view.file) {
        if ("__setViewData__" in leafView) {
          leafView.setViewData = leafView.__setViewData__;
          delete leafView.__setViewData__;
        }
      }
    }
  });
};

// src/obsidian/helpers/inline-editor/inline-editor.ts
var noop3 = async () => {
};
var _nodeId, _mounting;
var InlineEditor = class {
  constructor(view) {
    this.view = view;
    __privateAdd(this, _nodeId, null);
    this.target = null;
    this.onChangeSubscriptions = /* @__PURE__ */ new Set();
    __privateAdd(this, _mounting, Promise.resolve());
    this.subscriptions = /* @__PURE__ */ new Set();
    this.cursorPositions = /* @__PURE__ */ new Map();
    this.focus = () => {
      this.inlineView.editor.focus();
    };
    this.isCursorInRange = (cursor2) => {
      const docStart = { line: 0, ch: 0 };
      const lastLine = this.inlineView.editor.lastLine();
      const docEnd = {
        line: lastLine,
        ch: this.inlineView.editor.getLine(lastLine).length
      };
      const isLineInRange = cursor2.line >= docStart.line && cursor2.line <= docEnd.line;
      const isChInRange = (cursor2.line === docStart.line ? cursor2.ch >= docStart.ch : true) && (cursor2.line === docEnd.line ? cursor2.ch <= docEnd.ch : true);
      return isLineInRange && isChInRange;
    };
    this.restoreCursor = () => {
      const existingCursor = this.cursorPositions.get(this.nodeId);
      if (existingCursor && this.isCursorInRange(existingCursor)) {
        this.setCursor(existingCursor);
      } else {
        const lastLine = this.inlineView.editor.lastLine();
        const ch = this.inlineView.editor.getLine(lastLine).length;
        this.setCursor({
          line: lastLine,
          ch
        });
      }
    };
    this.setActiveEditor = () => {
      this.view.plugin.app.workspace._activeEditor = this.inlineView;
    };
    this.invokeAndDeleteOnChangeSubscriptions = () => {
      if (this.onChangeSubscriptions.size > 0)
        for (const subscription of this.onChangeSubscriptions) {
          subscription();
          this.onChangeSubscriptions.delete(subscription);
        }
    };
    this.saveContent = () => {
      const nodeId = this.nodeId;
      if (!nodeId)
        return;
      const content = this.getContent();
      const viewState = this.view.viewStore.getValue();
      this.view.documentStore.dispatch({
        type: "document/update-node-content",
        payload: {
          nodeId,
          content
        },
        context: {
          isInSidebar: viewState.document.editing.isInSidebar
        }
      });
    };
    this.fixVimWhenZooming = () => {
      const viewState = this.view.viewStore.getValue();
      if (viewState.document.editing.isInSidebar)
        return;
      const unsub = fixVimCursorWhenZooming(this.view);
      if (unsub) {
        this.subscriptions.add(unsub);
      }
    };
  }
  get nodeId() {
    return __privateGet(this, _nodeId);
  }
  set nodeId(value) {
    __privateSet(this, _nodeId, value);
  }
  get mounting() {
    return __privateGet(this, _mounting);
  }
  getContent() {
    return this.inlineView.editor.getValue();
  }
  getCursor() {
    return this.inlineView.editor.getCursor();
  }
  getEditor() {
    return this.inlineView.editor;
  }
  deleteNodeCursor(nodeId) {
    this.cursorPositions.delete(nodeId);
  }
  setNodeCursor(nodeId, cursor2) {
    if (this.nodeId && nodeId === this.nodeId)
      this.setCursor(cursor2);
    else
      this.cursorPositions.set(nodeId, cursor2);
  }
  setContent(content) {
    this.inlineView.__setViewData__(content, true);
  }
  loadNode(target, nodeId) {
    if (!this.view.file)
      return;
    if (this.nodeId) {
      this.unloadNode();
    }
    let resolve = () => {
    };
    __privateSet(this, _mounting, new Promise((_resolve) => {
      resolve = _resolve;
    }));
    const content = this.view.documentStore.getValue().document.content[nodeId]?.content;
    this.setContent(content);
    target.append(this.containerEl);
    this.focus();
    AdjustHeight(this.view, target)();
    this.target = target;
    if (!content) {
      vimEnterInsertMode(this.view.plugin, this.inlineView);
    }
    this.target.addEventListener("focusin", this.setActiveEditor);
    this.setActiveEditor();
    this.nodeId = nodeId;
    this.restoreCursor();
    this.lockFile();
    this.fixVimWhenZooming();
    setTimeout(() => resolve(), Math.max(16, content.length / 60));
  }
  unloadNode(nodeId, discardChanges = false) {
    const currentNodeId = this.nodeId;
    if (nodeId && nodeId !== currentNodeId)
      return;
    if (currentNodeId && !discardChanges) {
      this.saveContent();
      const cursor2 = this.getCursor();
      this.cursorPositions.set(currentNodeId, cursor2);
    }
    this.nodeId = null;
    if (this.target) {
      this.view.plugin.app.workspace.activeEditor = null;
      this.target.removeEventListener("focusin", this.setActiveEditor);
      this.target.empty();
      this.target = null;
    }
    for (const subscription of this.subscriptions) {
      subscription();
      this.subscriptions.delete(subscription);
    }
    this.unlockFile();
  }
  async onload() {
    const workspace = this.view.plugin.app.workspace;
    this.containerEl = document.createElement("div");
    this.containerEl.addClasses(["lineage-inline-editor"]);
    this.inlineView = new import_obsidian32.MarkdownView({
      containerEl: this.containerEl,
      app: this.view.plugin.app,
      workspace
    });
    this.inlineView.save = noop3;
    this.inlineView.requestSave = this.invokeAndDeleteOnChangeSubscriptions;
    this.inlineView.__setViewData__ = this.inlineView.setViewData;
    this.inlineView.setViewData = noop3;
    if (this.inlineView.getMode() === "preview") {
      await this.inlineView.setState(
        { mode: "source" },
        { history: false }
      );
    }
  }
  onNextChange(subscription) {
    this.onChangeSubscriptions.add(subscription);
    return () => {
      this.onChangeSubscriptions.delete(subscription);
    };
  }
  async loadFile(file) {
    this.inlineView.file = file;
    await this.inlineView.onLoadFile(file);
  }
  async unloadFile() {
    const file = this.inlineView.file;
    if (file) {
      this.inlineView.file = null;
      await this.inlineView.onUnloadFile(file);
    }
    this.unloadNode();
  }
  setCursor(cursor2) {
    this.inlineView.editor.setCursor(cursor2);
  }
  /* prevents obsidian from replacing file.data with card.data when the card editor and file editor share the same file*/
  lockFile() {
    lockFile(this.view);
  }
  unlockFile() {
    unlockFile(this.view);
  }
};
_nodeId = new WeakMap();
_mounting = new WeakMap();

// src/view/helpers/stringify-document.ts
var stringifyDocument = (document2, format2) => {
  const json = columnsToJson(document2.columns, document2.content);
  if (format2 === "outline") {
    return jsonToOutline(json);
  } else if (format2 === "html-element") {
    return jsonToHtmlElement(json);
  } else {
    return jsonToHtmlComment(json);
  }
};

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/stores/view/subscriptions/effects/document-search/document-search.ts
var _searchTriggeredMinimap;
var DocumentSearch = class {
  constructor(view) {
    this.view = view;
    __privateAdd(this, _searchTriggeredMinimap, void 0);
    this.updateIndex = () => {
      const documentState = this.view.documentStore.getValue();
      const viewState = this.view.viewStore.getValue();
      const items = [];
      for (const id2 of Object.keys(documentState.document.content)) {
        const content = documentState.document.content[id2]?.content;
        if (content) {
          items.push({
            id: id2,
            content
          });
        }
      }
      this.fuse = new Fuse(items, {
        keys: ["content"],
        threshold: viewState.search.fuzzySearch ? 0.4 : 0,
        shouldSort: true,
        isCaseSensitive: false,
        ignoreLocation: true
      });
    };
    this.resetIndex = () => {
      this.fuse = null;
    };
    this.search = (query) => {
      if (!this.fuse) {
        this.updateIndex();
      }
      const results = this.fuse.search(query);
      const map = /* @__PURE__ */ new Map();
      for (const result of results) {
        map.set(result.item.id, result);
      }
      return map;
    };
  }
  get searchTriggeredMinimap() {
    return __privateGet(this, _searchTriggeredMinimap);
  }
  set searchTriggeredMinimap(value) {
    __privateSet(this, _searchTriggeredMinimap, value);
  }
};
_searchTriggeredMinimap = new WeakMap();

// src/stores/view/subscriptions/effects/style-rules/style-rules-processor.ts
var import_obsidian33 = require("obsidian");
var StyleRulesProcessor = class {
  constructor(view) {
    this.rules = [];
    this.onViewMount = async () => {
      this.setRules();
      this.processRules(null);
    };
    this.onDocumentUpdate = async (action) => {
      this.processRules(action);
    };
    this.onRulesUpdate = async () => {
      this.setRules();
      this.processRules(null);
    };
    this.onViewUnmount = async () => {
      await rulesWorker.run({
        type: "destroy",
        payload: {
          viewId: this.view.id
        }
      });
      this.rules = [];
    };
    this.processRules = (0, import_obsidian33.debounce)(
      async (action) => {
        let results = null;
        if (this.rules.length > 0) {
          const document2 = this.view.documentStore.getValue().document;
          results = await rulesWorker.run({
            type: "process-rules",
            payload: {
              document: document2,
              rules: this.rules,
              action,
              viewId: this.view.id
            }
          });
        }
        this.view.viewStore.dispatch({
          type: "view/style-rules/update-results",
          payload: {
            results
          }
        });
      },
      500
    );
    this.setRules = () => {
      const path = this.view.file?.path;
      invariant(path);
      const settings = this.view.plugin.settings.getValue();
      const documentRules = settings.styleRules.documents[path];
      const globalRules = settings.styleRules.global;
      this.rules = [];
      if (documentRules) {
        this.rules.push(...documentRules.rules);
      }
      this.rules.push(
        ...globalRules.rules.map((r) => ({ ...r, global: true }))
      );
    };
    this.view = view;
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/delay-align.ts
var delayAlign = (action) => {
  let delay2 = 0;
  if (action.type === "view/left-sidebar/toggle" || action.type === "settings/view/toggle-minimap") {
    delay2 = 300;
  } else if (action.type === "plugin/echo/workspace/resize") {
    delay2 = 50;
  } else if (action.type === "view/life-cycle/mount") {
    delay2 = 16;
  } else if (action.type === "view/update-active-branch?source=document") {
    const documentAction = action.context.documentAction;
    if (documentAction.type === "document/add-node" || documentAction.type === "document/drop-node") {
      delay2 = 16;
    } else if (documentAction.type === "document/move-node") {
      const horizontalMove = documentAction.payload.direction === "left" || documentAction.payload.direction === "right";
      if (horizontalMove)
        delay2 = 16;
    }
  }
  return delay2;
};

// src/stores/view/subscriptions/effects/align-branch/create-align-branch-actions/force-center-active-node-v.ts
var forceCenterActiveNodeV = (action) => {
  let centerActiveNodeV = false;
  centerActiveNodeV = action.type === "view/life-cycle/mount" || action.type === "document/file/load-from-disk";
  if (!centerActiveNodeV) {
    const type = getDocumentEventType(action.type);
    centerActiveNodeV = !!type.dropOrMove || !!type.changeHistory || !!type.createOrDelete && action.type !== "document/add-node";
  }
  return centerActiveNodeV;
};

// src/stores/view/subscriptions/effects/align-branch/create-align-branch-actions/lazy-vertical-scrolling-mode.ts
var lazyVerticalScrollingMode = (context, action) => {
  const actions = [];
  if (action.type === "document/add-node") {
    if (action.payload.position === "right") {
      actions.push({
        action: "20/active-node/vertical/align-with-parent"
      });
    } else {
      actions.push({ action: "20/active-node/vertical/reveal" });
    }
  } else if (action.type === "plugin/echo/workspace/resize" || action.type === "plugin/echo/workspace/active-leaf-change" || action.type === "view/left-sidebar/toggle" || action.type === "view/left-sidebar/set-width") {
    actions.push({ action: "20/active-node/vertical/reveal" });
    actions.push({
      action: "30/parents/vertical/align-with-active-node"
    });
    actions.push({
      action: "40/children/vertical/align-with-active-node"
    });
  } else {
    actions.push({ action: "20/active-node/vertical/reveal" });
    const previousActiveBranch = context.previousActiveBranch;
    const activeBranch = context.activeBranch;
    if (previousActiveBranch) {
      const isChildOfPreviousNode = previousActiveBranch.group === activeBranch.group || previousActiveBranch.node === activeBranch.group;
      const isParentOfPreviousNode = previousActiveBranch.group === activeBranch.node;
      const isMovingLeft = isParentOfPreviousNode || !isChildOfPreviousNode && activeBranch.sortedParentNodes.every((p, i) => {
        return previousActiveBranch.sortedParentNodes[i] === p;
      });
      if (!(isChildOfPreviousNode || isMovingLeft)) {
        actions.push({
          action: "30/parents/vertical/align-with-active-node"
        });
      }
      if (!isParentOfPreviousNode) {
        actions.push({
          action: "40/children/vertical/align-with-active-node"
        });
      }
    }
  }
  return actions;
};

// src/stores/view/subscriptions/effects/align-branch/create-align-branch-actions/outline-scrolling-actions.ts
var outlineScrollingActions = (context, action) => {
  const actions = [];
  const settings = context.alignBranchSettings;
  const forceCenterActiveNodeV2 = action.type === "view/life-cycle/mount" || action.type === "document/file/load-from-disk";
  if (forceCenterActiveNodeV2) {
    actions.push({ action: "20/active-node/horizontal/center" });
    actions.push({ action: "20/active-node/vertical/center" });
  } else {
    if (settings.centerActiveNodeH) {
      actions.push({ action: "20/active-node/horizontal/center" });
    } else {
      actions.push({ action: "20/active-node/horizontal/reveal" });
    }
    if (settings.centerActiveNodeV) {
      actions.push({ action: "20/active-node/vertical/center" });
    } else {
      actions.push({ action: "20/active-node/vertical/reveal" });
    }
  }
  if (action.type === "view/life-cycle/mount") {
    actions.push({
      action: "10/first-column/horizontal/move-to-the-left"
    });
  }
  return actions;
};

// src/stores/view/subscriptions/effects/align-branch/create-align-branch-actions/force-center-active-node-h.ts
var forceCenterActiveNodeH = (context, action) => {
  if (action.type === "view/life-cycle/mount") {
    return context.activeBranch.sortedParentNodes.length < 2;
  }
};

// src/stores/view/subscriptions/effects/align-branch/create-align-branch-actions/create-align-branch-actions.ts
var createAlignBranchActions = (context, action) => {
  const actions = [];
  if (action.type === "view/update-active-branch?source=document") {
    action = action.context.documentAction;
  }
  if (action.type === "view/align-branch/reveal-node") {
    actions.push({ action: "20/active-node/vertical/reveal" });
    actions.push({ action: "20/active-node/horizontal/reveal" });
    return actions;
  } else if (action.type === "view/align-branch/center-node") {
    actions.push({ action: "20/active-node/vertical/center" });
    actions.push({ action: "20/active-node/horizontal/center" });
    if (!context.outlineMode) {
      actions.push({ action: "30/parents/vertical/center" });
      actions.push({ action: "40/children/vertical/center" });
    }
    return actions;
  }
  if (context.outlineMode) {
    return outlineScrollingActions(context, action);
  }
  const settings = context.alignBranchSettings;
  if (settings.centerActiveNodeH || forceCenterActiveNodeH(context, action)) {
    actions.push({ action: "20/active-node/horizontal/center" });
  } else {
    actions.push({ action: "20/active-node/horizontal/reveal" });
  }
  if (settings.centerActiveNodeV || forceCenterActiveNodeV(action)) {
    actions.push({ action: "20/active-node/vertical/center" });
    actions.push({ action: "30/parents/vertical/center" });
    actions.push({ action: "40/children/vertical/center" });
  } else {
    actions.push(...lazyVerticalScrollingMode(context, action));
  }
  if (action.type === "view/life-cycle/mount" || action.type === "document/split-node" || action.type === "document/file/load-from-disk") {
    actions.push({ action: "50/inactive-columns/vertical/move-up" });
  }
  if (!settings.centerActiveNodeH && (action.type === "view/life-cycle/mount" || action.type === "settings/view/set-zoom-level")) {
    actions.push({
      action: "10/first-column/horizontal/move-to-the-left"
    });
  }
  return actions;
};

// src/lib/align-element/constants.ts
var LEFT_PADDING = 15;
var CONTROLS_BAR_WIDTH = 60;
var BREADCRUMBS_HEIGHT = 50;
var TOOLBAR_HEIGHT = 50;
var THRESHOLD = 5;

// src/lib/align-element/helpers/calculate-scroll-left.ts
var calculateScrollLeft = (elementRect, containerRect, center, scrollToTheLeft = false) => {
  const viewPortIsWideEnough = containerRect.width > elementRect.width;
  const deltaRight = containerRect.right - CONTROLS_BAR_WIDTH - elementRect.right;
  const deltaLeft = containerRect.left + LEFT_PADDING - elementRect.left;
  const leftSideIsVisible = deltaLeft < 0;
  const rightSideIsVisible = deltaRight > 0;
  let scrollLeft = 0;
  if (!viewPortIsWideEnough) {
    scrollLeft = deltaLeft;
  } else if (center) {
    const horizontalMiddle = containerRect.left + containerRect.width / 2;
    const elementMiddle = elementRect.left + elementRect.width / 2;
    scrollLeft = horizontalMiddle - elementMiddle;
  } else if (!leftSideIsVisible || scrollToTheLeft) {
    scrollLeft = deltaLeft;
  } else if (!rightSideIsVisible) {
    scrollLeft = deltaRight;
  }
  return scrollLeft;
};

// src/lib/align-element/align-element-horizontally.ts
var alignElementHorizontally = (context, id2, center, scrollToTheLeft = false) => {
  const element2 = getElementById(context.container, id2);
  if (!element2)
    return;
  const column = element2.matchParent(".column");
  if (!column)
    return;
  const elementRect = element2.getBoundingClientRect();
  const scrollLeft = calculateScrollLeft(
    elementRect,
    context.containerRect,
    center,
    scrollToTheLeft
  );
  if (Math.abs(scrollLeft) > THRESHOLD)
    context.container.scrollBy({
      left: scrollLeft * -1,
      behavior: scrollToTheLeft ? "instant" : context.alignBranchSettings.behavior
    });
  else {
    context.container.scrollBy({
      left: 0,
      behavior: "instant"
    });
  }
  return column.id;
};

// src/stores/view/subscriptions/effects/align-branch/run-align-branch-actions/actions/scroll-first-column-to-the-left.ts
var scrollFirstColumnToTheLeft = (context) => {
  const firstColumnId = context.columns[0]?.id;
  if (!firstColumnId)
    return;
  alignElementHorizontally(context, firstColumnId, false, true);
};

// src/lib/align-element/helpers/calculate-scroll-top.ts
var calculateScrollTop = (elementRect, containerRect, center) => {
  const viewPortIsTallEnough = containerRect.height >= elementRect.height;
  const deltaTop = containerRect.top + TOOLBAR_HEIGHT - elementRect.top;
  const deltaBottom = containerRect.bottom - BREADCRUMBS_HEIGHT - elementRect.bottom;
  const bottomIsVisible = deltaBottom > 0;
  const topIsVisible = deltaTop < 0;
  let scrollTop = 0;
  if (!viewPortIsTallEnough) {
    scrollTop = deltaTop;
  } else if (center) {
    const verticalMiddle = containerRect.height / 2;
    scrollTop = verticalMiddle - (elementRect.top - containerRect.top + elementRect.height / 2);
  } else {
    if (!topIsVisible) {
      scrollTop = deltaTop;
    } else if (!bottomIsVisible) {
      scrollTop = deltaBottom;
    }
  }
  return scrollTop;
};

// src/lib/align-element/helpers/calculate-scroll-top-relative.ts
var calculateScrollTopRelative = (elementRect, containerRect, activeCardRect) => {
  const viewPortIsTallEnough = containerRect.height >= elementRect.height;
  const deltaTop = containerRect.top + TOOLBAR_HEIGHT - elementRect.top;
  let scrollTop = 0;
  if (!viewPortIsTallEnough) {
    scrollTop = deltaTop;
  } else {
    const verticalMiddle = activeCardRect.top + activeCardRect.height / 2;
    scrollTop = verticalMiddle - (elementRect.top + elementRect.height / 2);
    const elementTopVisible = elementRect.top + scrollTop >= containerRect.top + TOOLBAR_HEIGHT;
    const elementBottomVisible = elementRect.bottom + scrollTop <= containerRect.bottom - BREADCRUMBS_HEIGHT;
    if (!elementTopVisible) {
      scrollTop += containerRect.top + TOOLBAR_HEIGHT - (elementRect.top + scrollTop);
    } else if (!elementBottomVisible) {
      scrollTop += containerRect.bottom - BREADCRUMBS_HEIGHT - (elementRect.bottom + scrollTop);
    }
  }
  return scrollTop;
};

// src/lib/align-element/align-element-vertically.ts
var alignVertically = (context, column, elementRect, relativeId, center) => {
  let relativeRect = null;
  if (relativeId && context.state.rects.has(relativeId)) {
    relativeRect = context.state.rects.get(relativeId);
  } else if (relativeId) {
    const relativeElement = getElementById(context.container, relativeId);
    if (relativeElement) {
      relativeRect = relativeElement.getBoundingClientRect();
    }
  }
  const scrollTop = relativeRect ? calculateScrollTopRelative(
    elementRect,
    context.containerRect,
    relativeRect
  ) : calculateScrollTop(elementRect, context.containerRect, center);
  if (Math.abs(scrollTop) > THRESHOLD) {
    column.scrollBy({
      top: scrollTop * -1 / context.alignBranchSettings.zoomLevel,
      behavior: context.alignBranchSettings.behavior
    });
  } else {
    column.scrollBy({
      top: 0,
      behavior: "instant"
    });
  }
  return {
    height: elementRect.height,
    top: elementRect.top + scrollTop
  };
};
var alignElementVertically = (context, id2, relativeId, center) => {
  const element2 = getElementById(context.container, id2);
  if (!element2)
    return;
  const column = element2.matchParent(".column");
  if (!column)
    return;
  const elementRect = element2.getBoundingClientRect();
  const rect = alignVertically(
    context,
    column,
    elementRect,
    relativeId,
    center
  );
  if (!center && (id2 === context.activeBranch.group || id2 === context.activeBranch.node)) {
    context.state.rects.set(id2, rect);
  }
};

// src/stores/view/subscriptions/effects/align-branch/run-align-branch-actions/actions/align-parents-nodes.ts
var alignParentsNodes = (context, relativeId) => {
  for (const id2 of context.activeBranch.sortedParentNodes) {
    alignElementVertically(context, id2, relativeId, true);
  }
};

// src/lib/align-element/align-group-of-elements-vertically.ts
var alignGroupOfElementsVertically = (context, column, ids, relativeId, center = true) => {
  const elements = ids.map((id2) => getElementById(context.container, id2)).filter((x) => x);
  const elementRect = getCombinedBoundingClientRect(elements);
  alignVertically(context, column, elementRect, relativeId, center);
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-child-columns/align-child-group-of-column.ts
var alignChildGroupOfColumn = (context, column, relativeId, center) => {
  const columnElement = getElementById(context.container, column.id);
  if (!columnElement)
    return;
  const childGroups = context.activeBranch.childGroups;
  const childGroupsOfColumn = column.groups.filter((g) => childGroups.has(g.parentId)).map((g) => "group-" + g.parentId);
  alignGroupOfElementsVertically(
    context,
    columnElement,
    childGroupsOfColumn,
    relativeId,
    center
  );
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-child-columns/align-child-columns.ts
var getActiveNodeOfGroup = (context, column, previousActiveNode) => {
  const activeNodesOfColumn = context.activeNodesOfColumn;
  return activeNodesOfColumn[column] && previousActiveNode ? activeNodesOfColumn[column][previousActiveNode] : null;
};
var alignChildColumns = (context, relativeId, center) => {
  const columns = context.columns;
  const activeNode = context.activeBranch.node;
  let previousActiveNode = activeNode;
  const activeNodeColumn = findNodeColumn(columns, activeNode);
  for (let i = activeNodeColumn + 1; i < columns.length; i++) {
    const column = columns[i];
    const activeNodeOfGroup = getActiveNodeOfGroup(
      context,
      column.id,
      previousActiveNode
    );
    previousActiveNode = activeNodeOfGroup;
    if (activeNodeOfGroup) {
      alignElementVertically(
        context,
        activeNodeOfGroup,
        relativeId,
        center
      );
    } else {
      const childGroups = context.activeBranch.childGroups;
      const columnHasChildGroup = !!column.groups.find(
        (g) => childGroups.has(g.parentId)
      );
      if (columnHasChildGroup) {
        alignChildGroupOfColumn(context, column, relativeId, center);
      }
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-child-columns/align-inactive-columns.ts
var alignInactiveColumns = (context) => {
  const activeNodeColumn = findNodeColumn(
    context.columns,
    context.activeBranch.node
  );
  const inactiveColumns = context.columns.filter((c, i) => {
    return i > activeNodeColumn && !c.groups.some(
      (g) => context.activeBranch.childGroups.has(g.parentId) && g.nodes.length > 0
    );
  });
  for (const column of inactiveColumns) {
    const nodes = column.groups.map((g) => g.nodes).flat();
    alignElementVertically(context, nodes[nodes.length - 1], null, true);
  }
};

// src/stores/view/subscriptions/effects/align-branch/run-align-branch-actions/run-align-branch-actions.ts
var runAlignBranchActions = (context, actions, signal) => {
  actions = actions.sort((a, b) => a.action.localeCompare(b.action));
  const activeNode = context.activeBranch.node;
  for (const action of actions) {
    if (signal.aborted)
      return;
    const type = action.action;
    if (type === "10/first-column/horizontal/move-to-the-left") {
      scrollFirstColumnToTheLeft(context);
    } else if (type === "20/active-node/horizontal/center") {
      alignElementHorizontally(context, activeNode, true, false);
    } else if (type === "20/active-node/horizontal/reveal") {
      alignElementHorizontally(context, activeNode, false, false);
    } else if (type === "20/active-node/vertical/center") {
      alignElementVertically(context, activeNode, null, true);
    } else if (type === "20/active-node/vertical/reveal") {
      alignElementVertically(context, activeNode, null, false);
    } else if (type === "20/active-node/vertical/align-with-parent") {
      alignElementVertically(
        context,
        activeNode,
        context.activeBranch.group,
        false
      );
    } else if (type === "30/parents/vertical/center") {
      alignParentsNodes(context, null);
    } else if (type === "30/parents/vertical/align-with-active-node") {
      alignParentsNodes(context, activeNode);
    } else if (type === "40/children/vertical/center") {
      alignChildColumns(context, null, true);
    } else if (type === "40/children/vertical/align-with-active-node") {
      alignChildColumns(context, activeNode, false);
    } else if (type === "50/inactive-columns/vertical/move-up") {
      alignInactiveColumns(context);
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/skip-align.ts
var skipAlign = (view, action) => {
  if (action.type === "document/update-node-content" && action.context.isInSidebar)
    return true;
  if (action.type === "view/set-active-node/mouse-silent")
    return true;
  const outlineMode = view.plugin.settings.getValue().view.outlineMode;
  if (outlineMode) {
    const viewState = view.viewStore.getValue();
    const activeNode = viewState.document.activeNode;
    if (viewState.outline.hiddenNodes.has(activeNode) && outlineMode)
      return true;
  }
};

// src/lib/align-element/helpers/wait-for-active-node-to-stop-moving.ts
var LOOP_DELAY_MS = 10;
var MAX_ATTEMPTS = 100;
var REQUIRED_MATCHES = 20;
var waitForActiveNodeToStopMoving = async (view, signal) => {
  const activeBranch = view.viewStore.getValue().document.activeBranch;
  let columnEl;
  let retries = 0;
  let hits = 0;
  let lastScrollTop = -1;
  let lastScrollLeft = -1;
  const container = view.container;
  while (retries < MAX_ATTEMPTS && !signal.aborted) {
    if (!columnEl) {
      columnEl = getElementById(container, activeBranch.column);
    } else {
      const isStill = lastScrollTop === columnEl.scrollTop && lastScrollLeft === container.scrollLeft;
      if (isStill) {
        hits++;
        if (hits === REQUIRED_MATCHES)
          return;
      } else {
        hits = 0;
      }
      lastScrollTop = columnEl.scrollTop;
      lastScrollLeft = container.scrollLeft;
    }
    retries++;
    await delay(LOOP_DELAY_MS);
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/adjust-scroll-behavior.ts
var adjustScrollBehavior = (action) => {
  let behavior = "smooth";
  if (action.type === "view/update-active-branch?source=document") {
    const documentAction = action.context.documentAction;
    const documentEvent = documentAction.type;
    if (documentEvent === "document/file/load-from-disk") {
      behavior = "instant";
    } else if (documentEvent === "document/move-node") {
      const verticalMove = documentAction.payload.direction === "down" || documentAction.payload.direction === "up";
      if (verticalMove)
        behavior = "instant";
    }
  } else if (action.type === "settings/view/set-zoom-level") {
    behavior = "instant";
  }
  return behavior;
};

// src/stores/view/subscriptions/effects/align-branch/helpers/create-context.ts
var createContext = (view, action, previousActiveBranch) => {
  const settings = view.plugin.settings.getValue();
  const container = view.container;
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const activeBranch = viewState.document.activeBranch;
  const behavior = adjustScrollBehavior(action);
  const context = {
    previousActiveBranch,
    activeBranch,
    columns: documentState.document.columns,
    container,
    activeNodesOfColumn: viewState.document.activeNodesOfColumn,
    containerRect: container.getBoundingClientRect(),
    outlineMode: settings.view.outlineMode,
    alignBranchSettings: {
      centerActiveNodeH: settings.view.scrolling.centerActiveNodeH,
      centerActiveNodeV: settings.view.scrolling.centerActiveNodeV,
      zoomLevel: settings.view.zoomLevel,
      behavior
    },
    state: {
      rects: /* @__PURE__ */ new Map()
    }
  };
  return context;
};

// src/stores/view/subscriptions/effects/align-branch/constants/action-priority.ts
var actionPriorityRecord = {
  "view/life-cycle/mount": 100,
  "view/update-active-branch?source=document": 90,
  "view/set-active-node/keyboard-jump": 90,
  "view/set-active-node/sequential/select-next": 90,
  "view/set-active-node/keyboard": 90,
  "view/set-active-node/history/select-previous": 90,
  "view/set-active-node/history/select-next": 90,
  "view/set-active-node/mouse": 90,
  "view/set-active-node/mouse-silent": 0,
  "view/set-active-node/search": 30,
  "view/align-branch/center-node": 30,
  "view/align-branch/reveal-node": 30,
  "view/selection/select-all": 30,
  "document/update-node-content": 30,
  "view/set-active-node/document": 20,
  "view/editor/disable-main-editor": 20,
  "view/editor/enable-main-editor": 20,
  "view/outline/toggle-collapse-node": 10,
  "view/outline/refresh-collapsed-nodes": 10,
  "view/outline/toggle-collapse-all": 10,
  "document/format-headings": 10,
  "view/left-sidebar/set-width": 10,
  "plugin/echo/workspace/active-leaf-change": 10,
  "plugin/echo/workspace/resize": 10,
  "plugin/echo/workspace/layout-ready": 10,
  "plugin/documents/update-active-view-of-document": 10,
  "settings/view/toggle-minimap": 10,
  "view/left-sidebar/toggle": 10,
  "settings/view/layout/set-card-width": 10,
  "settings/view/layout/set-cards-gap": 10,
  "settings/view/layout/set-min-card-height": 10,
  "view/modes/gap-between-cards/toggle": 10,
  "view/search/set-results": 10,
  "search/view/toggle-show-all-nodes": 10,
  "view/search/set-query": 10,
  "view/search/toggle-input": 10,
  "view/search/toggle-fuzzy-mode": 10,
  "settings/view/toggle-horizontal-scrolling-mode": 10,
  "settings/view/toggle-vertical-scrolling-mode": 10,
  "settings/view/layout/set-limit-card-height": 10,
  "settings/view/set-zoom-level": 10,
  "settings/view/modes/toggle-outline-mode": 10,
  "settings/view/set-node-indentation-width": 10
};
var actionPriority = new Map(
  Object.entries(actionPriorityRecord)
);

// src/stores/view/subscriptions/effects/align-branch/align-branch.ts
var AlignBranch = class {
  constructor(view) {
    this.view = view;
    this.previousEvent = null;
    this.previousActiveBranch = null;
    this.align = (action) => {
      const priority = actionPriority.get(action.type);
      if (typeof priority !== "number") {
        throw new SilentError(action.type + " not allowed");
      }
      if (this.previousEvent && !this.previousEvent.completed) {
        if (priority >= this.previousEvent.priority) {
          this.previousEvent.controller.abort();
        } else {
          return;
        }
      }
      const event = {
        action,
        priority,
        controller: new AbortController(),
        completed: false
      };
      this.run(event);
      this.previousEvent = event;
    };
    this.run = async (event) => {
      try {
        if (skipAlign(this.view, event.action)) {
          event.completed = true;
          return;
        }
        const delay_ms = delayAlign(event.action);
        if (delay_ms > 0) {
          await delay(delay_ms, event.controller.signal);
        }
        await this.view.inlineEditor.mounting;
        const context = createContext(
          this.view,
          event.action,
          this.previousActiveBranch
        );
        this.previousActiveBranch = context.activeBranch;
        const actions = createAlignBranchActions(context, event.action);
        if (!event.controller.signal.aborted) {
          requestAnimationFrame(() => {
            runAlignBranchActions(
              context,
              actions,
              event.controller.signal
            );
          });
          if (context.alignBranchSettings.behavior === "smooth") {
            await waitForActiveNodeToStopMoving(
              this.view,
              event.controller.signal
            );
          }
        }
      } catch (e) {
        logger.error(e);
      }
      event.completed = true;
    };
  }
};

// src/helpers/debounce.ts
var debounce3 = (func2, delay2) => {
  let timeoutId = null;
  return (...args) => {
    if (timeoutId)
      clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func2(...args);
    }, delay2);
  };
};

// src/stores/minimap/subscriptions/effects/update-visible-range.ts
var updateVisibleRange = async (view) => {
  const minimapStore = view.getMinimapStore();
  const state2 = minimapStore.getValue();
  const canvasId = state2.canvasId;
  const payload = await minimapWorker.run({
    type: "minimap/set/scroll-position",
    payload: {
      canvasId,
      scroll_position_cpx: state2.scrollbar.scrollPosition_cpx
    }
  });
  if (payload && "start_cpx" in payload) {
    const dom = view.getMinimapDom();
    const canvas = dom.canvas;
    requestAnimationFrame(async () => {
      const marginTop = cpx_to_dpx(payload.start_cpx) + "px";
      await minimapWorker.run({
        type: "minimap/draw-document",
        payload: {
          canvasId
        }
      });
      canvas.style.marginTop = marginTop;
    });
  }
};

// src/stores/minimap/subscriptions/effects/debounced-minimap-effects.ts
var DebouncedMinimapEffects = class {
  constructor() {
    this.drawDocument = debounce3(drawDocument, 100);
    this.updateVisibleRange = debounce3(updateVisibleRange, 16);
  }
};

// src/stores/view/subscriptions/actions/document/update-frontmatter.ts
var updateFrontmatter = (view, frontmatter) => {
  view.documentStore.dispatch({
    type: "document/file/update-frontmatter",
    payload: {
      frontmatter
    }
  });
};

// src/stores/view/subscriptions/actions/document/load-full-document.ts
var loadFullDocument = (view, data, frontmatter, format2, activeSection) => {
  view.documentStore.dispatch({
    payload: {
      document: { data, frontmatter, position: null },
      format: format2,
      activeSection
    },
    type: "document/file/load-from-disk"
  });
};

// src/stores/plugin/actions/refresh-active-view-of-document.ts
var refreshActiveViewOfDocument = (view) => {
  const views = view.plugin.app.workspace.getLeavesOfType(LINEAGE_VIEW_TYPE).map(
    (leaf) => leaf.view instanceof LineageView && leaf.view !== view && leaf.view.file ? [leaf.view.id, leaf.view.file.path] : null
  ).filter((x) => x);
  view.plugin.store.dispatch({
    type: "plugin/documents/refresh-active-view-of-document",
    payload: { views }
  });
};

// src/view/view.ts
var LINEAGE_VIEW_TYPE = "lineage";
var LineageView = class _LineageView extends import_obsidian34.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.minimapDom = null;
    this.onDestroyCallbacks = /* @__PURE__ */ new Set();
    this.onViewStoreError = (error, location, action) => {
      if (action && action.type === "document/file/load-from-disk") {
        if (this.file) {
          this.plugin.store.dispatch({
            type: "plugin/documents/unregister-document-store",
            payload: { path: this.file.path }
          });
          setViewType(this.plugin, this.file.path, "markdown");
          toggleObsidianViewType(
            this.plugin,
            this.plugin.app.workspace.getLeaf(),
            "markdown"
          );
        }
      }
      onPluginError(error, location, action);
    };
    this.saveDocument = async () => {
      invariant(this.file);
      const state2 = clone(this.documentStore.getValue());
      const data = state2.file.frontmatter + stringifyDocument(state2.document, getPersistedDocumentFormat(this));
      if (data !== this.data) {
        if (data.trim().length === 0) {
          throw new Error(lang.error_save_empty_data);
        }
        this.data = data;
        this.requestSave();
      }
    };
    this.loadInitialData = async () => {
      invariant(this.file);
      const pluginState = this.plugin.store.getValue();
      const fileHasAStore = pluginState.documents[this.file.path];
      if (fileHasAStore) {
        this.useExistingStore();
      } else {
        this.createStore();
      }
      this.loadDocumentToStore("view-mount");
      if (!this.inlineEditor) {
        this.inlineEditor = new InlineEditor(this);
        await this.inlineEditor.onload();
      }
      await this.inlineEditor.loadFile(this.file);
      this.component = new main_default({
        target: this.contentEl,
        props: {
          plugin: this.plugin,
          view: this
        }
      });
      invariant(this.container);
      this.onDestroyCallbacks.add(viewSubscriptions(this));
    };
    this.createStore = () => {
      invariant(this.file);
      this.plugin.store.dispatch({
        type: "plugin/documents/register-new-document-store",
        payload: {
          path: this.file.path,
          documentStore: this.documentStore,
          viewId: this.id
        }
      });
    };
    this.useExistingStore = () => {
      if (!this.file)
        return;
      this.documentStore = this.plugin.store.getValue().documents[this.file.path].documentStore;
    };
    this.loadDocumentToStore = (event) => {
      const { body, frontmatter } = extractFrontmatter(this.data);
      const documentState = this.documentStore.getValue();
      const viewState = this.viewStore.getValue();
      const format2 = this.getDocumentFormat(body);
      const emptyStore = documentState.history.items.length === 0;
      const existingBody = stringifyDocument(documentState.document, format2);
      const bodyHasChanged = existingBody !== body;
      const frontmatterHasChanged = frontmatter !== documentState.file.frontmatter;
      const isEditing2 = Boolean(viewState.document.editing.activeNodeId);
      const activeNode = viewState.document.activeNode;
      const activeSection = activeNode ? documentState.sections.id_section[activeNode] : null;
      if (emptyStore || bodyHasChanged && !isEditing2) {
        loadFullDocument(this, body, frontmatter, format2, activeSection);
        if (this.isActive && event !== "view-mount") {
          new import_obsidian34.Notice("Document updated externally");
        }
      } else if (frontmatterHasChanged) {
        updateFrontmatter(this, frontmatter);
      }
    };
    this.debouncedLoadDocumentToStore = (0, import_obsidian34.debounce)(
      this.loadDocumentToStore,
      250
    );
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    this.viewStore = new Store(
      defaultViewState(),
      viewReducer,
      this.onViewStoreError,
      this.documentStore.getValue().document
    );
    this.id = id.view();
    this.documentSearch = new DocumentSearch(this);
    this.rulesProcessor = new StyleRulesProcessor(this);
    this.alignBranch = new AlignBranch(this);
    this.minimapEffects = new DebouncedMinimapEffects();
  }
  get isActive() {
    return this === this.plugin.app.workspace.getActiveViewOfType(_LineageView);
  }
  get isViewOfFile() {
    const path = this.file?.path;
    return path ? this.id === this.plugin.store.getValue().documents[path]?.viewId : false;
  }
  getViewData() {
    return this.data;
  }
  setViewData(data) {
    if (!this.activeFilePath && this.file) {
      this.activeFilePath = this.file?.path;
      this.loadInitialData();
    } else {
      this.data = data;
      if (this.isViewOfFile)
        this.debouncedLoadDocumentToStore();
    }
  }
  async onUnloadFile() {
    if (this.component) {
      this.component.$destroy();
    }
    this.activeFilePath = null;
    this.contentEl.empty();
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    if (this.inlineEditor)
      await this.inlineEditor.unloadFile();
    for (const s of this.onDestroyCallbacks) {
      s();
    }
    refreshActiveViewOfDocument(this);
  }
  clear() {
    this.data = "";
  }
  getViewType() {
    return LINEAGE_VIEW_TYPE;
  }
  getIcon() {
    return customIcons.cards.name;
  }
  getDisplayText() {
    return this.file ? this.file.basename : "";
  }
  async onOpen() {
  }
  async onClose() {
    return this.onUnloadFile();
  }
  getDocumentFormat(body) {
    let format2;
    format2 = getPersistedDocumentFormat(this, false);
    if (format2) {
      return format2;
    }
    format2 = detectDocumentFormat(body) || this.plugin.settings.getValue().general.defaultDocumentFormat;
    setDocumentFormat(this.plugin, this.file.path, format2);
    return format2;
  }
  setMinimapDom(dom) {
    this.minimapDom = dom;
  }
  getMinimapDom() {
    invariant(this.minimapDom);
    return this.minimapDom;
  }
  getMinimapStore() {
    invariant(this.minimapStore);
    return this.minimapStore;
  }
};

// src/obsidian/patches/create-set-view-state.ts
function createSetViewState(plugin) {
  return function(next) {
    return function(state2, ...rest) {
      const isMarkdownView = state2.type === "markdown";
      const path = state2?.state?.file;
      if (isMarkdownView && // @ts-ignore
      plugin.viewType[path]?.viewType === LINEAGE_VIEW_TYPE && // @ts-ignore
      !state2.state.inlineEditor) {
        const newState = {
          ...state2,
          type: LINEAGE_VIEW_TYPE
        };
        return next.apply(this, [newState, ...rest]);
      } else {
        return next.apply(this, [state2, ...rest]);
      }
    };
  };
}

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/stores/settings/reducers/update-style-rules/helpers/fix-condition-types.ts
var fixConditionTypes = (rule) => {
  if (rule.condition.type === "condition") {
    const cnd = rule.condition;
    const isStringCondition = cnd.property === "headings" || cnd.property === "content";
    if (isStringCondition) {
      if (cnd.value === null || cnd.value === void 0) {
        cnd.value = "";
      } else if (typeof cnd.value === "number") {
        cnd.value = String(cnd.value);
      }
    } else {
      if (cnd.value && typeof cnd.value === "string") {
        cnd.value = parseFloat(cnd.value);
      }
      if ("valueB" in cnd && typeof cnd.valueB === "string") {
        cnd.valueB = parseFloat(cnd.valueB);
      }
    }
  }
};

// src/helpers/array-helpers/move-array-item.ts
var moveArrayItem = (array, fromIndex, toIndex) => {
  const newArray = array.slice();
  const element2 = newArray[fromIndex];
  newArray.splice(fromIndex, 1);
  newArray.splice(toIndex, 0, element2);
  return newArray;
};

// src/stores/settings/reducers/update-style-rules/handle-dnd.ts
var handleDND = (rules, payload) => {
  const { droppedId, targetId, position } = payload;
  const fromIndex = rules.findIndex((r) => r.id === droppedId);
  let toIndex = rules.findIndex((r) => r.id === targetId);
  if (fromIndex === -1 || toIndex === -1 || fromIndex === toIndex) {
    return rules;
  }
  const droppedWasAboveTarget = fromIndex < toIndex;
  if (droppedWasAboveTarget) {
    toIndex--;
  }
  if (position === "before") {
    rules = moveArrayItem(rules, fromIndex, toIndex);
  } else {
    rules = moveArrayItem(rules, fromIndex, toIndex + 1);
  }
  return rules;
};

// src/helpers/array-helpers/insert-item-at-index.ts
var insertItemAtIndex = (array, item, index) => {
  const copy = [...array];
  copy.splice(index, 0, item);
  return copy;
};

// src/stores/settings/reducers/update-style-rules/update-style-rules.ts
var updateStyleRules = (settings, action) => {
  let rulesContainer;
  rulesContainer = settings.styleRules.settings.activeTab === "global-rules" ? settings.styleRules.global : settings.styleRules.documents[action.payload.documentPath];
  if (!rulesContainer) {
    if (action.type !== "settings/style-rules/add") {
      throw new Error("Document does not have any style rules");
    }
    settings.styleRules.documents[action.payload.documentPath] = {
      rules: []
    };
    rulesContainer = settings.styleRules.documents[action.payload.documentPath];
  }
  if (action.type === "settings/style-rules/add") {
    const newRule = {
      id: id.styleRule(),
      name: "",
      enabled: true,
      condition: {
        type: "condition",
        scope: "self",
        property: "content",
        operator: "contains",
        value: "",
        enabled: true
      },
      style: {
        color: getTheme() === "light" ? "#b2ccf5" : "#274462",
        styleVariant: "background-color"
      },
      priority: 0
    };
    rulesContainer.rules = [...rulesContainer.rules, newRule];
  } else if (action.type === "settings/style-rules/update") {
    const { id: id2, rule } = action.payload;
    const index = rulesContainer.rules.findIndex((r) => r.id === id2);
    if (index !== -1) {
      rulesContainer.rules[index] = {
        ...rulesContainer.rules[index],
        ...rule
      };
      fixConditionTypes(rulesContainer.rules[index]);
      rulesContainer.rules = [...rulesContainer.rules];
    }
  } else if (action.type === "settings/style-rules/delete") {
    rulesContainer.rules = rulesContainer.rules.filter(
      (rule) => rule.id !== action.payload.id
    );
  } else if (action.type === "settings/style-rules/move") {
    rulesContainer.rules = handleDND(rulesContainer.rules, action.payload);
  } else if (action.type === "settings/style-rules/update-style") {
    const index = rulesContainer.rules.findIndex(
      (r) => r.id === action.payload.id
    );
    if (index !== -1) {
      rulesContainer.rules[index] = {
        ...rulesContainer.rules[index],
        // @ts-ignore
        style: {
          ...rulesContainer.rules[index].style,
          ...action.payload.style
        }
      };
      rulesContainer.rules = [...rulesContainer.rules];
    }
  } else if (action.type === "settings/style-rules/update-condition") {
    const { ruleId, updates } = action.payload;
    const index = rulesContainer.rules.findIndex((r) => r.id === ruleId);
    if (index !== -1) {
      rulesContainer.rules[index] = {
        ...rulesContainer.rules[index],
        // @ts-ignore
        condition: {
          ...rulesContainer.rules[index].condition,
          ...updates
        }
      };
      fixConditionTypes(rulesContainer.rules[index]);
      rulesContainer.rules = [...rulesContainer.rules];
    }
  } else if (action.type === "settings/style-rules/enable-rule") {
    const index = rulesContainer.rules.findIndex(
      (r) => r.id === action.payload.id
    );
    if (index !== -1) {
      rulesContainer.rules[index].enabled = true;
      rulesContainer.rules = [...rulesContainer.rules];
    }
  } else if (action.type === "settings/style-rules/disable-rule") {
    const index = rulesContainer.rules.findIndex(
      (r) => r.id === action.payload.id
    );
    if (index !== -1) {
      rulesContainer.rules[index].enabled = false;
      rulesContainer.rules = [...rulesContainer.rules];
    }
  } else if (action.type === "settings/style-rules/toggle-global") {
    const rule = rulesContainer.rules.find(
      (r) => r.id === action.payload.id
    );
    invariant(rule);
    rulesContainer.rules = rulesContainer.rules.filter(
      (r) => r.id !== action.payload.id
    );
    if (settings.styleRules.settings.activeTab === "global-rules") {
      let documentRules = settings.styleRules.documents[action.payload.documentPath];
      if (!documentRules) {
        settings.styleRules.documents[action.payload.documentPath] = {
          rules: []
        };
        documentRules = settings.styleRules.documents[action.payload.documentPath];
      }
      documentRules.rules = [...documentRules.rules, rule];
    } else {
      settings.styleRules.global.rules = [
        ...settings.styleRules.global.rules,
        rule
      ];
    }
  } else if (action.type === "settings/style-rules/duplicate-rule") {
    const index = rulesContainer.rules.findIndex(
      (r) => r.id === action.payload.id
    );
    const rule = rulesContainer.rules[index];
    rulesContainer.rules = insertItemAtIndex(
      rulesContainer.rules,
      {
        ...rule,
        id: id.styleRule()
      },
      index + 1
    );
  }
};

// src/stores/settings/reducers/toggle-editor-state.ts
var getDefaultHotkey = (command, type) => {
  const defaultCommand = defaultViewHotkeys().find(
    (hk) => hk.name === command
  );
  const defaultHotkey = type === "primary" ? defaultCommand?.hotkeys[0] : defaultCommand?.hotkeys[1];
  invariant(defaultHotkey);
  return defaultHotkey;
};
var editorStateValues = [
  "editor-on",
  "editor-off",
  "both"
];
var rotateEditorState = (editorState) => {
  const index = editorStateValues.indexOf(editorState);
  return editorStateValues[(index + 1) % editorStateValues.length];
};
var toggleEditorState = (state2, action) => {
  let persistedHotkey;
  const fullPersistedHotkey = state2.hotkeys.customHotkeys[action.payload.command] || {};
  if (fullPersistedHotkey[action.payload.type]) {
    persistedHotkey = fullPersistedHotkey[action.payload.type];
  }
  if (!persistedHotkey || !("editorState" in persistedHotkey)) {
    const defaultHotkey = getDefaultHotkey(
      action.payload.command,
      action.payload.type
    );
    persistedHotkey = {
      ...persistedHotkey || {},
      editorState: defaultHotkey.editorState
    };
  }
  persistedHotkey.editorState = rotateEditorState(
    persistedHotkey.editorState
  );
  state2.hotkeys.customHotkeys = {
    ...state2.hotkeys.customHotkeys,
    [action.payload.command]: {
      ...fullPersistedHotkey,
      [action.payload.type]: persistedHotkey
    }
  };
};

// src/stores/settings/reducers/set-hotkey-as-blank.ts
var setHotkeyAsBlank = (state2, action) => {
  let persistedHotkey;
  const fullPersistedHotkey = state2.hotkeys.customHotkeys[action.payload.command] || {};
  if (fullPersistedHotkey[action.payload.type]) {
    persistedHotkey = fullPersistedHotkey[action.payload.type];
  }
  persistedHotkey = {
    ...persistedHotkey || {},
    key: "",
    modifiers: []
  };
  state2.hotkeys.customHotkeys = {
    ...state2.hotkeys.customHotkeys,
    [action.payload.command]: {
      ...fullPersistedHotkey,
      [action.payload.type]: persistedHotkey
    }
  };
};

// src/stores/settings/reducers/persist-collapsed-sections.ts
var persistCollapsedSections2 = (state2, action) => {
  const documentPreferences = state2.documents[action.payload.path];
  if (!documentPreferences)
    return;
  if (!documentPreferences.outline) {
    documentPreferences.outline = {
      collapsedSections: action.payload.sections
    };
  } else {
    documentPreferences.outline.collapsedSections = action.payload.sections;
  }
};

// src/stores/settings/settings-reducer.ts
var updateState = (store, action) => {
  if (action.type === "settings/documents/delete-document-preferences") {
    delete store.documents[action.payload.path];
    delete store.styleRules.documents[action.payload.path];
  } else if (action.type === "settings/documents/set-document-format") {
    if (!store.documents[action.payload.path]) {
      store.documents[action.payload.path] = {
        documentFormat: action.payload.format,
        viewType: "lineage",
        activeSection: null,
        pinnedSections: {
          sections: [],
          activeSection: null
        },
        outline: {
          collapsedSections: []
        }
      };
    } else {
      store.documents[action.payload.path].documentFormat = action.payload.format;
    }
  } else if (action.type === "settings/documents/set-view-type") {
    if (store.documents[action.payload.path]) {
      store.documents[action.payload.path].viewType = action.payload.type;
    }
  } else if (action.type === "settings/document/persist-active-section") {
    if (store.documents[action.payload.path]) {
      store.documents[action.payload.path].activeSection = action.payload.sectionNumber;
    }
  } else if (action.type === "settings/documents/update-document-path") {
    const preferences = store.documents[action.payload.oldPath];
    delete store.documents[action.payload.oldPath];
    store.documents[action.payload.newPath] = preferences;
    if (store.styleRules.documents[action.payload.oldPath]) {
      const rules = store.styleRules.documents[action.payload.oldPath];
      delete store.styleRules.documents[action.payload.oldPath];
      store.styleRules.documents[action.payload.newPath] = rules;
    }
  } else if (action.type === "settings/hotkeys/update-custom-hotkeys") {
    store.hotkeys.customHotkeys = action.payload.customHotkeys;
  } else if (action.type === "settings/view/theme/set-font-size") {
    store.view.fontSize = action.payload.fontSize;
  } else if (action.type === "settings/view/theme/set-h1-font-size") {
    store.view.h1FontSize_em = action.payload.fontSize_em;
  } else if (action.type === "settings/view/theme/set-container-bg-color") {
    store.view.theme.containerBg = action.payload.backgroundColor;
  } else if (action.type === "settings/view/theme/set-active-branch-bg-color") {
    store.view.theme.activeBranchBg = action.payload.backgroundColor;
  } else if (action.type === "settings/view/layout/set-card-width") {
    store.view.cardWidth = action.payload.width;
  } else if (action.type === "settings/view/layout/set-min-card-height") {
    store.view.minimumCardHeight = action.payload.height;
  } else if (action.type === "settings/view/layout/set-limit-card-height") {
    store.view.limitPreviewHeight = action.payload.limit;
  } else if (action.type === "settings/documents/remove-stale-documents") {
    store.documents = { ...action.payload.documents };
  } else if (action.type === "settings/view/set-zoom-level") {
    changeZoomLevel(store, action.payload);
  } else if (action.type === "settings/general/set-default-document-format") {
    store.general.defaultDocumentFormat = action.payload.format;
  } else if (action.type === "settings/view/toggle-minimap") {
    store.view.showMinimap = !store.view.showMinimap;
  } else if (action.type === "view/left-sidebar/toggle") {
    store.view.showLeftSidebar = !store.view.showLeftSidebar;
  } else if (action.type === "settings/pinned-nodes/persist") {
    const document2 = store.documents[action.payload.filePath];
    if (!document2.pinnedSections) {
      document2.pinnedSections = {
        sections: [],
        activeSection: null
      };
    }
    document2.pinnedSections.sections = action.payload.sections;
    document2.pinnedSections.activeSection = action.payload.section;
  } else if (action.type === "settings/pinned-nodes/persist-active-node") {
    const document2 = store.documents[action.payload.filePath];
    if (!document2.pinnedSections) {
      document2.pinnedSections = {
        sections: [],
        activeSection: null
      };
    }
    document2.pinnedSections.activeSection = action.payload.section;
  } else if (action.type === "settings/view/toggle-horizontal-scrolling-mode") {
    store.view.scrolling.centerActiveNodeH = !store.view.scrolling.centerActiveNodeH;
    store.view.scrolling = {
      ...store.view.scrolling
    };
  } else if (action.type === "settings/view/toggle-vertical-scrolling-mode") {
    store.view.scrolling.centerActiveNodeV = !store.view.scrolling.centerActiveNodeV;
    store.view.scrolling = {
      ...store.view.scrolling
    };
  } else if (action.type === "settings/view/layout/set-cards-gap") {
    store.view.cardsGap = action.payload.gap;
  } else if (action.type === "view/left-sidebar/set-width") {
    if (action.payload.width > 0) {
      store.view.leftSidebarWidth = action.payload.width;
    }
  } else if (action.type === "view/left-sidebar/set-active-tab") {
    store.view.leftSidebarActiveTab = action.payload.tab;
  } else if (action.type === "view/modes/gap-between-cards/toggle") {
    store.view.applyGapBetweenCards = !store.view.applyGapBetweenCards;
  } else if (action.type === "settings/view/modes/toggle-outline-mode") {
    store.view.outlineMode = !store.view.outlineMode;
    if (store.view.outlineMode) {
      store.view.scrolling.centerActiveNodeH = false;
      store.view.scrolling = {
        ...store.view.scrolling
      };
    }
  } else if (action.type === "settings/view/set-node-indentation-width") {
    store.view.nodeIndentationWidth = action.payload.width;
  } else if (action.type === "settings/view/set-maintain-edit-mode") {
    store.view.maintainEditMode = action.payload.maintain;
  } else if (action.type === "settings/view/theme/set-inactive-node-opacity") {
    store.view.theme.inactiveNodeOpacity = action.payload.opacity;
  } else if (action.type === "settings/view/theme/set-active-branch-color") {
    if (action.payload.color) {
      store.view.theme.activeBranchColor = action.payload.color;
    } else {
      delete store.view.theme.activeBranchColor;
    }
  } else if (action.type === "settings/hotkeys/set-custom-hotkey") {
    const customHotkey = store.hotkeys.customHotkeys[action.payload.command];
    if (!customHotkey) {
      store.hotkeys.customHotkeys[action.payload.command] = {
        [action.payload.type]: action.payload.hotkey
      };
    } else {
      customHotkey[action.payload.type] = {
        ...customHotkey[action.payload.type],
        ...action.payload.hotkey
      };
    }
    store.hotkeys.customHotkeys = { ...store.hotkeys.customHotkeys };
  } else if (action.type === "settings/hotkeys/reset-custom-hotkey") {
    const customHotkey = store.hotkeys.customHotkeys[action.payload.command];
    if (customHotkey) {
      delete customHotkey[action.payload.type];
    }
    store.hotkeys.customHotkeys = { ...store.hotkeys.customHotkeys };
  } else if (action.type === "settings/hotkeys/apply-preset") {
    const entries = Object.entries(action.payload.preset);
    for (const [command, customHotkeys] of entries) {
      if (!store.hotkeys.customHotkeys[command]) {
        store.hotkeys.customHotkeys[command] = {};
      }
      if (customHotkeys.primary) {
        store.hotkeys.customHotkeys[command].primary = customHotkeys.primary;
      }
      if (customHotkeys.secondary) {
        store.hotkeys.customHotkeys[command].secondary = customHotkeys.secondary;
      }
    }
    store.hotkeys.customHotkeys = {
      ...store.hotkeys.customHotkeys
    };
  } else if (action.type === "settings/hotkeys/reset-all") {
    store.hotkeys.customHotkeys = {};
  } else if (action.type === "settings/hotkeys/toggle-editor-state") {
    toggleEditorState(store, action);
  } else if (action.type === "settings/hotkeys/set-blank") {
    setHotkeyAsBlank(store, action);
  } else if (action.type === "settings/document/persist-collapsed-sections") {
    persistCollapsedSections2(store, action);
  } else if (action.type === "settings/view/set-always-show-card-buttons") {
    store.view.alwaysShowCardButtons = action.payload.show;
  } else if (action.type === "settings/view/vertical-toolbar/set-hidden-button") {
    if (action.payload.hide) {
      store.view.hiddenVerticalToolbarButtons = Array.from(
        /* @__PURE__ */ new Set([
          ...store.view.hiddenVerticalToolbarButtons,
          action.payload.id
        ])
      );
    } else {
      store.view.hiddenVerticalToolbarButtons = store.view.hiddenVerticalToolbarButtons.filter(
        (b) => b !== action.payload.id
      );
    }
  } else if (action.type === "settings/style-rules/set-active-tab") {
    store.styleRules.settings.activeTab = action.payload.tab;
  } else if (action.type === "settings/general/set-link-pane-type") {
    store.general.linkPaneType = action.payload.position;
  } else if (action.type.startsWith("settings/style-rules")) {
    updateStyleRules(store, action);
  }
};
var settingsReducer = (store, action) => {
  updateState(store, action);
  return store;
};

// src/helpers/deep-merge.ts
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var deepMerge = (target, ...sources) => {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject2(target) && isObject2(source)) {
    for (const key in source) {
      if (isObject2(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        if (typeof target[key] === "undefined")
          Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
};

// src/obsidian/events/workspace/register-file-menu-event.ts
var import_obsidian37 = require("obsidian");

// src/obsidian/events/workspace/helpers/get-leaf-of-file.ts
var getLeafOfFile = (plugin, file, viewType) => {
  const leaves = plugin.app.workspace.getLeavesOfType(viewType);
  return leaves.find(
    (l) => l.view?.file?.path === file.path
  );
};

// src/obsidian/events/workspace/effects/toggle-file-view-type.ts
var toggleFileViewType = async (plugin, file, leaf) => {
  const documents = plugin.settings.getValue().documents;
  const preferences = documents[file.path] ? documents[file.path] : null;
  const currentViewType = preferences ? preferences.viewType : "markdown";
  let fileLeaf = leaf || getLeafOfFile(plugin, file, currentViewType);
  if (!fileLeaf)
    fileLeaf = await openFile(plugin, file, "tab");
  const newViewType = currentViewType === "markdown" ? "lineage" : "markdown";
  toggleObsidianViewType(plugin, fileLeaf, newViewType);
  setViewType(plugin, file.path, newViewType);
};

// src/obsidian/events/workspace/context-menu-itetms/add-toggle-view-menu-item.ts
var addToggleViewMenuItem = (menu, plugin, file, leaf) => {
  if (file.extension !== "md")
    return;
  menu.addItem((item) => {
    if (!leaf) {
      leaf = getLeafOfFile(plugin, file, "lineage");
    }
    const isTree = leaf && leaf.view.getViewType() === LINEAGE_VIEW_TYPE;
    item.setTitle(
      isTree ? lang.ocm_open_in_editor : lang.ocm_open_in_lineage
    );
    item.setIcon(isTree ? "file-text" : customIcons.cards.name);
    item.onClick(async () => {
      toggleFileViewType(plugin, file, leaf);
    });
  });
};

// src/obsidian/events/workspace/effects/create-lineage-file-in-folder.ts
var createLineageFileInFolder = async (plugin, folder) => {
  const newFile = await createNewFile(plugin, folder);
  if (newFile) {
    const format2 = plugin.settings.getValue().general.defaultDocumentFormat;
    await openFileInLineage(plugin, newFile, format2, "tab");
  }
};

// src/obsidian/events/workspace/context-menu-itetms/add-folder-context-menu-items.ts
var addFolderContextMenuItems = (menu, plugin, folder) => {
  menu.addItem((item) => {
    item.setTitle(lang.ocm_new_document);
    item.setIcon(customIcons.cards.name);
    item.onClick(() => createLineageFileInFolder(plugin, folder));
  });
};

// src/obsidian/events/workspace/effects/import-from-gingko/import-from-gingko.ts
var import_obsidian36 = require("obsidian");

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/verify-json-file.ts
var verifyJsonFile = (tree) => {
  for (const treeNode of tree) {
    if (!treeNode)
      return false;
    if (typeof treeNode !== "object")
      return false;
    if (!("content" in treeNode))
      return false;
    if (!("children" in treeNode))
      return false;
    if (typeof treeNode.content !== "string")
      return false;
    if (!Array.isArray(treeNode.children))
      return false;
    if (!verifyJsonFile(treeNode.children))
      return false;
  }
  return true;
};

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/map-files-to-gingko-files.ts
var mapFilesToGingkoFiles = async (plugin, files) => {
  const gingkoFiles = [];
  for (const file of files) {
    const content = await plugin.app.vault.read(file);
    const tree = JSON.parse(content);
    const isValid = verifyJsonFile(tree);
    if (!isValid)
      throw new Error(
        `File "${file.basename}" does not seem to be valid a Gingko file`
      );
    gingkoFiles.push({
      basename: file.basename,
      tree
    });
  }
  return gingkoFiles;
};

// src/obsidian/events/workspace/effects/create-new-folder.ts
var import_obsidian35 = require("obsidian");
var createNewFolder = async (plugin, folder, basename) => {
  invariant(folder);
  const children2 = folder.children.map((c) => c instanceof import_obsidian35.TFolder ? c.name : null).filter((f) => f);
  const path = getUniqueFileName(folder.path, children2, basename);
  const createdFolder = await plugin.app.vault.createFolder(path);
  invariant(createdFolder);
  return createdFolder;
};

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/create-lineage-documents-from-gingko-files.ts
var createLineageDocumentsFromGingkoFiles = async (plugin, files, folderPath) => {
  const parentFolder = plugin.app.vault.getFolderByPath(folderPath);
  invariant(parentFolder);
  let destinationFolder;
  if (files.length === 1) {
    destinationFolder = parentFolder;
  } else {
    destinationFolder = await createNewFolder(
      plugin,
      parentFolder,
      "imported from gingko"
    );
  }
  if (!destinationFolder)
    throw new Error("Could not get destination folder");
  for (const file of files) {
    const sections = jsonToHtmlComment(file.tree);
    const createdFile = await createNewFile(
      plugin,
      destinationFolder,
      sections,
      file.basename
    );
    setDocumentFormat(plugin, createdFile.path, "sections");
    setViewType(plugin, createdFile.path, "lineage");
  }
};

// src/obsidian/events/workspace/effects/import-from-gingko/import-from-gingko.ts
var importFromGingko = async (plugin, files) => {
  try {
    const parentFolder = files[0].parent?.path;
    if (!parentFolder)
      return;
    const gingkoFiles = await mapFilesToGingkoFiles(plugin, files);
    await createLineageDocumentsFromGingkoFiles(
      plugin,
      gingkoFiles,
      parentFolder
    );
    new import_obsidian36.Notice(
      `Imported ${gingkoFiles.length} Gingko file${gingkoFiles.length === 1 ? "" : "s"}`
    );
  } catch (e) {
    onPluginError(e, "command", { files });
  }
};

// src/obsidian/events/workspace/context-menu-itetms/add-import-ginkgo-menu-item.ts
var addImportGinkgoMenuItem = (menu, plugin, files) => {
  const allJson = files.every((file) => file.extension === "json");
  if (!allJson)
    return;
  menu.addItem((item) => {
    item.setTitle(lang.ocm_import_from_gingko);
    item.setIcon(customIcons.cards.name);
    item.onClick(async () => {
      importFromGingko(plugin, files);
    });
  });
};

// src/obsidian/events/workspace/register-file-menu-event.ts
var registerFileMenuEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on(
      "file-menu",
      (menu, abstractFile, source, leaf) => {
        if (abstractFile instanceof import_obsidian37.TFile) {
          addToggleViewMenuItem(menu, plugin, abstractFile, leaf);
          addImportGinkgoMenuItem(menu, plugin, [abstractFile]);
        } else if (abstractFile instanceof import_obsidian37.TFolder) {
          addFolderContextMenuItems(menu, plugin, abstractFile);
        }
      }
    )
  );
};

// src/helpers/slugify.ts
var slugify = (inputString) => {
  return inputString.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
};

// src/obsidian/commands/helpers/get-active-file.ts
var getActiveFile = (plugin) => {
  const activeFile = plugin.app.workspace.getActiveFile();
  if (activeFile && activeFile.extension === "md")
    return activeFile;
};

// src/obsidian/events/workspace/effects/create-lineage-document.ts
var createLineageDocument = async (plugin) => {
  try {
    const format2 = plugin.settings.getValue().general.defaultDocumentFormat;
    const file = getActiveFile(plugin);
    let folder = null;
    if (file) {
      folder = file.parent;
    } else {
      folder = plugin.app.vault.getRoot();
    }
    if (folder) {
      const newFile = await createNewFile(plugin, folder);
      if (newFile) {
        await openFileInLineage(plugin, newFile, format2, "tab");
      }
    }
  } catch (e) {
    onPluginError(e, "command", lang.cmd_create_new_document);
  }
};

// src/obsidian/commands/helpers/get-active-lineage-view.ts
var getActiveLineageView = (plugin) => {
  return plugin.app.workspace.getActiveViewOfType(LineageView);
};

// src/obsidian/commands/add-commands.ts
var createCommands2 = (plugin) => {
  const commands = [];
  commands.push({
    name: lang.cmd_toggle_lineage_view,
    icon: customIcons.cards.name,
    checkCallback: (checking) => {
      const file = getActiveFile(plugin);
      if (file) {
        if (checking)
          return true;
        else {
          toggleFileViewType(plugin, file, void 0);
        }
      }
    }
  });
  commands.push({
    name: lang.cmd_create_new_document,
    icon: customIcons.cards.name,
    checkCallback: (checking) => {
      if (checking)
        return true;
      createLineageDocument(plugin);
    }
  });
  commands.push({
    name: lang.cmd_toggle_horizontal_scrolling_mode,
    icon: customIcons.alignH.name,
    checkCallback: (checking) => {
      if (checking) {
        return Boolean(getActiveLineageView(plugin));
      }
      plugin.settings.dispatch({
        type: "settings/view/toggle-horizontal-scrolling-mode"
      });
    }
  });
  commands.push({
    name: lang.cmd_toggle_vertical_scrolling_mode,
    icon: customIcons.alignV.name,
    checkCallback: (checking) => {
      if (checking) {
        return Boolean(getActiveLineageView(plugin));
      }
      plugin.settings.dispatch({
        type: "settings/view/toggle-vertical-scrolling-mode"
      });
    }
  });
  commands.push({
    name: lang.cm_split_node,
    icon: customIcons.split.name,
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      openSplitNodeModal(view);
    }
  });
  commands.push({
    name: lang.cmd_sort_child_nodes_asc,
    icon: "sort-asc",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      invariant(view);
      sortChildNodes(
        view,
        view.viewStore.getValue().document.activeNode,
        "ascending"
      );
    }
  });
  commands.push({
    name: lang.cmd_sort_child_nodes_desc,
    icon: "sort-desc",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      invariant(view);
      sortChildNodes(
        view,
        view.viewStore.getValue().document.activeNode,
        "descending"
      );
    }
  });
  commands.push({
    name: lang.cm_copy_link_to_block,
    icon: "links-coming-in",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      copyLinkToBlock(view, false);
    }
  });
  commands.push({
    name: lang.cmd_toggle_pin_in_left_sidebar,
    icon: "pin",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return view ? isEditing(view) : false;
      }
      if (!view)
        return;
      const viewState = view.viewStore.getValue();
      const documentStore = view.documentStore;
      const documentState = documentStore.getValue();
      const activeNode = viewState.document.activeNode;
      const isPinned = documentState.pinnedNodes.Ids.includes(activeNode);
      documentStore.dispatch({
        type: isPinned ? "document/pinned-nodes/unpin" : "document/pinned-nodes/pin",
        payload: { id: activeNode }
      });
    }
  });
  commands.push({
    name: lang.cmd_extract_branch,
    icon: customIcons.cards.name,
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      extractBranch(view);
    }
  });
  commands.push({
    name: lang.cmd_export_branches_with_subitems,
    icon: "file-text",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      exportSelection(view, true);
    }
  });
  commands.push({
    name: lang.cmd_export_nodes_wo_subitems,
    icon: "file-text",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      exportSelection(view, false);
    }
  });
  commands.push({
    name: lang.cm_export_document,
    icon: "file-text",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      exportDocument(view);
    }
  });
  commands.push({
    name: lang.cm_eject_document,
    icon: "file-text",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      ejectDocument(view);
    }
  });
  commands.push({
    name: lang.cmd_toggle_minimap,
    icon: "panel-right",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      plugin.settings.dispatch({
        type: "settings/view/toggle-minimap"
      });
    }
  });
  commands.push({
    name: lang.cmd_toggle_left_sidebar,
    icon: "panel-left",
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      plugin.settings.dispatch({ type: "view/left-sidebar/toggle" });
    }
  });
  commands.push({
    name: lang.cmd_space_between_cards,
    icon: customIcons.gap.name,
    checkCallback: (checking) => {
      const view = getActiveLineageView(plugin);
      if (checking) {
        return Boolean(view);
      }
      view.plugin.settings.dispatch({
        type: "view/modes/gap-between-cards/toggle"
      });
    }
  });
  return commands;
};
var addCommands = (plugin) => {
  const commands = createCommands2(plugin);
  for (const command of commands) {
    plugin.addCommand({
      ...command,
      checkCallback: (checking) => {
        try {
          return command.checkCallback(checking);
        } catch (e) {
          onPluginError(e, "command", command.name);
          return false;
        }
      },
      id: slugify(command.name)
    });
  }
};

// src/stores/settings/subscriptions/settings-subscriptions.ts
var settingsSubscriptions = (plugin) => {
  return plugin.settings.subscribe((state2, action, initialRun) => {
    plugin.viewType = state2.documents;
    if (initialRun) {
      updateViewHotkeysDictionary(get_store_value(ViewHotkeysStore(plugin)));
    } else if (action) {
      if (action.type === "settings/hotkeys/reset-all" || action.type === "settings/hotkeys/apply-preset" || action.type === "settings/hotkeys/reset-custom-hotkey" || action.type === "settings/hotkeys/set-custom-hotkey" || action.type === "settings/hotkeys/toggle-editor-state" || action.type === "settings/hotkeys/set-blank") {
        updateViewHotkeysDictionary(get_store_value(ViewHotkeysStore(plugin)));
      }
    }
  });
};

// src/stores/plugin/plugin-reducer.ts
var updateState2 = (state2, action) => {
  if (action.type === "plugin/documents/unregister-document-store") {
    const path = action.payload.path;
    if (path in state2.documents) {
      const oldEntry = state2.documents[path];
      oldEntry.documentStore.set(defaultDocumentState());
      delete state2.documents[path];
    }
  } else if (action.type === "plugin/documents/update-document-path") {
    const oldPath = action.payload.oldPath;
    const newPath = action.payload.newPath;
    if (oldPath in state2.documents) {
      const oldEntry = state2.documents[oldPath];
      delete state2.documents[oldPath];
      state2.documents[newPath] = oldEntry;
    }
  } else if (action.type === "plugin/documents/register-new-document-store") {
    state2.documents[action.payload.path] = {
      documentStore: action.payload.documentStore,
      viewId: action.payload.viewId
    };
  } else if (action.type === "plugin/documents/update-active-view-of-document") {
    if (state2.documents[action.payload.path]) {
      state2.documents[action.payload.path].viewId = action.payload.viewId;
    }
  } else if (action.type === "plugin/documents/refresh-active-view-of-document") {
    for (const [viewId, filePath] of action.payload.views) {
      if (state2.documents[filePath]) {
        state2.documents[filePath].viewId = viewId;
      }
    }
  }
};
var pluginReducer = (store, action) => {
  updateState2(store, action);
  return store;
};

// src/stores/plugin/default-plugin-state.ts
var DefaultPluginState = () => ({
  documents: {}
});

// src/obsidian/status-bar/status-bar.ts
var StatusBar = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.updateAll = (view) => {
      this.updateCardsNumber(view);
      this.updateProgressIndicatorAndChildCount(view);
    };
    this.updateCardsNumber = (view) => {
      const cards2 = Object.keys(
        view.documentStore.getValue().document.content
      ).length;
      this.elements.numberOfCards.setText(
        cards2 + " section" + (cards2 === 1 ? "" : "s")
      );
    };
    this.updateProgressIndicatorAndChildCount = async (view) => {
      const document2 = view.documentStore.getValue().document;
      const activeNode = view.viewStore.getValue().document.activeNode;
      const result = await statusBarWorker.run({
        document: document2,
        activeNode
      });
      this.elements.documentProgress.setText(result.progress + " %");
    };
    this.onload();
  }
  onload() {
    this.container = this.plugin.addStatusBarItem();
    this.elements = {
      numberOfCards: this.container.createDiv(),
      // numberOfChildren: this.container.createDiv(),
      documentProgress: this.container.createDiv()
    };
    this.elements.numberOfCards.style.marginRight = "5px";
    this.elements.documentProgress.ariaLabel = "Progress through the document";
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", (x) => {
        const visible = Boolean(x && x.view instanceof LineageView);
        this.setVisibility(visible);
      })
    );
  }
  setVisibility(visible) {
    this.container.toggleClass("lineage__hidden-element", !visible);
  }
  setElementVisibility(element2, visible) {
    element2.toggleClass("lineage__hidden-element", !visible);
  }
};

// src/obsidian/patches/set-active-leaf.ts
function setActiveLeaf(next) {
  return function(leaf, param) {
    const isLineageViewAndIsEditing = leaf.view && leaf.view instanceof LineageView && leaf.view.inlineEditor?.nodeId;
    if (isLineageViewAndIsEditing)
      return;
    return next.call(this, leaf, param);
  };
}

// src/stores/settings/migrations/migrate-settings.ts
var migrateSettings = (settings) => {
  for (const [path, pref] of Object.entries(settings.documents)) {
    if (typeof pref === "boolean") {
      settings.documents[path] = {
        documentFormat: "sections",
        viewType: "lineage",
        activeSection: null,
        pinnedSections: null,
        outline: null
      };
    }
  }
  if ("backup" in settings) {
    delete settings.backup;
  }
};

// src/obsidian/events/workspace/register-files-menu-event.ts
var import_obsidian38 = require("obsidian");
var registerFilesMenuEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on("files-menu", (menu, abstractFile) => {
      const allFiles = abstractFile.every((af) => af instanceof import_obsidian38.TFile);
      if (allFiles)
        addImportGinkgoMenuItem(menu, plugin, abstractFile);
    })
  );
};

// src/obsidian/markdown-post-processors/remove-html-element-marker-in-preview-mode.ts
var removeHtmlElementMarkerInPreviewMode = (el) => {
  if (el.classList.contains("lng-prev"))
    return;
  const spans = el.querySelectorAll("span[data-section]");
  for (let i = 0; i < spans.length; i++) {
    const span = spans[i];
    const parent = span.parentElement;
    if (!parent)
      continue;
    const contents = span.childNodes;
    for (let j = 0; j < contents.length; j++) {
      const content = contents[j];
      parent.insertBefore(
        content,
        span.nextSibling ? span.nextSibling : span
      );
    }
  }
};

// src/stores/plugin/subscriptions/on-vault-event.ts
var import_obsidian39 = require("obsidian");
var onVaultEvent = (plugin) => {
  const onDeleteRef = plugin.app.vault.on("delete", (file) => {
    if (file instanceof import_obsidian39.TFile) {
      if (plugin.viewType[file.path]) {
        plugin.store.dispatch({
          type: "plugin/documents/unregister-document-store",
          payload: {
            path: file.path
          }
        });
        plugin.settings.dispatch({
          type: "settings/documents/delete-document-preferences",
          payload: {
            path: file.path
          }
        });
      }
    }
  });
  const onRenameRef = plugin.app.vault.on("rename", (file, oldPath) => {
    if (file instanceof import_obsidian39.TFile) {
      if (plugin.viewType[oldPath]) {
        plugin.store.dispatch({
          type: "plugin/documents/update-document-path",
          payload: {
            newPath: file.path,
            oldPath
          }
        });
        plugin.settings.dispatch({
          type: "settings/documents/update-document-path",
          payload: {
            newPath: file.path,
            oldPath
          }
        });
      }
    }
  });
  plugin.registerEvent(onDeleteRef);
  plugin.registerEvent(onRenameRef);
};

// src/stores/plugin/subscriptions/effects/remove-stale-documents/helpers/filter-stale-documents.ts
var filterStaleDocuments = (settings, allFiles) => {
  if (allFiles.size === 0)
    return 0;
  const paths = Object.keys(settings.documents);
  const deletedPaths = /* @__PURE__ */ new Set();
  for (const path of paths) {
    if (!allFiles.has(path)) {
      deletedPaths.add(path);
      delete settings.documents[path];
      delete settings.styleRules.documents[path];
    }
  }
  return deletedPaths.size;
};

// src/stores/plugin/subscriptions/effects/remove-stale-documents/helpers/get-all-loaded-files.ts
var import_obsidian40 = require("obsidian");
var getAllLoadedFiles = (plugin) => {
  const allFiles = plugin.app.vault.getAllLoadedFiles();
  const allPaths = /* @__PURE__ */ new Set();
  for (const maybeFile of allFiles) {
    if (maybeFile instanceof import_obsidian40.TFile) {
      allPaths.add(maybeFile.path);
    }
  }
  return allPaths;
};

// src/stores/plugin/subscriptions/effects/remove-stale-documents/remove-stale-documents.ts
var processStaleDocuments = (plugin) => {
  const settings = plugin.settings.getValue();
  const allLoadedFiles = getAllLoadedFiles(plugin);
  const deleted = filterStaleDocuments(settings, allLoadedFiles);
  if (deleted === 0)
    return;
  logger.debug(`[lineage] removed ${deleted} stale documents`);
  plugin.settings.dispatch({
    type: "settings/documents/remove-stale-documents",
    payload: {
      documents: settings.documents
    }
  });
};
var removeStaleDocuments = (plugin) => {
  plugin.registerTimeout(
    setTimeout(() => processStaleDocuments(plugin), 1e3 * 60 * 5)
  );
};

// src/stores/plugin/subscriptions/on-workspace-event.ts
var onWorkspaceEvent = (plugin) => {
  const onActiveLeafChangeRef = plugin.app.workspace.on(
    "active-leaf-change",
    (leaf) => {
      const view = leaf?.view;
      if (view instanceof LineageView && view.file?.path) {
        view.plugin.store.dispatch({
          type: "plugin/documents/update-active-view-of-document",
          payload: {
            path: view.file?.path,
            viewId: view.id
          }
        });
      }
      plugin.store.dispatch({
        type: "plugin/echo/workspace/active-leaf-change"
      });
    }
  );
  const onResizeRef = plugin.app.workspace.on("resize", () => {
    plugin.store.dispatch({
      type: "plugin/echo/workspace/resize"
    });
  });
  plugin.app.workspace.onLayoutReady(() => {
    plugin.store.dispatch({
      type: "plugin/echo/workspace/layout-ready"
    });
    removeStaleDocuments(plugin);
  });
  plugin.registerEvent(onActiveLeafChangeRef);
  plugin.registerEvent(onResizeRef);
};

// src/main.ts
var Lineage = class extends import_obsidian41.Plugin {
  constructor() {
    super(...arguments);
    this.timeoutReferences = /* @__PURE__ */ new Set();
    this.viewType = {};
  }
  async onload() {
    await this.loadSettings();
    this.store = new Store(
      DefaultPluginState(),
      pluginReducer,
      onPluginError
    );
    loadCustomIcons();
    this.registerView(
      LINEAGE_VIEW_TYPE,
      (leaf) => new LineageView(leaf, this)
    );
    addCommands(this);
    this.registerPatches();
    this.registerEvents();
    this.statusBar = new StatusBar(this);
    this.loadRibbonIcon();
    this.registerMarkdownPostProcessor(
      removeHtmlElementMarkerInPreviewMode
    );
  }
  async saveSettings() {
    await this.saveData(this.settings.getValue());
  }
  async loadSettings() {
    const rawSettings = await this.loadData() || {};
    const settings = deepMerge(rawSettings, DEFAULT_SETTINGS());
    migrateSettings(settings);
    this.settings = new Store(
      settings,
      settingsReducer,
      onPluginError
    );
    this.settings.subscribe(() => {
      this.saveSettings();
    });
    settingsSubscriptions(this);
  }
  registerEvents() {
    registerFileMenuEvent(this);
    registerFilesMenuEvent(this);
    onVaultEvent(this);
    onWorkspaceEvent(this);
  }
  registerTimeout(timeout) {
    this.timeoutReferences.add(timeout);
  }
  registerPatches() {
    this.register(around(this.app.workspace, { setActiveLeaf }));
    const setViewState = createSetViewState(this);
    this.register(around(import_obsidian41.WorkspaceLeaf.prototype, { setViewState }));
  }
  loadRibbonIcon() {
    this.addRibbonIcon(
      customIcons.cards.name,
      "Toggle Lineage view",
      () => {
        const file = getActiveFile(this);
        if (file)
          toggleFileViewType(this, file, void 0);
        else
          createLineageDocument(this);
      }
    );
  }
  onunload() {
    super.onunload();
    for (const timeout of this.timeoutReferences) {
      clearTimeout(timeout);
    }
    minimapWorker.terminate();
    rulesWorker.terminate();
    statusBarWorker.terminate();
  }
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-left.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-down.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/clipboard-paste.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/clock.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/copy.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/eye.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-minus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-output.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-plus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-symlink.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-text.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/focus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/globe.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/grip-vertical.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/heading-1.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/history.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/info.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/keyboard.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/merge.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/minus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/more-vertical.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/palette.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/panel-left-dashed.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/panel-right-dashed.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pencil.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pin.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/plus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/redo-2.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-ccw.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-cw.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/save.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/scan-search.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/scissors.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/search.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/settings.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/split.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/text.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/trash.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/undo-2.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/x.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/

/* nosourcemap */